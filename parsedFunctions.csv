File,FnId,Body
"../test-repos/AFASSoftware_maquette/src/h.ts","h","no body"
"../test-repos/AFASSoftware_maquette/src/h.ts","h","no body"
"../test-repos/AFASSoftware_maquette/src/h.ts","h","{  if (Array.isArray(properties)) {  children = properties;  properties = undefined;  } else if (  (properties && (typeof properties === 'string' || properties.hasOwnProperty('vnodeSelector'))) ||  (children && (typeof children === 'string' || children.hasOwnProperty('vnodeSelector')))) {  throw new Error('h called with invalid arguments');  }  let text: string | undefined;  let flattenedChildren: VNode[] | undefined;  // Recognize a common special case where there is only a single text node  if (children !== undefined && children.length === 1 && typeof children[0] === 'string') {  text = children[0] as string;  } else if (children) {  flattenedChildren = [];  appendChildren(selector, children, flattenedChildren);  if (flattenedChildren.length === 0) {  flattenedChildren = undefined;  }  }  return {  vnodeSelector: selector,  properties: properties,  children: flattenedChildren,  text: (text === '') ? undefined : text,  domNode: null  }; }"
"../test-repos/DanielYKPan_date-time-picker/src/date-time/adapter/native-date-time-adapter.class.ts","range","{  const valuesArray = Array(length);  for (let i = 0; i < length; i++) {  valuesArray[i] = valueFunction(i);  }  return valuesArray; }"
"../test-repos/DanielYKPan_date-time-picker/src/date-time/date-time-picker.component.ts","OWL_DTPICKER_SCROLL_STRATEGY_PROVIDER_FACTORY","{  return () => overlay.scrollStrategies.block(); }"
"../test-repos/DanielYKPan_date-time-picker/src/utils/object.utils.ts","extendObject","{  if (dest == null) {  throw TypeError('Cannot convert undefined or null to object');  }   for (const source of sources) {  if (source != null) {  for (const key in source) {  if (source.hasOwnProperty(key)) {  dest[key] = source[key];  }  }  }  }   return dest; }"
"../test-repos/DanielYKPan_date-time-picker/src/dialog/dialog.service.ts","OWL_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY","{  return () => overlay.scrollStrategies.block(); }"
"../test-repos/DanielYKPan_date-time-picker/src/dialog/dialog.service.ts","applyConfigDefaults","{  return extendObject(new OwlDialogConfig(), config, defaultOptions); }"
"../test-repos/DavideViolante_Angular-Full-Stack/server/routes.ts","setRoutes","{   const router = express.Router();   const catCtrl = new CatCtrl();  const userCtrl = new UserCtrl();   // Cats  router.route('/cats').get(catCtrl.getAll);  router.route('/cats/count').get(catCtrl.count);  router.route('/cat').post(catCtrl.insert);  router.route('/cat/:id').get(catCtrl.get);  router.route('/cat/:id').put(catCtrl.update);  router.route('/cat/:id').delete(catCtrl.delete);   // Users  router.route('/login').post(userCtrl.login);  router.route('/users').get(userCtrl.getAll);  router.route('/users/count').get(userCtrl.count);  router.route('/user').post(userCtrl.insert);  router.route('/user/:id').get(userCtrl.get);  router.route('/user/:id').put(userCtrl.update);  router.route('/user/:id').delete(userCtrl.delete);   // Apply the routes to our application with the prefix /api  app.use('/api', router);  }"
"../test-repos/DavideViolante_Angular-Full-Stack/client/app/app.module.ts","tokenGetter","{  return localStorage.getItem('token'); }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","createResponse","{  return {status: SuccessStatus, sessionId: request.params.sessionId, value}; }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","isWebdriverResponse","{  return value && typeof value === 'object' && typeof (value as any).status === 'number'; }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","withCallback","{  return new Promise((resolve, reject) => {  fn((err, res) => {  if (err) return reject(err);  else resolve((res as any));  })  }); }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","htmlCollectionToArray","{  const result = [];  for (let i = 0; i < elements.length; i++) {  result.push(elements[i]);  }  return result;  }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","isInput","{  return element.tagName === 'INPUT'; }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","isInputlike","{  return element.tagName === 'TEXTAREA' || element.tagName === 'INPUT'; }"
"../test-repos/ForbesLindesay_taxi-rank/src/Webdriver.ts","isForm","{  return element.tagName === 'FORM'; }"
"../test-repos/ForbesLindesay_taxi-rank/src/WebdriverUrlMap.ts","register","{  methods.push({method, path, fn}); }"
"../test-repos/ForbesLindesay_taxi-rank/src/eventChannel.ts","eventChannel","{  const handlers: Set<(value: T) => void> = new Set();  function on(handler: (value: T) => void) {  handlers.add(handler);  return () => {  handlers.delete(handler);  };  }  (on as any).emit = (value: T) => {  handlers.forEach(fn => fn(value));  };  return (on as any); }"
"../test-repos/ForbesLindesay_taxi-rank/src/eventChannel.ts","on","{  handlers.add(handler);  return () => {  handlers.delete(handler);  };  }"
"../test-repos/ForbesLindesay_taxi-rank/src/index.ts","startServer","{  const app = express();   app.use(json());  app.get('/version', (req, res, next) => {  res.json(require('../package.json').version);  });   function isStorageLevel(str: string): str is StorageLevel {  return str === StorageLevel.Local || str === StorageLevel.Session;  }   const driver = new Webdriver();  urlMap.forEach(pattern => {  (app as any)[pattern.method](pattern.path, (req: express.Request, res: express.Response, next: express.NextFunction) => {  if (req.params.storageLevel && !isStorageLevel(req.params.storageLevel)) {  return next();  }  (driver as any)[pattern.fn](req).then(  (result: any) => res.json(result),  (err: any) => res.json({status: WebdriverStatus.UnknownError, value: {message: err.stack}}),  ).catch(next);  });  });   app.use((req, res, next) => {  res.json({status: WebdriverStatus.UnknownCommand, value: {message: `Unknown method: '${req.method}' '${req.path}'`}});  });   return app.listen(options.port || 9516, options.onStart); }"
"../test-repos/ForbesLindesay_taxi-rank/src/index.ts","isStorageLevel","{  return str === StorageLevel.Local || str === StorageLevel.Session;  }"
"../test-repos/HsuanXyz_ion2-calendar/dev/src/ion2-calendar/calendar.module.ts","calendarController","{  return new CalendarController(modalCtrl, calSvc); }"
"../test-repos/HsuanXyz_ion2-calendar/src/calendar.module.ts","calendarController","{  return new CalendarController(modalCtrl, calSvc); }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","erc20Approve","{  const erc20Token = Erc20Contract.at(tokenAddr);  const realAmount = amount * Math.pow(10, decimals);  await erc20Token.approve(spender, realAmount, {from: tokenOwner}); }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","size2Ring01","{  const orderPrams1 = {  loopringProtocol: mainnetLoopringAddr,  tokenS: mainnetEosAddr,  tokenB: mainnetZrxAddr,  amountS: new BigNumber(3e18),  amountB: new BigNumber(8e18),  validSince: new BigNumber(this.currBlockTimeStamp * 1000),  validUntil: new BigNumber((this.currBlockTimeStamp + 360000) * 1000),  lrcFee: new BigNumber(2e18),  buyNoMoreThanAmountB: true,  marginSplitPercentage: 55,  };   const orderPrams2 = {  loopringProtocol: mainnetLoopringAddr,  tokenS: mainnetZrxAddr,  tokenB: mainnetEosAddr,  amountS: new BigNumber(8e18),  amountB: new BigNumber(3e18),  validSince: new BigNumber(this.currBlockTimeStamp * 1000),  validUntil: new BigNumber((this.currBlockTimeStamp + 360000) * 1000),  lrcFee: new BigNumber(15e17),  buyNoMoreThanAmountB: false,  marginSplitPercentage: 0,  };   const order1 = new Order(order1Owner, orderPrams1);  const order2 = new Order(order2Owner, orderPrams2);  order1.web3Instance = web3;  order2.web3Instance = web3;   await order1.signAsync();  await order2.signAsync();   const ring = new Ring(ringOwner, [order1, order2]);  ring.web3Instance = web3;  await ring.signAsync();   return ring; }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","size3Ring01","{   const orderPrams1 = {  loopringProtocol: mainnetLoopringAddr,  tokenS: mainnetEosAddr,  tokenB: mainnetZrxAddr,  amountS: new BigNumber(20e18),  amountB: new BigNumber(60e18),  validSince: new BigNumber(this.currBlockTimeStamp * 1000),  validUntil: new BigNumber((this.currBlockTimeStamp + 360000) * 1000),  lrcFee: new BigNumber(2e18),  buyNoMoreThanAmountB: true,  marginSplitPercentage: 55,  };   const orderPrams2 = {  loopringProtocol: mainnetLoopringAddr,  tokenS: mainnetZrxAddr,  tokenB: mainnetBnbAddr,  amountS: new BigNumber(50e18),  amountB: new BigNumber(10e18),  validSince: new BigNumber(this.currBlockTimeStamp * 1000),  validUntil: new BigNumber((this.currBlockTimeStamp + 360000) * 1000),  lrcFee: new BigNumber(15e17),  buyNoMoreThanAmountB: false,  marginSplitPercentage: 0,  };   const orderPrams3 = {  loopringProtocol: mainnetLoopringAddr,  tokenS: mainnetBnbAddr,  tokenB: mainnetEosAddr,  amountS: new BigNumber(10e18),  amountB: new BigNumber(15e18),  validSince: new BigNumber(this.currBlockTimeStamp * 1000),  validUntil: new BigNumber((this.currBlockTimeStamp + 360000) * 1000),  lrcFee: new BigNumber(25e17),  buyNoMoreThanAmountB: false,  marginSplitPercentage: 60,  };   const order1 = new Order(order1Owner, orderPrams1);  const order2 = new Order(order2Owner, orderPrams2);  const order3 = new Order(order3Owner, orderPrams3);  order1.web3Instance = web3;  order2.web3Instance = web3;  order3.web3Instance = web3;   await order1.signAsync();  await order2.signAsync();  await order3.signAsync();   const ring = new Ring(ringOwner, [order1, order2, order3]);  ring.web3Instance = web3;   await ring.signAsync();   return ring; }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","submit","{  const contractInstance = ProtocolContract.at(mainnetLoopringAddr);  const tx = await contractInstance.submitRing(p.addressList,  p.uintArgsList,  p.uint8ArgsList,  p.buyNoMoreThanAmountBList,  p.vList,  p.rList,  p.sList,  p.ringOwner,  p.feeRecepient,  {from: p.ringOwner, gas: 900000, gasPrice: 5000000000});  console.log('tx: ', tx); }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","approve","{  await erc20Approve(mainnetEosAddr, order1Owner, delegateAddr, 200, 18);  await erc20Approve(mainnetZrxAddr, order2Owner, delegateAddr, 200, 18);  await erc20Approve(mainnetBnbAddr, order3Owner, delegateAddr, 200, 18);   await erc20Approve(mainnetLrcAddr, order1Owner, delegateAddr, 100, 18);  await erc20Approve(mainnetLrcAddr, order2Owner, delegateAddr, 100, 18);  await erc20Approve(mainnetLrcAddr, order3Owner, delegateAddr, 100, 18); }"
"../test-repos/Loopring_protocol/util/submit_rings.ts","main","{  // const ring = await size2Ring01();  // const feeSelectionList = [0, 0];   const ring = await size3Ring01();  const feeSelectionList = [0, 0, 0];   const ringFactory = new RingFactory('', '', '', '', '', 0);  const params = ringFactory.ringToSubmitableParams(ring,  feeSelectionList,  ring.owner);   const json = JSON.stringify(params);  const outFile = '/tmp/ring.json';  fs.writeFileSync(outFile, json);   await submit(params); }"
"../test-repos/Microsoft_satcheljs/test/legacy/createUndoTests.ts","resetState","{  _.resetGlobalState();  __resetGlobalContext(); }"
"../test-repos/Microsoft_satcheljs/test/legacy/stitch/stitchTests.ts","getNext","{  return (action, actionType, args) => {  sequenceOfEvents.push({  actionType,  args,  });   return returnValue;  }; }"
"../test-repos/Microsoft_satcheljs/test/legacy/stitch/stitchTests.ts","getArguments","{  return arguments; }"
"../test-repos/Microsoft_satcheljs/test/legacy/promise/actionWrappersTests.ts","fulfillPromise","{  return originalThenSpy.calls.argsFor(0)[0](arg);  }"
"../test-repos/Microsoft_satcheljs/test/legacy/promise/actionWrappersTests.ts","rejectPromiseInThen","{  return originalThenSpy.calls.argsFor(0)[1](arg);  }"
"../test-repos/Microsoft_satcheljs/test/legacy/promise/actionWrappersTests.ts","rejectPromiseInCatch","{  return originalCatchSpy.calls.argsFor(0)[0](arg);  }"
"../test-repos/Microsoft_satcheljs/test/legacy/promise/installTests.ts","setupPromise","{  spyOn(actionWrappers, 'wrapThen').and.returnValue(wrappedThen);  spyOn(actionWrappers, 'wrapCatch').and.returnValue(wrappedCatch);  }"
"../test-repos/Microsoft_satcheljs/test/legacy/promise/installTests.ts","resetPromise","{  Promise.prototype.then = originalThen;  Promise.prototype.catch = originalCatch;  }"
"../test-repos/Microsoft_satcheljs/src/applyMiddleware.ts","applyMiddleware","{  var next: DispatchFunction = finalDispatch;  for (var i = middleware.length - 1; i >= 0; i--) {  next = applyNextMiddleware(middleware[i], next);  }   getGlobalContext().dispatchWithMiddleware = next; }"
"../test-repos/Microsoft_satcheljs/src/applyMiddleware.ts","applyNextMiddleware","{  return actionMessage => middleware(next, actionMessage); }"
"../test-repos/Microsoft_satcheljs/src/createStore.ts","createStore","{  createStoreAction(key, initialState);  return () => <T>getRootStore().get(key); }"
"../test-repos/Microsoft_satcheljs/src/orchestrator.ts","orchestrator","{  let actionId = getPrivateActionId(actionCreator);  if (!actionId) {  throw new Error('Orchestrators can only subscribe to action creators.');  }   subscribe(actionId, target);  return target; }"
"../test-repos/Microsoft_satcheljs/src/actionCreator.ts","actionCreator","{  return createActionCreator(actionType, target, false); }"
"../test-repos/Microsoft_satcheljs/src/actionCreator.ts","action","{  return createActionCreator(actionType, target, true); }"
"../test-repos/Microsoft_satcheljs/src/actionCreator.ts","createActionCreator","{  let actionId = createActionId();   let decoratedTarget = function createAction(...args: any[]) {  // Create the action message  let actionMessage: ActionMessage = target ? target.apply(null, args) : {};   // Stamp the action type  if (actionMessage.type) {  throw new Error('Action creators should not include the type property.');  }   // Stamp the action message with the type and the private ID  actionMessage.type = actionType;  setPrivateActionId(actionMessage, actionId);   // Dispatch if necessary  if (shouldDispatch) {  dispatch(actionMessage);  }   return actionMessage;  } as TActionCreator;   // Stamp the action creator function with the private ID  setPrivateActionId(decoratedTarget, actionId);  return decoratedTarget; }"
"../test-repos/Microsoft_satcheljs/src/actionCreator.ts","getPrivateActionId","{  return target.__SATCHELJS_ACTION_ID; }"
"../test-repos/Microsoft_satcheljs/src/actionCreator.ts","setPrivateActionId","{  target.__SATCHELJS_ACTION_ID = actionId; }"
"../test-repos/Microsoft_satcheljs/src/legacy/functionInternals.ts","setOriginalTarget","{  decoratedTarget.__SATCHELJS_ORIGINAL_TARGET = originalTarget; }"
"../test-repos/Microsoft_satcheljs/src/legacy/functionInternals.ts","getOriginalTarget","{  if (typeof decoratedTarget.__SATCHELJS_ORIGINAL_TARGET !== typeof undefined) {  return decoratedTarget.__SATCHELJS_ORIGINAL_TARGET;  }   return undefined; }"
"../test-repos/Microsoft_satcheljs/src/legacy/functionInternals.ts","setActionType","{  decoratedTarget.__SATCHELJS_ACTION_TYPE = actionType; }"
"../test-repos/Microsoft_satcheljs/src/legacy/functionInternals.ts","getActionType","{  return (<any>decoratedTarget).__SATCHELJS_ACTION_TYPE; }"
"../test-repos/Microsoft_satcheljs/src/legacy/trace/trace.ts","trace","{  log('Executing action: ' + (actionType ? actionType : '(anonymous action)'));   try {  depth++;  return next(action, actionType, args, actionContext);  } finally {  depth--;  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/trace/trace.ts","log","{  let indentation = new Array(depth + 1).join(' ');  /* tslint:disable:no-console */  console.log(indentation + message);  /* tslint:enable:no-console */ }"
"../test-repos/Microsoft_satcheljs/src/legacy/createUndo.ts","initializeSpy","{  if (spyRefCount === 0) {  spyDisposer = spy(spyOnChanges);  }  spyRefCount++; }"
"../test-repos/Microsoft_satcheljs/src/legacy/createUndo.ts","disposeSpy","{  spyRefCount--;  if (spyRefCount === 0) {  spyDisposer();  spyDisposer = null;  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/createUndo.ts","spyOnChanges","{  let undoStep: UndoStep;  let modifiedObject = event.object;   switch (event.type) {  case 'update':  if (event.index !== undefined) {  // update (array)  undoStep = {  verify: () => modifiedObject[event.index] === event.newValue,  objectName: modifiedObject.$mobx.name,  propertyName: event.index,  undo: () => {  modifiedObject[event.index] = event.oldValue;  },  };  } else if (typeof modifiedObject.get !== 'undefined') {  // update (map)  undoStep = {  verify: () => modifiedObject.get(event.name) === event.newValue,  objectName: modifiedObject.$mobx.name,  propertyName: event.name,  undo: () => {  modifiedObject.set(event.name, event.oldValue);  },  };  } else {  // update (object)  undoStep = {  verify: () => modifiedObject[event.name] === event.newValue,  objectName: modifiedObject.$mobx.name,  propertyName: event.name,  undo: () => {  modifiedObject[event.name] = event.oldValue;  },  };  }  break;  case 'splice':  undoStep = {  verify: () => {  for (let i = 0; i < event.addedCount; i++) {  if (modifiedObject[event.index + i] !== event.added[i]) {  return false;  }  }  return true;  },  objectName: modifiedObject.$mobx.name,  propertyName: event.index,  undo: () => {  // First, remove the added items.  // Then, add items back one at a time, because passing an array in to 'splice' will insert the array as a single item  modifiedObject.splice(event.index, event.addedCount);  for (let i = 0; i < event.removedCount; i++) {  modifiedObject.splice(event.index + i, 0, event.removed[i]);  }  },  };  break;  case 'add':  if (typeof modifiedObject.get !== 'undefined') {  // add (map)  undoStep = {  verify: () => modifiedObject.get(event.name) === event.newValue,  objectName: modifiedObject.$mobx.name,  propertyName: event.name,  undo: () => {  modifiedObject.delete(event.name);  },  };  } else {  // add (object)  undoStep = {  verify: () => modifiedObject[event.name] === event.newValue,  objectName: modifiedObject.$mobx.name,  propertyName: event.name,  undo: () => {  delete modifiedObject[event.name];  },  };  }  break;  case 'delete':  undoStep = {  verify: () => !modifiedObject.has(event.name),  objectName: modifiedObject.$mobx.name,  propertyName: event.name,  undo: () => {  modifiedObject.set(event.name, event.oldValue);  },  };  break;  default:  // Nothing worth tracking  return;  }   undoWindows.forEach(undoWindow => undoWindow.steps.push(undoStep)); }"
"../test-repos/Microsoft_satcheljs/src/legacy/createUndo.ts","trackUndo","{  initializeSpy();  undoWindows.push({ steps: [] });   try {  let returnValue: T = action();   let undoWindow: UndoWindow = undoWindows[undoWindows.length - 1];  let undoPreviouslyExecuted = false;   // Reverse the steps, as changes made later in the action may depend on changes earlier in the action  undoWindow.steps.reverse();   let undo: UndoResult<T> = satcheljsAction(`undo-${actionName}`)(() => {  if (undoPreviouslyExecuted) {  throw `This instance of undo-${actionName} has already been executed`;  }  if (undoVerifiesChanges) {  undoWindow.steps.forEach(step => {  if (!step.verify()) {  throw `Property '${step.propertyName} on store object '${step.objectName} changed since action was performed.`;  }  });  }  undoWindow.steps.forEach(step => step.undo());  undoPreviouslyExecuted = true;  });   undo.actionReturnValue = returnValue;   return undo;  } finally {  undoWindows.pop();  disposeSpy();  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/createUndo.ts","createUndo","{  return (action: () => T) => {  return trackUndo(actionName, action, !!undoVerifiesChanges);  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/select.ts","createCursorFromSelector","{  let state: any = {};   Object.keys(selector).forEach((key: keyof T) => {  if (typeof state[key] === typeof undefined) {  Object.defineProperty(state, key, {  enumerable: true,  get: () => selector[key].apply(null, args),  });  }  });   Object.freeze(state);   return state; }"
"../test-repos/Microsoft_satcheljs/src/legacy/select.ts","select","{  return function decorator<Target extends Function>(target: Target): Target {  // do not execute the selector function in test mode, simply returning  // the target that was passed in  if (getGlobalContext().legacyTestMode) {  return target;  }   let context = this;  let argumentPosition = target.length - 1;  let actionTarget = getOriginalTarget(target);   if (actionTarget) {  argumentPosition = actionTarget.length - 1;  }   let returnValue: any = function() {  let state = createCursorFromSelector<T>(selector, arguments);  let args = Array.prototype.slice.call(arguments);  if (typeof args[argumentPosition] === typeof undefined) {  for (var i = args.length; i < argumentPosition; i++) {  args[i] = undefined;  }  args[argumentPosition] = state;  }  return target.apply(context, args);  };   setActionType(returnValue, getActionType(<any>target));  return <Target>returnValue;  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/legacyApplyMiddleware.ts","applyMiddleware","{  var next: LegacyDispatchFunction = finalDispatch;  for (var i = middleware.length - 1; i >= 0; i--) {  next = applyMiddlewareInternal(middleware[i], next);  }   getGlobalContext().legacyDispatchWithMiddleware = next; }"
"../test-repos/Microsoft_satcheljs/src/legacy/legacyApplyMiddleware.ts","applyMiddlewareInternal","{  return (action, actionType, args, actionContext) =>  middleware(next, action, actionType, args, actionContext); }"
"../test-repos/Microsoft_satcheljs/src/legacy/legacyApplyMiddleware.ts","dispatchWithMiddleware","{  if (!getGlobalContext().legacyDispatchWithMiddleware) {  getGlobalContext().legacyDispatchWithMiddleware = finalDispatch;  }   getGlobalContext().legacyDispatchWithMiddleware(action, actionType, args, actionContext); }"
"../test-repos/Microsoft_satcheljs/src/legacy/legacyApplyMiddleware.ts","finalDispatch","{  return action(); }"
"../test-repos/Microsoft_satcheljs/src/legacy/action.ts","action","{  return function createAction(arg0: any, arg1: any, arg2: any) {  if (arguments.length == 1 && typeof arg0 == 'function') {  return wrapFunctionInAction(arg0, actionType, actionContext);  } else {  decorateClassMethod(arg0, arg1, arg2, actionType, actionContext);  }  } as ActionFactory; }"
"../test-repos/Microsoft_satcheljs/src/legacy/action.ts","wrapFunctionInAction","{  let decoratedTarget: T = <T>function() {  let returnValue: any;  let passedArguments = arguments;   dispatch(  () => {  returnValue = target.apply(this, passedArguments);  return returnValue;  },  actionType,  arguments,  actionContext  );   return returnValue;  };   setOriginalTarget(decoratedTarget, target);  setActionType(decoratedTarget, actionType);   return decoratedTarget; }"
"../test-repos/Microsoft_satcheljs/src/legacy/action.ts","decorateClassMethod","{  if (descriptor && typeof descriptor.value == 'function') {  descriptor.value = wrapFunctionInAction(descriptor.value, actionType, actionContext);  } else {  throw new Error('The @action decorator can only apply to class methods.');  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/stitch/stitch.ts","stitch","{  let returnValue = next(action, actionType, args, actionContext);   if (actionType && handlers[actionType]) {  handlers[actionType].forEach(handler => handler.apply(null, args));  }   return returnValue; }"
"../test-repos/Microsoft_satcheljs/src/legacy/stitch/stitch.ts","subscribe","{  if (!handlers[actionType]) {  handlers[actionType] = [];  }   handlers[actionType].push(callback); }"
"../test-repos/Microsoft_satcheljs/src/legacy/stitch/stitch.ts","raise","{  console.error('[satcheljs-stitch] The 'raise' API is deprecated. Use 'raiseAction' instead.');   // Create a no-op action to execute  let actionToExecute = action(actionType)(() => {});   if (callback) {  // Pass it to the callback so that the consumer can call it with arguments  callback(<T>actionToExecute);  } else {  // No callback was provided, so just execute it with no arguments  actionToExecute();  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/stitch/stitch.ts","raiseAction","{  // Create a no-op action to execute  return <T>action(actionType)(() => {}); }"
"../test-repos/Microsoft_satcheljs/src/legacy/dispatch.ts","dispatch","{  getGlobalContext().legacyInDispatch++;   mobxAction(actionType ? actionType : '(anonymous action)', () => {  dispatchWithMiddleware(action, actionType, args, actionContext);  })();   getGlobalContext().legacyInDispatch--; }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/install.ts","install","{  let originalThen = Promise.prototype.then;  let originalCatch = Promise.prototype.catch;   Promise.prototype.then = wrapThen(originalThen);  Promise.prototype.catch = wrapCatch(originalCatch);   return function uninstall() {  Promise.prototype.then = originalThen;  Promise.prototype.catch = originalCatch;  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/promiseMiddleware.ts","getCurrentAction","{  return actionStack.length ? actionStack[actionStack.length - 1] : null; }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/promiseMiddleware.ts","promiseMiddleware","{  // If we're not already installed, install now  if (!isInstalled) {  uninstall = install();  isInstalled = true;  }   try {  actionStack.push(actionType);  return next(action, actionType, args, actionContext);  } finally {  actionStack.pop();   // If we're no longer in an action, uninstall  if (!actionStack.length) {  uninstall();  isInstalled = false;  }  } }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/actionWrappers.ts","wrapThen","{  return function wrappedThen(onFulfilled?: Function, onRejected?: Function) {  return originalThen.call(  this,  wrapInAction(onFulfilled, 'then'),  wrapInAction(onRejected, 'then_rejected')  );  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/actionWrappers.ts","wrapCatch","{  return function wrappedCatch(onRejected?: Function) {  return originalCatch.call(this, wrapInAction(onRejected, 'catch'));  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/promise/actionWrappers.ts","wrapInAction","{  let currentAction = getCurrentAction();  if (!currentAction || !callback) {  return callback;  }   let actionName = currentAction + ' => ' + callbackType;  return function() {  let returnValue;  let args = arguments;  action(actionName)(() => {  returnValue = callback.apply(null, args);  })();   return returnValue;  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","setPropAccessors","{  let newProps: any = {};   Object.keys(props).forEach(key => {  newProps[key] = props[key];  });   Object.keys(selector).forEach((key: keyof T) => {  let getter = selector[key];   if (typeof newProps[key] === typeof undefined) {  Object.defineProperty(newProps, key, {  enumerable: true,  get: () => getter.call(null, newProps),  });  }  });   return newProps; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","createNewConstructor","{  if (!selector) {  return original;  }   return class extends React.Component<any, any> {  render() {  return React.createElement(original, setPropAccessors(this.props, selector));  }  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","createNewFunctionalComponent","{  if (!selector) {  return original;  }   return function(props: any) {  let newProps = setPropAccessors(props, selector);  return (<Function>original).call(original, newProps);  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","isReactComponent","{  return target && target.prototype && target.prototype.isReactComponent; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","isFunction","{  return target instanceof Function; }"
"../test-repos/Microsoft_satcheljs/src/legacy/react/reactive.ts","reactive","{  // this check only applies to ES6 React Class Components  if (isReactComponent(selectorOrComponentClass)) {  let componentClass = selectorOrComponentClass as React.ComponentClass<any>;  return observer(componentClass);  }   return function<Target extends React.ReactType>(target: Target) {  if (getGlobalContext().legacyTestMode) {  if (isReactComponent(target)) {  return observer(target as React.ComponentClass<any>);  } else if (isFunction(target)) {  return observer(target as React.StatelessComponent<any>);  }   return target;  }   let newComponent: any;   if (isReactComponent(target)) {  // Double layer of observer here so that mobx will flow down the observation  newComponent = observer(  createNewConstructor(  observer(target as React.ComponentClass<any>),  selectorOrComponentClass as SelectorFunction<T>  ) as React.ComponentClass<any>  );  newComponent.nonReactiveComponent = target as React.ComponentClass<any>;  return newComponent;  } else if (isFunction(target)) {  newComponent = observer(  createNewFunctionalComponent(  target as React.StatelessComponent<any>,  selectorOrComponentClass as SelectorFunction<T>  )  );  newComponent.nonReactiveStatelessComponent = target as React.StatelessComponent<any>;  return newComponent;  }   return <T>newComponent;  }; }"
"../test-repos/Microsoft_satcheljs/src/legacy/testMode.ts","initializeTestMode","{  getGlobalContext().legacyTestMode = true; }"
"../test-repos/Microsoft_satcheljs/src/legacy/testMode.ts","resetTestMode","{  getGlobalContext().legacyTestMode = false; }"
"../test-repos/Microsoft_satcheljs/src/mutator.ts","mutator","{  let actionId = getPrivateActionId(actionCreator);  if (!actionId) {  throw new Error('Mutators can only subscribe to action creators.');  }   // Wrap the callback in a MobX action so it can modify the store  let wrappedTarget = action((actionMessage: T) => {  try {  getGlobalContext().inMutator = true;  if (target(actionMessage)) {  throw new Error('Mutators cannot return a value and cannot be async.');  }  } finally {  getGlobalContext().inMutator = false;  }  });   // Subscribe to the action  subscribe(actionId, wrappedTarget);   return target; }"
"../test-repos/Microsoft_satcheljs/src/simpleSubscribers.ts","createSimpleSubscriber","{  return function simpleSubscriber<T extends SimpleAction>(actionType: string, target: T): T {  // Create the action creator  let simpleActionCreator = action(actionType, function simpleActionCreator() {  return {  args: arguments,  };  });   // Create the subscriber  decorator(simpleActionCreator, function simpleSubscriberCallback(actionMessage: any) {  target.apply(null, actionMessage.args);  });   // Return a function that dispatches that action  return (simpleActionCreator as any) as T;  }; }"
"../test-repos/Microsoft_satcheljs/src/getRootStore.ts","getRootStore","{  return getGlobalContext().rootStore; }"
"../test-repos/Microsoft_satcheljs/src/dispatcher.ts","subscribe","{  let subscriptions = getGlobalContext().subscriptions;  if (!subscriptions[actionId]) {  subscriptions[actionId] = [];  }   subscriptions[actionId].push(callback); }"
"../test-repos/Microsoft_satcheljs/src/dispatcher.ts","dispatch","{  if (getGlobalContext().inMutator) {  throw new Error('Mutators cannot dispatch further actions.');  }   let dispatchWithMiddleware = getGlobalContext().dispatchWithMiddleware || finalDispatch;  dispatchWithMiddleware(actionMessage); }"
"../test-repos/Microsoft_satcheljs/src/dispatcher.ts","finalDispatch","{  let actionId = getPrivateActionId(actionMessage);  let subscribers = getGlobalContext().subscriptions[actionId];   if (subscribers) {  let promises: Promise<any>[] = [];   subscribers.forEach(subscriber => {  let returnValue = subscriber(actionMessage);  if (returnValue) {  promises.push(returnValue);  }  });   if (promises.length) {  return promises.length == 1 ? promises[0] : Promise.all(promises);  }  } }"
"../test-repos/Microsoft_satcheljs/src/globalContext.ts","__resetGlobalContext","{  global.__satchelGlobalContext = {  schemaVersion: schemaVersion,  rootStore: map({}),  nextActionId: 0,  subscriptions: {},  dispatchWithMiddleware: null,  inMutator: false,  legacyInDispatch: 0,  legacyDispatchWithMiddleware: null,  legacyTestMode: false,  }; }"
"../test-repos/Microsoft_satcheljs/src/globalContext.ts","ensureGlobalContextSchemaVersion","{  if (schemaVersion != global.__satchelGlobalContext.schemaVersion) {  throw new Error('Detected incompatible SatchelJS versions loaded.');  } }"
"../test-repos/Microsoft_satcheljs/src/globalContext.ts","getGlobalContext","{  return global.__satchelGlobalContext; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","boolean","{   return value === true || value === false;  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","string","{   return toString.call(value) === '[object String]';  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","is","{   let candidate = item as DirectoryItem;   return candidate && Is.string(candidate.directory) && (Is.boolean(candidate.changeProcessCWD) || candidate.changeProcessCWD === void 0);  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","makeDiagnostic","{  let message = (problem.ruleId != null)   ? `${problem.message} (${problem.ruleId})`   : `${problem.message}`;  let startLine = Math.max(0, problem.line - 1);  let startChar = Math.max(0, problem.column - 1);  let endLine = problem.endLine != null ? Math.max(0, problem.endLine - 1) : startLine;  let endChar = problem.endColumn != null ? Math.max(0, problem.endColumn - 1) : startChar;  return {   message: message,   severity: convertSeverity(problem.severity),   source: 'eslint',   range: {    start: { line: startLine, character: startChar },    end: { line: endLine, character: endChar }   },   code: problem.ruleId  }; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","computeKey","{  let range = diagnostic.range;  return `[${range.start.line},${range.start.character},${range.end.line},${range.end.character}]-${diagnostic.code}`; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","recordCodeAction","{  if (!problem.fix || !problem.ruleId) {   return;  }  let uri = document.uri;  let edits: Map<string, AutoFix> = codeActions.get(uri);  if (!edits) {   edits = new Map<string, AutoFix>();   codeActions.set(uri, edits);  }  edits.set(computeKey(diagnostic), { label: `Fix this ${problem.ruleId} problem`, documentVersion: document.version, ruleId: problem.ruleId, edit: problem.fix }); }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","convertSeverity","{  switch (severity) {   // Eslint 1 is warning   case 1:    return DiagnosticSeverity.Warning;   case 2:    return DiagnosticSeverity.Error;   default:    return DiagnosticSeverity.Error;  } }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","isUNC","{  if (process.platform !== 'win32') {   // UNC is a windows concept   return false;  }   if (!path || path.length < 5) {   // at least \\a\b   return false;  }   let code = path.charCodeAt(0);  if (code !== CharCode.Backslash) {   return false;  }  code = path.charCodeAt(1);  if (code !== CharCode.Backslash) {   return false;  }  let pos = 2;  let start = pos;  for (; pos < path.length; pos++) {   code = path.charCodeAt(pos);   if (code === CharCode.Backslash) {    break;   }  }  if (start === pos) {   return false;  }  code = path.charCodeAt(pos + 1);  if (isNaN(code) || code === CharCode.Backslash) {   return false;  }  return true; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","getFileSystemPath","{  let result = uri.fsPath;  if (process.platform === 'win32' && result.length >= 2 && result[1] === ':') {   // Node by default uses an upper case drive letter and ESLint uses   // === to compare pathes which results in the equal check failing   // if the drive letter is lower case in th URI. Ensure upper case.   return result[0].toUpperCase() + result.substr(1);  } else {   return result;  } }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","getFilePath","{  if (!documentOrUri) {   return undefined;  }  let uri = Is.string(documentOrUri) ? URI.parse(documentOrUri) : URI.parse(documentOrUri.uri);  if (uri.scheme !== 'file') {   return undefined;  }  return getFileSystemPath(uri); }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","globalNpmPath","{  if (_globalNpmPath === void 0) {   _globalNpmPath = Files.resolveGlobalNodePath(trace);   if (_globalNpmPath === void 0) {    _globalNpmPath = null;   }  }  if (_globalNpmPath === null) {   return undefined;  }  return _globalNpmPath; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","globalYarnPath","{  if (_globalYarnPath === void 0) {   _globalYarnPath = Files.resolveGlobalYarnPath(trace);   if (_globalYarnPath === void 0) {    _globalYarnPath = null;   }  }  if (_globalYarnPath === null) {   return undefined;  }  return _globalYarnPath; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","resolveSettings","{  let uri = document.uri;  let resultPromise = document2Settings.get(uri);  if (resultPromise) {   return resultPromise;  }  resultPromise = connection.workspace.getConfiguration({ scopeUri: uri, section: '' }).then((settings: TextDocumentSettings) => {   if (settings.packageManager === 'npm') {    settings.resolvedGlobalPackageManagerPath = globalNpmPath();   } else if (settings.packageManager === 'yarn') {    settings.resolvedGlobalPackageManagerPath = globalYarnPath();   }   let uri = URI.parse(document.uri);   let promise: Thenable<string>   if (uri.scheme === 'file') {    let file = uri.fsPath;    let directory = path.dirname(file);    if (settings.nodePath) {     let nodePath = settings.nodePath;     if (!path.isAbsolute(nodePath) && settings.workspaceFolder !== void 0) {      let uri = URI.parse(settings.workspaceFolder.uri);      if (uri.scheme === 'file') {       nodePath = path.join(uri.fsPath, nodePath);      }     }     promise = Files.resolve('eslint', nodePath, nodePath, trace).then<string, string>(undefined, () => {      return Files.resolve('eslint', settings.resolvedGlobalPackageManagerPath, directory, trace);     });    } else {     promise = Files.resolve('eslint', settings.resolvedGlobalPackageManagerPath, directory, trace);    }   } else {    promise = Files.resolve('eslint', settings.resolvedGlobalPackageManagerPath, settings.workspaceFolder ? settings.workspaceFolder.uri : undefined, trace);   }   return promise.then((path) => {    let library = path2Library.get(path);    if (!library) {     library = require(path);     if (!library.CLIEngine) {      settings.validate = false;      connection.console.error(`The eslint library loaded from ${path} doesn\'t export a CLIEngine. You need at least eslint@1.0.0`);     } else {      connection.console.info(`ESLint library loaded from: ${path}`);      settings.library = library;     }     path2Library.set(path, library);    } else {     settings.library = library;    }    return settings;   }, () => {    settings.validate = false;    connection.sendRequest(NoESLintLibraryRequest.type, { source: { uri: document.uri } });    return settings;   });  });  document2Settings.set(uri, resultPromise);  return resultPromise; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","is","{   let candidate: Request<any, any> = value;   return candidate && !!candidate.token && !!candidate.resolve && !!candidate.reject;  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","is","{   let candidate: Thenable<T> = value;   return candidate && typeof candidate.then === 'function';  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","getFixes","{  let uri = textDocument.uri  let edits = codeActions.get(uri);  function createTextEdit(editInfo: AutoFix): TextEdit {   return TextEdit.replace(Range.create(textDocument.positionAt(editInfo.edit.range[0]), textDocument.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');  }  if (edits) {   let fixes = new Fixes(edits);   if (fixes.isEmpty() || textDocument.version !== fixes.getDocumentVersion()) {    return [];   }   return fixes.getOverlapFree().map(createTextEdit);  }  return []; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","createTextEdit","{   return TextEdit.replace(Range.create(textDocument.positionAt(editInfo.edit.range[0]), textDocument.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","environmentChanged","{  document2Settings.clear();  for (let document of documents.all()) {   messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);  } }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","trace","{  connection.tracer.log(message, verbose); }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","validateSingle","{  // We validate document in a queue but open / close documents directly. So we need to deal with the  // fact that a document might be gone from the server.  if (!documents.get(document.uri)) {   return Promise.resolve(undefined);  }  return resolveSettings(document).then((settings) => {   if (!settings.validate) {    return;   }   try {    validate(document, settings, publishDiagnostics);    connection.sendNotification(StatusNotification.type, { state: Status.ok });   } catch (err) {    let status = undefined;    for (let handler of singleErrorHandlers) {     status = handler(err, document, settings.library);     if (status) {      break;     }    }    status = status || Status.error;    connection.sendNotification(StatusNotification.type, { state: status });   }  }); }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","validateMany","{  documents.forEach(document => {   messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);  }); }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","getMessage","{  let result: string = null;  if (typeof err.message === 'string' || err.message instanceof String) {   result = <string>err.message;   result = result.replace(/\r?\n/g, ' ');   if (/^CLI: /.test(result)) {    result = result.substr(5);   }  } else {   result = `An unknown error occured while validating document: ${document.uri}`;  }  return result; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","validate","{  let newOptions: CLIOptions = Object.assign(Object.create(null), settings.options);  let content = document.getText();  let uri = document.uri;  let file = getFilePath(document);  let cwd = process.cwd();   try {   if (file) {    if (settings.workingDirectory) {     newOptions.cwd = settings.workingDirectory.directory;     if (settings.workingDirectory.changeProcessCWD) {      process.chdir(settings.workingDirectory.directory);     }    } else if (settings.workspaceFolder) {     let workspaceFolderUri = URI.parse(settings.workspaceFolder.uri);     if (workspaceFolderUri.scheme === 'file') {      const fsPath = getFileSystemPath(workspaceFolderUri);      newOptions.cwd = fsPath;      process.chdir(fsPath);     }    } else if (!settings.workspaceFolder && !isUNC(file)) {     let directory = path.dirname(file);     if (directory) {      if (path.isAbsolute(directory)) {       newOptions.cwd = directory;      }     }    }   }    let cli = new settings.library.CLIEngine(newOptions);   // Clean previously computed code actions.   codeActions.delete(uri);   let report: ESLintReport = cli.executeOnText(content, file);   let diagnostics: Diagnostic[] = [];   if (report && report.results && Array.isArray(report.results) && report.results.length > 0) {    let docReport = report.results[0];    if (docReport.messages && Array.isArray(docReport.messages)) {     docReport.messages.forEach((problem) => {      if (problem) {       let diagnostic = makeDiagnostic(problem);       diagnostics.push(diagnostic);       if (settings.autoFix) {        recordCodeAction(document, diagnostic, problem);       }      }     });    }   }   if (publishDiagnostics) {    connection.sendDiagnostics({ uri, diagnostics });   }  } finally {   if (cwd !== process.cwd()) {    process.chdir(cwd);   }  } }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","isNoConfigFoundError","{  let candidate = error as ESLintError;  return candidate.messageTemplate === 'no-config-found' || candidate.message === 'No ESLint configuration found.'; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","tryHandleNoConfig","{  if (!isNoConfigFoundError(error)) {   return undefined;  }  if (!noConfigReported.has(document.uri)) {   connection.sendRequest(    NoConfigRequest.type,    {     message: getMessage(error, document),     document: {      uri: document.uri     }    })   .then(undefined, () => { });   noConfigReported.set(document.uri, library);  }  return Status.warn; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","tryHandleConfigError","{  if (!error.message) {   return undefined;  }   function handleFileName(filename: string): Status {   if (!configErrorReported.has(filename)) {    connection.console.error(getMessage(error, document));    if (!documents.get(URI.file(filename).toString())) {     connection.window.showInformationMessage(getMessage(error, document));    }    configErrorReported.set(filename, library);   }   return Status.warn;  }   let matches = /Cannot read config file:\s+(.*)\nError:\s+(.*)/.exec(error.message);  if (matches && matches.length === 3) {   return handleFileName(matches[1]);  }   matches = /(.*):\n\s*Configuration for rule \'(.*)\' is /.exec(error.message);  if (matches && matches.length === 3) {   return handleFileName(matches[1]);  }   matches = /Cannot find module '([^']*)'\nReferenced from:\s+(.*)/.exec(error.message);  if (matches && matches.length === 3) {   return handleFileName(matches[2]);  }   return undefined; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","handleFileName","{   if (!configErrorReported.has(filename)) {    connection.console.error(getMessage(error, document));    if (!documents.get(URI.file(filename).toString())) {     connection.window.showInformationMessage(getMessage(error, document));    }    configErrorReported.set(filename, library);   }   return Status.warn;  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","tryHandleMissingModule","{  if (!error.message) {   return undefined;  }   function handleMissingModule(plugin: string, module: string, error: ESLintError): Status {   if (!missingModuleReported.has(plugin)) {    let fsPath = getFilePath(document);    missingModuleReported.set(plugin, library);    if (error.messageTemplate === 'plugin-missing') {     connection.console.error([      '',      `${error.message.toString()}`,      `Happened while validating ${fsPath ? fsPath : document.uri}`,      `This can happen for a couple of reasons:`,      `1. The plugin name is spelled incorrectly in an ESLint configuration file (e.g. .eslintrc).`,      `2. If ESLint is installed globally, then make sure ${module} is installed globally as well.`,      `3. If ESLint is installed locally, then ${module} isn't installed correctly.`,      '',      `Consider running eslint --debug ${fsPath ? fsPath : document.uri} from a terminal to obtain a trace about the configuration files used.`     ].join('\n'));    } else {     connection.console.error([      `${error.message.toString()}`,      `Happend while validating ${fsPath ? fsPath : document.uri}`     ].join('\n'));    }   }   return Status.warn;  }   let matches = /Failed to load plugin (.*): Cannot find module (.*)/.exec(error.message);  if (matches && matches.length === 3) {   return handleMissingModule(matches[1], matches[2], error);  }   return undefined; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","handleMissingModule","{   if (!missingModuleReported.has(plugin)) {    let fsPath = getFilePath(document);    missingModuleReported.set(plugin, library);    if (error.messageTemplate === 'plugin-missing') {     connection.console.error([      '',      `${error.message.toString()}`,      `Happened while validating ${fsPath ? fsPath : document.uri}`,      `This can happen for a couple of reasons:`,      `1. The plugin name is spelled incorrectly in an ESLint configuration file (e.g. .eslintrc).`,      `2. If ESLint is installed globally, then make sure ${module} is installed globally as well.`,      `3. If ESLint is installed locally, then ${module} isn't installed correctly.`,      '',      `Consider running eslint --debug ${fsPath ? fsPath : document.uri} from a terminal to obtain a trace about the configuration files used.`     ].join('\n'));    } else {     connection.console.error([      `${error.message.toString()}`,      `Happend while validating ${fsPath ? fsPath : document.uri}`     ].join('\n'));    }   }   return Status.warn;  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","showErrorMessage","{  connection.window.showErrorMessage(`ESLint: ${getMessage(error, document)}. Please see the 'ESLint' output channel for details.`);  if (Is.string(error.stack)) {   connection.console.error('ESLint stack trace:');   connection.console.error(error.stack);  }  return Status.error; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","createTextEdit","{   return TextEdit.replace(Range.create(textDocument.positionAt(editInfo.edit.range[0]), textDocument.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","getLastEdit","{   let length = array.length;   if (length === 0) {    return undefined;   }   return array[length - 1];  }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","computeAllFixes","{  let uri = identifier.uri;  let textDocument = documents.get(uri);  if (!textDocument || identifier.version !== textDocument.version) {   return undefined;  }  let edits = codeActions.get(uri);  function createTextEdit(editInfo: AutoFix): TextEdit {   return TextEdit.replace(Range.create(textDocument.positionAt(editInfo.edit.range[0]), textDocument.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');  }   if (edits) {   let fixes = new Fixes(edits);   if (!fixes.isEmpty()) {    return fixes.getOverlapFree().map(createTextEdit);   }  }  return undefined; }"
"../test-repos/Microsoft_vscode-eslint/server/src/eslintServer.ts","createTextEdit","{   return TextEdit.replace(Range.create(textDocument.positionAt(editInfo.edit.range[0]), textDocument.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","boolean","{   return value === true || value === false;  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","string","{   return toString.call(value) === '[object String]';  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","is","{   let candidate = item as ValidateItem;   return candidate && Is.string(candidate.language) && (Is.boolean(candidate.autoFix) || candidate.autoFix === void 0);  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","is","{   let candidate = item as DirectoryItem;   return candidate && Is.string(candidate.directory) && (Is.boolean(candidate.changeProcessCWD) || candidate.changeProcessCWD === void 0);  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","pickFolder","{  if (folders.length === 1) {   return Promise.resolve(folders[0]);  }  return Window.showQuickPick(   folders.map<WorkspaceFolderItem>((folder) => { return { label: folder.name, description: folder.uri.fsPath, folder: folder }; }),   { placeHolder: placeHolder }  ).then((selected) => {   if (!selected) {    return undefined;   }   return selected.folder;  }); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","enable","{  let folders = Workspace.workspaceFolders;  if (!folders) {   Window.showWarningMessage('ESLint can only be enabled if VS Code is opened on a workspace folder.');   return;  }  let disabledFolders = folders.filter(folder => !Workspace.getConfiguration('eslint',folder.uri).get('enable', true));  if (disabledFolders.length === 0) {   if (folders.length === 1) {    Window.showInformationMessage('ESLint is already enabled in the workspace.');   } else {    Window.showInformationMessage('ESLint is already enabled on all workspace folders.');   }   return;  }  pickFolder(disabledFolders, 'Select a workspace folder to enable ESLint for').then(folder => {   if (!folder) {    return;   }   Workspace.getConfiguration('eslint', folder.uri).update('enable', true);  }); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","disable","{  let folders = Workspace.workspaceFolders;  if (!folders) {   Window.showErrorMessage('ESLint can only be disabled if VS Code is opened on a workspace folder.');   return;  }  let enabledFolders = folders.filter(folder => Workspace.getConfiguration('eslint',folder.uri).get('enable', true));  if (enabledFolders.length === 0) {   if (folders.length === 1) {    Window.showInformationMessage('ESLint is already disabled in the workspace.');   } else {    Window.showInformationMessage('ESLint is already disabled on all workspace folders.');   }   return;  }  pickFolder(enabledFolders, 'Select a workspace folder to disable ESLint for').then(folder => {   if (!folder) {    return;   }   Workspace.getConfiguration('eslint', folder.uri).update('enable', false);  }); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","createDefaultConfiguration","{  let folders = Workspace.workspaceFolders;  if (!folders) {   Window.showErrorMessage('An ESLint configuration can only be generated if VS Code is opened on a workspace folder.');   return;  }  let noConfigFolders = folders.filter(folder => {   let configFiles = ['.eslintrc.js', '.eslintrc.yaml', '.eslintrc.yml', '.eslintrc', '.eslintrc.json'];   for (let configFile of configFiles) {    if (fs.existsSync(path.join(folder.uri.fsPath, configFile))) {     return false;    }   }   return true;  });  if (noConfigFolders.length === 0) {   if (folders.length === 1) {    Window.showInformationMessage('The workspace already contains an ESLint configuration file.');   } else {    Window.showInformationMessage('All workspace folders already contain an ESLint configuration file.');   }   return;  }  pickFolder(noConfigFolders, 'Select a workspace folder to generate a ESLint configuration for').then(folder => {   if (!folder) {    return;   }   let eslintConfigFile = path.join(folder.uri.fsPath, '.eslintrc.json');   if (!fs.existsSync(eslintConfigFile)) {    fs.writeFileSync(eslintConfigFile, eslintrc, { encoding: 'utf8' });   }  }); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","shouldBeValidated","{  let config = Workspace.getConfiguration('eslint', textDocument.uri);  if (!config.get('enable', true)) {   return false;  }  let validate = config.get<(ValidateItem | string)[]>('validate', defaultLanguages);  for (let item of validate) {   if (Is.string(item) && item === textDocument.languageId) {    return true;   } else if (ValidateItem.is(item) && item.language === textDocument.languageId) {    return true;   }  }  return false; }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","activate","{  let activated: boolean;  let openListener: Disposable;  let configurationListener: Disposable;  function didOpenTextDocument(textDocument: TextDocument) {   if (activated) {    return;   }   if (shouldBeValidated(textDocument)) {    openListener.dispose();    configurationListener.dispose();    activated = true;    realActivate(context);   }  }  function configurationChanged() {   if (activated) {    return;   }   for (let textDocument of Workspace.textDocuments) {    if (shouldBeValidated(textDocument)) {     openListener.dispose();     configurationListener.dispose();     activated = true;     realActivate(context);     return;    }   }  }  openListener = Workspace.onDidOpenTextDocument(didOpenTextDocument);  configurationListener = Workspace.onDidChangeConfiguration(configurationChanged);   let notValidating = () => Window.showInformationMessage('ESLint is not validating any files yet.');  dummyCommands = [   Commands.registerCommand('eslint.executeAutofix', notValidating),   Commands.registerCommand('eslint.showOutputChannel', notValidating)  ];   context.subscriptions.push(   Commands.registerCommand('eslint.createConfig', createDefaultConfiguration),   Commands.registerCommand('eslint.enable', enable),   Commands.registerCommand('eslint.disable', disable)  );  taskProvider = new TaskProvider();  taskProvider.start();  configurationChanged(); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","didOpenTextDocument","{   if (activated) {    return;   }   if (shouldBeValidated(textDocument)) {    openListener.dispose();    configurationListener.dispose();    activated = true;    realActivate(context);   }  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","configurationChanged","{   if (activated) {    return;   }   for (let textDocument of Workspace.textDocuments) {    if (shouldBeValidated(textDocument)) {     openListener.dispose();     configurationListener.dispose();     activated = true;     realActivate(context);     return;    }   }  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","realActivate","{   let statusBarItem = Window.createStatusBarItem(StatusBarAlignment.Right, 0);  let eslintStatus: Status = Status.ok;  let serverRunning: boolean = false;   statusBarItem.text = 'ESLint';  statusBarItem.command = 'eslint.showOutputChannel';   function showStatusBarItem(show: boolean): void {   if (show) {    statusBarItem.show();   } else {    statusBarItem.hide();   }  }   function updateStatus(status: Status) {   eslintStatus = status;   switch (status) {    case Status.ok:     statusBarItem.text = 'ESLint';     break;    case Status.warn:     statusBarItem.text = '$(alert) ESLint';     break;    case Status.error:     statusBarItem.text = '$(issue-opened) ESLint';     break;    default:     statusBarItem.text = 'ESLint';   }   updateStatusBarVisibility();  }   function updateStatusBarVisibility(): void {   showStatusBarItem(    (serverRunning && eslintStatus !== Status.ok) || Workspace.getConfiguration('eslint').get('alwaysShowStatus', false)   );  }   // We need to go one level up since an extension compile the js code into  // the output folder.  // serverModule  let serverModule = context.asAbsolutePath(path.join('server', 'out', 'eslintServer.js'));  let serverOptions: ServerOptions = {   run: { module: serverModule, transport: TransportKind.ipc, options: { cwd: process.cwd() } },   debug: { module: serverModule, transport: TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6010'], cwd: process.cwd() } }  };   let defaultErrorHandler: ErrorHandler;  let serverCalledProcessExit: boolean = false;   let packageJsonFilter: DocumentFilter = { scheme: 'file', pattern: '**/package.json'};  let configFileFilter: DocumentFilter = { scheme: 'file', pattern: '**/.eslintr{c.js,c.yaml,c.yml,c,c.json}'};  let syncedDocuments: Map<string, TextDocument> = new Map<string, TextDocument>();   Workspace.onDidChangeConfiguration(() => {   for (let textDocument of syncedDocuments.values()) {    if (!shouldBeValidated(textDocument)) {     syncedDocuments.delete(textDocument.uri.toString());     client.sendNotification(DidCloseTextDocumentNotification.type, client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument));    }   }   for (let textDocument of Workspace.textDocuments) {    if (!syncedDocuments.has(textDocument.uri.toString()) && shouldBeValidated(textDocument)) {     client.sendNotification(DidOpenTextDocumentNotification.type, client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument));     syncedDocuments.set(textDocument.uri.toString(), textDocument);    }   }  });  let clientOptions: LanguageClientOptions = {   documentSelector: [{ scheme: 'file' }, { scheme: 'untitled'}],   diagnosticCollectionName: 'eslint',   revealOutputChannelOn: RevealOutputChannelOn.Never,   synchronize: {    // configurationSection: 'eslint',    fileEvents: [     Workspace.createFileSystemWatcher('**/.eslintr{c.js,c.yaml,c.yml,c,c.json}'),     Workspace.createFileSystemWatcher('**/.eslintignore'),     Workspace.createFileSystemWatcher('**/package.json')    ]   },   initializationOptions: () => {    let configuration = Workspace.getConfiguration('eslint');    let folders = Workspace.workspaceFolders;    return {     legacyModuleResolve: configuration ? configuration.get('_legacyModuleResolve', false) : false,     nodePath: configuration ? configuration.get('nodePath', undefined) : undefined,     languageIds: configuration ? configuration.get('valiadate', defaultLanguages) : defaultLanguages,     workspaceFolders: folders ? folders.map(folder => folder.toString()) : []    };   },   initializationFailedHandler: (error) => {    client.error('Server initialization failed.', error);    client.outputChannel.show(true);    return false;   },   errorHandler: {    error: (error, message, count): ErrorAction => {     return defaultErrorHandler.error(error, message, count);    },    closed: (): CloseAction => {     if (serverCalledProcessExit) {      return CloseAction.DoNotRestart;     }     return defaultErrorHandler.closed();    }   },   middleware: {    didOpen: (document, next) => {     if (Languages.match(packageJsonFilter, document) || Languages.match(configFileFilter, document) || shouldBeValidated(document)) {      next(document);      syncedDocuments.set(document.uri.toString(), document);      return;     }    },    didChange: (event, next) => {     if (syncedDocuments.has(event.document.uri.toString())) {      next(event);     }    },    willSave: (event, next) => {     if (syncedDocuments.has(event.document.uri.toString())) {      next(event);     }    },    willSaveWaitUntil: (event, next) => {     if (syncedDocuments.has(event.document.uri.toString())) {      return next(event);     } else {      return Promise.resolve([]);     }    },    didSave: (document, next) => {     if (syncedDocuments.has(document.uri.toString())) {      next(document);     }    },    didClose: (document, next) => {     let uri = document.uri.toString();     if (syncedDocuments.has(uri)) {      syncedDocuments.delete(uri);      next(document);     }    },    provideCodeActions: (document, range, context, token, next): ProviderResult<Command[]> => {     if (!syncedDocuments.has(document.uri.toString()) || !context.diagnostics || context.diagnostics.length === 0) {      return [];     }     let eslintDiagnostics: Diagnostic[] = [];     for (let diagnostic of context.diagnostics) {      if (diagnostic.source === 'eslint') {       eslintDiagnostics.push(diagnostic);      }     }     if (eslintDiagnostics.length === 0) {      return [];     }     let newContext: CodeActionContext = Object.assign({}, context, { diagnostics: eslintDiagnostics } as CodeActionContext);     return next(document, range, newContext, token);    },    workspace: {     configuration: (params, _token, _next): any[] => {      if (!params.items) {       return null;      }      let result: (TextDocumentSettings | null)[] = [];      for (let item of params.items) {       if (item.section || !item.scopeUri) {        result.push(null);        continue;       }       let resource = client.protocol2CodeConverter.asUri(item.scopeUri);       let config = Workspace.getConfiguration('eslint', resource);       let pm = config.get('packageManager', 'npm');       let settings: TextDocumentSettings = {        validate: false,        packageManager: pm === 'yarn' ? 'yarn' : 'npm',        autoFix: false,        autoFixOnSave: false,        options: config.get('options', {}),        run: config.get('run', 'onType'),        nodePath: config.get('nodePath', undefined),        workingDirectory: undefined,        workspaceFolder: undefined,        library: undefined       }       let document: TextDocument = syncedDocuments.get(item.scopeUri);       if (!document) {        result.push(settings);        continue;       }       if (config.get('enabled', true)) {        let validateItems = config.get<(ValidateItem | string)[]>('validate', ['javascript', 'javascriptreact']);        for (let item of validateItems) {         if (Is.string(item) && item === document.languageId) {          settings.validate = true;          if (item === 'javascript' || item === 'javascriptreact') {           settings.autoFix = true;          }          break;         }         else if (ValidateItem.is(item) && item.language === document.languageId) {          settings.validate = true;          settings.autoFix = item.autoFix;          break;         }        }       }       if (settings.validate) {        settings.autoFixOnSave = settings.autoFix && config.get('autoFixOnSave', false);       }       let workspaceFolder = Workspace.getWorkspaceFolder(resource);       if (workspaceFolder) {        settings.workspaceFolder = {         name: workspaceFolder.name,         uri: client.code2ProtocolConverter.asUri(workspaceFolder.uri)        };       }       let workingDirectories = config.get<(string | DirectoryItem)[]>('workingDirectories', undefined);       if (Array.isArray(workingDirectories)) {        let workingDirectory = undefined;        let workspaceFolderPath = workspaceFolder && workspaceFolder.uri.scheme === 'file' ? workspaceFolder.uri.fsPath : undefined;        for (let entry of workingDirectories) {         let directory;         let changeProcessCWD = false;         if (Is.string(entry)) {          directory = entry;         }         else if (DirectoryItem.is(entry)) {          directory = entry.directory;          changeProcessCWD = !!entry.changeProcessCWD;         }         if (directory) {          if (path.isAbsolute(directory)) {           directory = directory;          }          else if (workspaceFolderPath && directory) {           directory = path.join(workspaceFolderPath, directory);          }          else {           directory = undefined;          }          let filePath = document.uri.scheme === 'file' ? document.uri.fsPath : undefined;          if (filePath && directory && filePath.startsWith(directory)) {           if (workingDirectory) {            if (workingDirectory.directory.length < directory.length) {             workingDirectory.directory = directory;             workingDirectory.changeProcessCWD = changeProcessCWD;            }           }           else {            workingDirectory = { directory, changeProcessCWD };           }          }         }        }        settings.workingDirectory = workingDirectory;       }       result.push(settings);      }      return result;     }    }   }  };   let client = new LanguageClient('ESLint', serverOptions, clientOptions);  client.registerProposedFeatures();  defaultErrorHandler = client.createDefaultErrorHandler();  const running = 'ESLint server is running.';  const stopped = 'ESLint server stopped.'  client.onDidChangeState((event) => {   if (event.newState === ClientState.Running) {    client.info(running);    statusBarItem.tooltip = running;    serverRunning = true;   } else {    client.info(stopped);    statusBarItem.tooltip = stopped;    serverRunning = false;   }   updateStatusBarVisibility();  });  client.onReady().then(() => {   client.onNotification(StatusNotification.type, (params) => {    updateStatus(params.state);   });    client.onNotification(exitCalled, (params) => {    serverCalledProcessExit = true;    client.error(`Server process exited with code ${params[0]}. This usually indicates a misconfigured ESLint setup.`, params[1]);    Window.showErrorMessage(`ESLint server shut down itself. See 'ESLint' output channel for details.`);   });    client.onRequest(NoConfigRequest.type, (params) => {    let document = Uri.parse(params.document.uri);    let workspaceFolder = Workspace.getWorkspaceFolder(document);    let fileLocation = document.fsPath;    if (workspaceFolder) {     client.warn([      '',      `No ESLint configuration (e.g .eslintrc) found for file: ${fileLocation}`,      `File will not be validated. Consider running 'eslint --init' in the workspace folder ${workspaceFolder.name}`,      `Alternatively you can disable ESLint by executing the 'Disable ESLint' command.`     ].join('\n'));    } else {     client.warn([      '',      `No ESLint configuration (e.g .eslintrc) found for file: ${fileLocation}`,      `File will not be validated. Alternatively you can disable ESLint by executing the 'Disable ESLint' command.`     ].join('\n'));    }    eslintStatus = Status.warn;    updateStatusBarVisibility();    return {};   });    client.onRequest(NoESLintLibraryRequest.type, (params) => {    const key = 'noESLintMessageShown';    let state = context.globalState.get<NoESLintState>(key, {});    let uri: Uri = Uri.parse(params.source.uri);    let workspaceFolder = Workspace.getWorkspaceFolder(uri);    let packageManager = Workspace.getConfiguration('eslint', uri).get('packageManager', 'npm');    if (workspaceFolder) {     if (packageManager === 'yarn') {      client.info([       '',       `Failed to load the ESLint library for the document ${uri.fsPath}`,       '',       `To use ESLint please install eslint by running \'yarn add eslint\' in the workspace folder ${workspaceFolder.name}`,       'or globally using \'yarn global add eslint\'. You need to reopen the workspace after installing eslint.',       '',       `Alternatively you can disable ESLint for the workspace folder ${workspaceFolder.name} by executing the 'Disable ESLint' command.`      ].join('\n'));     } else {      client.info([       '',       `Failed to load the ESLint library for the document ${uri.fsPath}`,       '',       `To use ESLint please install eslint by running \'npm install eslint\' in the workspace folder ${workspaceFolder.name}`,       'or globally using \'npm install -g eslint\'. You need to reopen the workspace after installing eslint.',       '',       'If you are using yarn instead of npm set the setting `'eslint.packageManager': 'yarn'`',       '',       `Alternatively you can disable ESLint for the workspace folder ${workspaceFolder.name} by executing the 'Disable ESLint' command.`      ].join('\n'));     }     if (!state.workspaces) {      state.workspaces = Object.create(null);     }     if (!state.workspaces[workspaceFolder.uri.toString()]) {      state.workspaces[workspaceFolder.uri.toString()] = true;      client.outputChannel.show(true);      context.globalState.update(key, state);     }    } else {     if (packageManager === 'yarn') {      client.info([       `Failed to load the ESLint library for the document ${uri.fsPath}`,       'To use ESLint for single JavaScript file install eslint globally using \'yarn global add eslint\'.',       'You need to reopen VS Code after installing eslint.',      ].join('\n'));     } else {      client.info([       `Failed to load the ESLint library for the document ${uri.fsPath}`,       'To use ESLint for single JavaScript file install eslint globally using \'npm install -g eslint\'.',       'If you are using yarn instead of npm set the setting `'eslint.packageManager': 'yarn'`',  'You need to reopen VS Code after installing eslint.',      ].join('\n'));     }     if (!state.global) {      state.global = true;      client.outputChannel.show(true);      context.globalState.update(key, state);     }    }    return {};   });  });   if (dummyCommands) {   dummyCommands.forEach(command => command.dispose());   dummyCommands = undefined;  }   updateStatusBarVisibility();   context.subscriptions.push(   client.start(),   Commands.registerCommand('eslint.executeAutofix', () => {    let textEditor = Window.activeTextEditor;    if (!textEditor) {     return;    }    let textDocument: VersionedTextDocumentIdentifier = {     uri: textEditor.document.uri.toString(),     version: textEditor.document.version    };    let params: ExecuteCommandParams = {     command: 'eslint.applyAutoFix',     arguments: [textDocument]    }    client.sendRequest(ExecuteCommandRequest.type, params).then(undefined, () => {     Window.showErrorMessage('Failed to apply ESLint fixes to the document. Please consider opening an issue with steps to reproduce.');    });   }),   Commands.registerCommand('eslint.showOutputChannel', () => { client.outputChannel.show(); }),   statusBarItem  ); }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","showStatusBarItem","{   if (show) {    statusBarItem.show();   } else {    statusBarItem.hide();   }  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","updateStatus","{   eslintStatus = status;   switch (status) {    case Status.ok:     statusBarItem.text = 'ESLint';     break;    case Status.warn:     statusBarItem.text = '$(alert) ESLint';     break;    case Status.error:     statusBarItem.text = '$(issue-opened) ESLint';     break;    default:     statusBarItem.text = 'ESLint';   }   updateStatusBarVisibility();  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","updateStatusBarVisibility","{   showStatusBarItem(    (serverRunning && eslintStatus !== Status.ok) || Workspace.getConfiguration('eslint').get('alwaysShowStatus', false)   );  }"
"../test-repos/Microsoft_vscode-eslint/client/src/extension.ts","deactivate","{  if (dummyCommands) {   dummyCommands.forEach(command => command.dispose());  }   if (taskProvider) {   taskProvider.dispose();  } }"
"../test-repos/Microsoft_vscode-eslint/client/src/tasks.ts","exists","{  return new Promise<boolean>((resolve, _reject) => {   fs.exists(file, (value) => {    resolve(value);   });  }); }"
"../test-repos/Microsoft_vsts-extension-samples/data-storage/src/dataStorage/settings.ts","saveSettings","{  const boolValue = $(selector + ' .booleanValue').prop('checked');  const numValue = parseInt($(selector + ' .numberValue').val());  const objValue = {  val1: $(selector + ' .objectValue1').val(),  val2: $(selector + ' .objectValue2').val()  };  VSS.getService(VSS.ServiceIds.ExtensionData).then((dataService: Extension_Data.ExtensionDataService) => { dataService.setValue('booleanValue', boolValue, {scopeType: scope}).then((value: boolean) => {  });  dataService.setValue('numberValue', numValue, {scopeType: scope}).then((value: number) => {  });  dataService.setValue('objectValue', objValue, {scopeType: scope}).then((value: any) => {  });  }); }"
"../test-repos/Microsoft_vsts-extension-samples/data-storage/src/dataStorage/settings.ts","getSettings","{  VSS.getService(VSS.ServiceIds.ExtensionData).then((dataService: Extension_Data.ExtensionDataService) => { const boolPromise = dataService.getValue('booleanValue', {scopeType: scope});  const numPromise = dataService.getValue('numberValue', {scopeType: scope});  const objPromise = dataService.getValue('objectValue', {scopeType: scope});  Q.all([boolPromise, numPromise, objPromise]).spread((boolValue: boolean, numValue: number, objValue: any) => {  $(selector + ' .booleanValue').prop('checked', boolValue);  $(selector + ' .numberValue').val(numValue ? numValue.toString() : '');  $(selector + ' .objectValue1').val(objValue ? objValue.val1 : '');  $(selector + ' .objectValue2').val(objValue ? objValue.val2 : '');  });  }); }"
"../test-repos/Microsoft_vsts-extension-samples/data-storage/src/dataStorage/notesGrids.ts","getActionArgs","{  return {  selectedNote: that.getSelectedNotes(),  selectedNotes: that.getSelectedNote()  };  }"
"../test-repos/Microsoft_vsts-extension-samples/analytics-example-widget/scripts/common/WidgetSettings.ts","areSettingsValid","{  return (widgetSettings.projectId != null &&  widgetSettings.teamId != null &&  widgetSettings.workItemType != null &&  widgetSettings.fields != null &&  widgetSettings.fields.every(o =>  o.fieldQueryName != null &&  o.fieldReferenceName != null &&  o.fieldType != null &&  o.operator != null &&  o.value != null &&  (o.value != '' || o.fieldType == 'String')) &&//Do not allow empty string when dealing with value types.  (widgetSettings.aggregation.aggregationMode != null &&  (widgetSettings.aggregation.aggregationMode == AggregationMode.count ||  (widgetSettings.aggregation.displayName != null &&  widgetSettings.aggregation.queryableName != null &&  widgetSettings.aggregation.fieldReferenceName != null)  )  )  ); }"
"../test-repos/Microsoft_vsts-extension-samples/analytics-example-widget/scripts/data/MetadataQuery.ts","mapReferenceNameForQuery","{  let match = mapping.fieldMappings.find(o => o.referenceName === referenceName);  return match != null ? match.queryableName : referenceName; }"
"../test-repos/Microsoft_vsts-extension-samples/analytics-example-widget/scripts/data/MetadataQuery.ts","hasMetadataMapping","{  return mapping.fieldMappings.find(o => o.referenceName === referenceName)!=null; }"
"../test-repos/NativeScript_sample-Groceries/app/shared/dialog-util.ts","alert","{  return dialogsModule.alert({  title: 'Groceries',  okButtonText: 'OK',  message: message  }); }"
"../test-repos/NativeScript_sample-Groceries/app/shared/status-bar-util.ts","setStatusBarColors","{  // Make the iOS status bar transparent with white text.  if (application.ios) {  application.on('launch', () => {  utils.ios.getter(UIApplication, UIApplication.sharedApplication).statusBarStyle = UIStatusBarStyle.LightContent;  });  }   // Make the Android status bar transparent.  // See http://bradmartin.net/2016/03/10/fullscreen-and-navigation-bar-color-in-a-nativescript-android-app/  // for details on the technique used.  if (application.android && platform.device.sdkVersion >= '21') {  application.android.on('activityStarted', () => {  const View = android.view.View;  const window = application.android.startActivity.getWindow();  window.setStatusBarColor(0x000000);   const decorView = window.getDecorView();  decorView.setSystemUiVisibility(  View.SYSTEM_UI_FLAG_LAYOUT_STABLE  | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION  | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN  | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);  });  } }"
"../test-repos/Neufund_TypeChain/test/integration/utils/web3Contracts.ts","deployContract","{  return new Promise<ContractInstance>((resolve, reject) => {  const dirPath = join(__dirname, '../abis');  const fileName = `__${contractName}_sol_${contractName}`;   const abi = JSON.parse(readFileSync(join(dirPath, fileName + '.abi'), 'utf-8'));  const bin = readFileSync(join(dirPath, fileName + '.bin'), 'utf-8');  const code = '0x' + bin;   const contract = web3.eth.contract(abi);   (contract as any).new({ from: accounts[0], data: code, gas: GAS_LIMIT_STANDARD }, (err: Error, contract: any) => {  // this callback gets called multiple times  // on a final call contract.address will be defined  if (err) {  reject(err);  } else if (contract.address) {  resolve(contract);  }  });  }); }"
"../test-repos/Neufund_TypeChain/test/integration/web3.ts","createNewBlockchain","{  const web3 = new Web3(ganache.provider());  const accounts = await promisify(web3.eth.getAccounts, { context: web3.eth })();  return { web3, accounts }; }"
"../test-repos/Neufund_TypeChain/runtime/typechain-runtime.ts","promisify","{  return new Promise((res, rej) => {  func(...args, (err: any, data: any) => {  if (err) return rej(err);  return res(data);  });  }); }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parse","{  const constants: Array<ConstantDeclaration> = [];  const constantFunctions: Array<ConstantFunctionDeclaration> = [];  const functions: Array<FunctionDeclaration> = [];   abi.forEach(abiPiece => {  // @todo implement missing abi pieces  // skip constructors for now  if (abiPiece.type === 'constructor') {  return;  }  // skip events  if (abiPiece.type === 'event') {  return;  }  // skip fallback functions  if (abiPiece.type === 'fallback') {  return;  }   if (abiPiece.type === 'function') {  if (checkForOverloads(constants, constantFunctions, functions, abiPiece.name)) {  // tslint:disable-next-line  console.log(yellow(`Detected overloaded constant function ${abiPiece.name} skipping...`));  return;  }   if (abiPiece.constant && abiPiece.inputs.length === 0 && abiPiece.outputs.length === 1) {  constants.push(parseConstant(abiPiece));  } else if (abiPiece.constant) {  constantFunctions.push(parseConstantFunction(abiPiece));  } else {  functions.push(parseFunctionDeclaration(abiPiece));  }  return;  }   throw new Error(`Unrecognized abi element: ${abiPiece.type}`);  });   return {  constants,  constantFunctions,  functions,  }; }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","checkForOverloads","{  return (  constantFunctions.find(f => f.name === name) ||  constants.find(f => f.name === name) ||  functions.find(f => f.name === name)  ); }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parseOutputs","{  if (outputs.length === 0) {  return [new VoidType()];  } else {  return outputs.map(param => parseEvmType(param.type));  } }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parseConstant","{  debug(`Parsing constant '${abiPiece.name}'`);  return {  name: abiPiece.name,  output: parseEvmType(abiPiece.outputs[0].type),  }; }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parseConstantFunction","{  debug(`Parsing constant function '${abiPiece.name}'`);  return {  name: abiPiece.name,  inputs: abiPiece.inputs.map(parseRawAbiParameter),  outputs: parseOutputs(abiPiece.outputs),  }; }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parseFunctionDeclaration","{  debug(`Parsing function declaration '${abiPiece.name}'`);  return {  name: abiPiece.name,  inputs: abiPiece.inputs.map(parseRawAbiParameter),  outputs: parseOutputs(abiPiece.outputs),  payable: abiPiece.payable,  }; }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","parseRawAbiParameter","{  return {  name: rawAbiParameter.name,  type: parseEvmType(rawAbiParameter.type),  }; }"
"../test-repos/Neufund_TypeChain/lib/abiParser.ts","extractAbi","{  let json;  try {  json = JSON.parse(rawJson);  } catch {  throw new MalformedAbiError('Not a json');  }   if (!json) {  throw new MalformedAbiError('Not a json');  }   if (Array.isArray(json)) {  return json;  }   if (Array.isArray(json.abi)) {  return json.abi;  }   throw new MalformedAbiError('Not a valid ABI'); }"
"../test-repos/Neufund_TypeChain/lib/generateSource.ts","generateSource","{  const parsedContractAbi = parse(abi);   return codeGenForContract(abi, parsedContractAbi, context); }"
"../test-repos/Neufund_TypeChain/lib/generateSource.ts","codeGenForContract","{  const typeName = `${context.fileName}`;  return `/* GENERATED BY TYPECHAIN VER. ${getVersion()} */ /* tslint:disable */  import { BigNumber } from 'bignumber.js'; import { TypeChainContract, promisify, ITxParams, IPayableTxParams, DeferredTransactionWrapper } from '${  context.relativeRuntimePath  }'  export class ${typeName} extends TypeChainContract {  public readonly rawWeb3Contract: any;  public constructor(web3: any, address: string | BigNumber) {  const abi = ${JSON.stringify(abi)};  super(web3, address, abi);  }   static async createAndValidate(web3: any, address: string | BigNumber): Promise<${typeName}> {  const contract = new ${typeName}(web3, address);  const code = await promisify(web3.eth.getCode, [address]);  if (code === '0x0') {  throw new Error(\`Contract at \${address} doesn't exist!\`);  }  return contract; }  ${input.constants  .map(  constant =>  `public get ${  constant.name  }(): Promise<${constant.output.generateCodeForOutput()}> { return promisify(this.rawWeb3Contract.${  constant.name  }, []); }`,  )  .join('\n')} ${input.constantFunctions  .map(  constantFunction =>  `public ${constantFunction.name}(${constantFunction.inputs  .map(codeGenForParams)  .join(', ')}): Promise<${codeGenForOutputTypeList(  constantFunction.outputs,  )}> { return promisify(this.rawWeb3Contract.${  constantFunction.name  }, [${constantFunction.inputs.map(codeGenForArgs).join(', ')}]); }`,  )  .join(';\n')} ${input.functions  .map(func => {  const txParamsType = func.payable ? 'IPayableTxParams' : 'ITxParams';  return `public ${func.name}Tx(${func.inputs  .map(codeGenForParams)  .join(  ', ',  )}): DeferredTransactionWrapper<${txParamsType}> { return new DeferredTransactionWrapper<${txParamsType}>(this, '${  func.name  }', [${func.inputs.map(codeGenForArgs).join(', ')}]);  }`;  })  .join(';\n')} }`; }"
"../test-repos/Neufund_TypeChain/lib/generateSource.ts","codeGenForParams","{  return `${param.name || 'index'}: ${param.type.generateCodeForInput()}`; }"
"../test-repos/Neufund_TypeChain/lib/generateSource.ts","codeGenForArgs","{  return `(${param.name || 'index'}).toString()`; }"
"../test-repos/Neufund_TypeChain/lib/generateSource.ts","codeGenForOutputTypeList","{  if (output.length === 1) {  return output[0].generateCodeForOutput();  } else {  return `[${output.map(x => x.generateCodeForOutput()).join(', ')}]`;  } }"
"../test-repos/Neufund_TypeChain/lib/cli.ts","main","{  const options = parseArgs();   const matches = glob.sync(options.glob, { ignore: 'node_modules/**', absolute: true });   if (matches.length === 0) {  // tslint:disable-next-line  console.log(red(`Found ${matches.length} ABIs.`));  process.exit(0);  }   // tslint:disable-next-line  console.log(green(`Found ${matches.length} ABIs.`));   const prettierConfig = await prettier.resolveConfig(dirname(matches[0]));  if (prettierConfig) {  // tslint:disable-next-line  console.log('Found prettier config file');  }   // tslint:disable-next-line  console.log('Generating typings...');   // copy runtime in directory of first typing (@todo it should be customizable)  const runtimeFilename = 'typechain-runtime.ts';  const runtimePath = join(options.outDir || dirname(matches[0]), runtimeFilename);  copyRuntime(runtimePath);  // tslint:disable-next-line  console.log(blue(`${runtimeFilename} => ${runtimePath}`));   // generate wrappers  matches.forEach(p =>  processFile(  p,  options.force,  runtimePath,  { ...(prettierConfig || {}), parser: 'typescript' },  options.outDir,  ),  ); }"
"../test-repos/Neufund_TypeChain/lib/cli.ts","processFile","{  const relativeInputPath = relative(cwd, absPath);  const parsedInputPath = parse(absPath);  const filenameWithoutAnyExtensions = getFilenameWithoutAnyExtensions(parsedInputPath.name);  const outputDir = fixedOutputDir || parsedInputPath.dir;  const outputPath = join(outputDir, filenameWithoutAnyExtensions + '.ts');  const relativeOutputPath = relative(cwd, outputPath);   const runtimeRelativePath = getRelativeModulePath(outputDir, runtimeAbsPath);  // tslint:disable-next-line  console.log(blue(`${relativeInputPath} => ${relativeOutputPath}`));  if (pathExistsSync(outputPath) && !forceOverwrite) {  // tslint:disable-next-line  console.log(red('File exists, skipping'));  return;  }   const abiString = readFileSync(absPath).toString();  const rawAbi = extractAbi(abiString);   const typescriptSourceFile = generateSource(rawAbi, {  fileName: filenameWithoutAnyExtensions,  relativeRuntimePath: runtimeRelativePath,  });  writeFileSync(outputPath, prettier.format(typescriptSourceFile, prettierConfig)); }"
"../test-repos/Neufund_TypeChain/lib/cli.ts","getFilenameWithoutAnyExtensions","{  const endPosition = filePath.indexOf('.');  return filePath.slice(0, endPosition !== -1 ? endPosition : filePath.length); }"
"../test-repos/Neufund_TypeChain/lib/cli.ts","getRelativeModulePath","{  return ('./' + relative(from, to)).replace('.ts', ''); // @note: this is probably not the best way to find relative path for modules }"
"../test-repos/Neufund_TypeChain/lib/utils.ts","getVersion","{  const packageJson: any = require('../package.json');   return packageJson.version; }"
"../test-repos/Neufund_TypeChain/lib/parseArgs.ts","parseArgs","{  const optionDefinitions = [  { name: 'force', alias: 'f', type: Boolean },  { name: 'glob', type: String, defaultOption: true },  { name: 'outDir', type: String },  ];   const rawOptions = commandLineArgs(optionDefinitions);   return {  force: !!rawOptions.force,  glob: rawOptions.glob || DEFAULT_GLOB_PATTERN,  outDir: rawOptions.outDir,  }; }"
"../test-repos/Neufund_TypeChain/lib/copyRuntime.ts","copyRuntime","{  copySync(join(__dirname, '../runtime/typechain-runtime.ts'), path); }"
"../test-repos/Neufund_TypeChain/lib/typeParser.ts","parseEvmType","{  const lastChar = rawType[rawType.length - 1];   if (lastChar === ']') {  // we parse array type  let finishArrayTypeIndex = rawType.length - 2;  while (rawType[finishArrayTypeIndex] !== '[') {  finishArrayTypeIndex--;  }   const arraySizeRaw = rawType.slice(finishArrayTypeIndex + 1, rawType.length - 1);  const arraySize = arraySizeRaw !== '' ? parseInt(arraySizeRaw) : undefined;   const restOfTheType = rawType.slice(0, finishArrayTypeIndex);   return new ArrayType(parseEvmType(restOfTheType), arraySize);  }   // this has to be primitive type   //first deal with simple types  switch (rawType) {  case 'bool':  return new BooleanType();  case 'address':  return new AddressType();  case 'string':  return new StringType();  case 'byte':  return new BytesType(1);  case 'bytes':  return new ArrayType(new BytesType(1));  }   if (isUIntTypeRegex.test(rawType)) {  const match = isUIntTypeRegex.exec(rawType);  return new UnsignedIntegerType(parseInt(match![1] || '256'));  }   if (isIntTypeRegex.test(rawType)) {  const match = isIntTypeRegex.exec(rawType);  return new IntegerType(parseInt(match![1] || '256'));  }   if (isBytesTypeRegex.test(rawType)) {  const match = isBytesTypeRegex.exec(rawType);  return new BytesType(parseInt(match![1] || '1'));  }   throw new Error('Unknown type: ' + rawType); }"
"../test-repos/Polymer_lit-html/tools/src/site.ts","generateDocs","{  await fs.emptyDir(docsOutDir);  const fileNames = await glob('**/*.md', { cwd: docsSrcDir });   // Read in all file data  const files = new Map<string, FileData>(await Promise.all(fileNames.map(async (fileName) => {  const filePath = path.parse(fileName);  const content = await fs.readFile(path.join(docsSrcDir, fileName), 'utf-8');  const pageData = frontMatter(content);  const outPath = `${filePath.dir}/${stripOrdering(filePath.name)}.html`;   return [fileName, {  path: filePath,  outPath,  attributes: pageData.attributes,  body: pageData.body,  }] as [string, FileData];  })));   for (const fileData of files.values()) {  const outDir = path.join(docsOutDir, fileData.path.dir);  await fs.mkdirs(outDir);  const body = marked(fileData.body);  // const section = fileData.path.dir.split(path.sep)[0] || 'home';  const outContent = page(fileData.outPath, body, files);  const outPath = path.join(docsOutDir, fileData.outPath);  fs.writeFile(outPath, outContent);  }   fs.copyFileSync(path.join(docsSrcDir, 'index.css'), path.join(docsOutDir, 'index.css'));  fs.copyFileSync(path.resolve(__dirname, '../node_modules/prismjs/themes/prism-okaidia.css'), path.join(docsOutDir, 'prism.css'));  await fs.writeFile(path.join(docsOutDir, '.nojekyll'), '');  await exec('npm run gen-docs', {cwd: '../'}); }"
"../test-repos/Polymer_lit-html/tools/src/site.ts","sortOutline","{  // re-insert index first  sorted.set('index', unsorted.get('index')!);  unsorted.delete('index');  // re-insert other entries in alpha-order  unsorted.forEach((value, key) => {  if (value instanceof Map) {  value = sortOutline(value, new Map());  }  sorted.set(key, value);  });  return sorted;  }"
"../test-repos/Polymer_lit-html/src/lit-html.ts","defaultTemplateFactory","{  let templateCache = templateCaches.get(result.type);  if (templateCache === undefined) {  templateCache = new Map<TemplateStringsArray, Template>();  templateCaches.set(result.type, templateCache);  }  let template = templateCache.get(result.strings);  if (template === undefined) {  template = new Template(result, result.getTemplateElement());  templateCache.set(result.strings, template);  }  return template; }"
"../test-repos/Polymer_lit-html/src/lit-html.ts","render","{  const template = templateFactory(result);  let instance = (container as any).__templateInstance as any;   // Repeat render, just call update()  if (instance !== undefined && instance.template === template &&  instance._partCallback === result.partCallback) {  instance.update(result.values);  return;  }   // First render, create a new TemplateInstance and append it  instance =  new TemplateInstance(template, result.partCallback, templateFactory);  (container as any).__templateInstance = instance;   const fragment = instance._clone();  instance.update(result.values);   removeNodes(container, container.firstChild);  container.appendChild(fragment); }"
"../test-repos/Polymer_lit-html/src/lit-html.ts","findTagClose","{  const close = str.lastIndexOf('>');  const open = str.indexOf('<', close + 1);  return open > -1 ? str.length : close; }"
"../test-repos/Polymer_lit-html/src/lib/repeat.ts","cleanMap","{  if (!part.startNode.parentNode) {  map.delete(key);  } }"
"../test-repos/Polymer_lit-html/src/lib/repeat.ts","repeat","no body"
"../test-repos/Polymer_lit-html/src/lib/repeat.ts","repeat","no body"
"../test-repos/Polymer_lit-html/src/lib/repeat.ts","repeat","{  let keyFn: KeyFn<T>;  if (arguments.length === 2) {  template = keyFnOrTemplate;  } else if (arguments.length === 3) {  keyFn = keyFnOrTemplate as KeyFn<T>;  }   return directive((part: Part): any => {  if (!(part instanceof NodePart)) {  throw new Error('repeat can only be used on NodeParts');  }   let keyMap = keyMapCache.get(part);  if (keyMap === undefined) {  keyMap = new Map();  keyMapCache.set(part, keyMap);  }  const container = part.startNode.parentNode as HTMLElement | ShadowRoot |  DocumentFragment;  let index = -1;  let currentMarker = part.startNode.nextSibling!;   for (const item of items) {  let result;  let key;  try {  ++index;  result = template !(item, index);  key = keyFn ? keyFn(item) : index;  } catch (e) {  console.error(e);  continue;  }   // Try to reuse a part  let itemPart = keyMap.get(key);  if (itemPart === undefined) {  const marker = document.createTextNode('');  const endNode = document.createTextNode('');  container.insertBefore(marker, currentMarker);  container.insertBefore(endNode, currentMarker);  itemPart = new NodePart(part.instance, marker, endNode);  if (key !== undefined) {  keyMap.set(key, itemPart);  }  } else if (currentMarker !== itemPart.startNode) {  // Existing part in the wrong position  const end = itemPart.endNode.nextSibling!;  if (currentMarker !== end) {  reparentNodes(container, itemPart.startNode, end, currentMarker);  }  } else {  // else part is in the correct position already  currentMarker = itemPart.endNode.nextSibling!;  }   itemPart.setValue(result);  }   // Cleanup  if (currentMarker !== part.endNode) {  removeNodes(container, currentMarker, part.endNode);  keyMap.forEach(cleanMap);  }  }); }"
"../test-repos/Polymer_lit-html/src/lib/shady-render.ts","render","{  return baseRender(result, container, shadyTemplateFactory(scopeName)); }"
"../test-repos/SebastianM_angular-google-maps/packages/core/core.module.ts","coreDirectives","{  return [  AgmMap, AgmMarker, AgmInfoWindow, AgmCircle,  AgmPolygon, AgmPolyline, AgmPolylinePoint, AgmKmlLayer,  AgmDataLayer  ]; }"
"../test-repos/SierraSoftworks_Iridium/test/Model.ts","createInstanceImplementation","{  let fn = function() { return {}; };  _.merge(fn, properties);  return fn;  }"
"../test-repos/SierraSoftworks_Iridium/test/issues/#83.ts","build_dataset","{  return new Array(count).fill(undefined).map((val, idx) => {  return {  i: idx,  x: new Date((start+idx) * 1000)  };  });  }"
"../test-repos/SierraSoftworks_Iridium/benchmarks/mongodb.ts","benchmark","{  return Bluebird.resolve(new Array(samples)).map(() => {  var objects: UserDocument[] = new Array(intensity);  for (var i = 0; i < objects.length; i++)  objects[i] = { _id: crypto.pseudoRandomBytes(16).toString('hex') };   return Bluebird.resolve().then(() => prepare(objects)).then(() => {  var start = new Date();  return Bluebird.resolve().then(() => run(objects)).then(() => {  var time = new Date().valueOf() - start.valueOf();  return time;  });  })  }, { concurrency: 1 }).then(times => {  results[name] = _.reduce(<number[]><any>times,(x, y) => x + y, 0) / times.length;  console.log('%s: %dms', name, results[name]);  if (compareTo) {  if (Math.abs(results[name] - results[compareTo]) / results[compareTo] < 0.1) { }  else if (results[name] > results[compareTo]) console.log(' - %dx slower than %s',(results[name] / results[compareTo]).toPrecision(2), compareTo);  else if (results[name] < results[compareTo]) console.log(' - %dx faster than %s',(results[name] / results[compareTo]).toPrecision(2), compareTo);  }   return results[name];  }); }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Collection","{  return function(target: InstanceImplementation<any, any>) {   target.collection = name;  }; }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Index","{  return function(target: InstanceImplementation<any,any>) {   target.indexes = (target.indexes || []).concat(<Index>{ spec: spec, options: options || {} });  } }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Validate","{  return function(target: InstanceImplementation<any,any>) {   target.validators = (target.validators || []).concat(Skmatc.create(schema => schema === forType, validate));  } }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Property","no body"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Property","no body"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Property","{  let name: string|number|undefined = undefined,   asType: any = false,   required: boolean = true;   if (args.length > 1 && typeof args[args.length - 1] === 'boolean')   required = args.pop();   return function(target: InstanceImplementation<any, any>, property?: string) {   let staticTarget: InstanceImplementation<any, any> = target;   if (!property) name = args.shift();   else {    name = property;    staticTarget = <InstanceImplementation<any, any>>target.constructor;   }   asType = args.pop() || false;    staticTarget.schema = _.clone(staticTarget.schema || { _id: false });   if(!required && typeof asType !== 'boolean') staticTarget.schema[name!] = { $required: required, $type: asType };   else staticTarget.schema[name!] = asType;  } }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Transform","{  return function(target: Instance<any, any>|InstanceImplementation<any, any>, property: string = '$document') {   let staticTarget: InstanceImplementation<any, any> = <InstanceImplementation<any, any>>(target instanceof Instance && target.constructor || target);    staticTarget.transforms = _.clone(staticTarget.transforms || <Transforms>{})   staticTarget.transforms[property] = {    fromDB: fromDB,    toDB: toDB   };  }; }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","ObjectID","{  Property(MongoDB.ObjectID)(target, name);  Transform(   DefaultTransforms.ObjectID.fromDB,   DefaultTransforms.ObjectID.toDB  )(target, name); }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","Binary","{  Property(Buffer)(target, name);  Transform(   DefaultTransforms.Binary.fromDB,   DefaultTransforms.Binary.toDB  )(target, name); }"
"../test-repos/SierraSoftworks_Iridium/lib/Decorators.ts","MapReduce","{  return function (target: InstanceImplementation<any, any>) {   target.mapReduceOptions = { map: map, reduce: reduce };  }; }"
"../test-repos/SierraSoftworks_Iridium/lib/middleware/Express.ts","ExpressMiddlewareFactory","{  return function (req: http.ServerRequest, res: http.ServerResponse, next:(err?: Error, route?: String) => void) {  core.connect().then(function() {  Object.defineProperty(req, 'db', {  get: function() { return core; }  });  next();  }).catch(next);  }; }"
"../test-repos/SierraSoftworks_Iridium/lib/utils/UrlBuilder.ts","BuildUrl","{  let url: string = 'mongodb://';   if (config.username) {  url += config.username;  if (config.password)  url += ':' + config.password;  url += '@';  }   url += buildHostList(config);  if (config.database)  url += '/' + config.database;   return url; }"
"../test-repos/SierraSoftworks_Iridium/lib/utils/UrlBuilder.ts","buildHostList","{  let hosts: string[] = [];   if (config.host) {  if (config.port)  hosts.push(`${config.host}:${config.port}`);  else  hosts.push(config.host);  }   if (config.hosts) {  config.hosts.forEach(host => {  if (host.port)  hosts.push(`${host.address}:${host.port}`);  else if(config && config.port)  hosts.push(`${host.address}:${config.port}`);  else  hosts.push(host.address);  });  }   if (hosts.length)  return uniq(hosts).join(',');  else  return 'localhost'; }"
"../test-repos/SierraSoftworks_Iridium/lib/utils/ObjectID.ts","toObjectID","{  return MongoDB.ObjectID.createFromHexString(value); }"
"../test-repos/SierraSoftworks_Iridium/lib/MapReduce.ts","emit","no body"
"../test-repos/SierraSoftworks_Iridium/lib/Validators.ts","DefaultValidators","{  return [   Skmatc.create(schema => schema === MongoDB.ObjectID, function(schema, data) {    return this.assert(!data || data instanceof MongoDB.ObjectID || (data._bsontype === 'ObjectID' && data.id), 'Expected ' + JSON.stringify(data) + ' to be a valid MongoDB.ObjectID object');   }, { name: 'ObjectID validation' }),   Skmatc.create(schema => schema === Buffer, function(schema, data) {    return this.assert(data && (data instanceof MongoDB.Binary || (data._bsontype === 'Binary' && data.buffer)), 'Expected ' + JSON.stringify(data) + ' to be a valid MongoDB.Binary object');   }, { name: 'Buffer validation' })  ]; }"
"../test-repos/SierraSoftworks_Iridium/lib/ModelSpecificInstance.ts","ModelSpecificInstance","{  const instanceTypeConstructor = <InstanceConstructor><any>instanceType;  let virtualClass = class extends instanceTypeConstructor {  constructor(...args: any[]) {  super(model, ...args);  }  }   _.each(Object.keys(model.schema),(property) => {  const transform = model.transforms[property];  if (transform) {  return Object.defineProperty(virtualClass.prototype, property, {  get: function (this: InstanceInternals<TDocument, TInstance>) {  return transform.fromDB((<TDocument & { [prop: string]: any }>this._modified)[property], property, model);  },  set: function (this: InstanceInternals<TDocument, TInstance>, value: any) {  (<TDocument & { [prop: string]: any }>this._modified)[property] = transform.toDB(value, property, model);  },  enumerable: true,  configurable: true  });  }   Object.defineProperty(virtualClass.prototype, property, {  get: function (this: InstanceInternals<TDocument, TInstance>) {  return (<TDocument & { [prop: string]: any }>this._modified)[property];  },  set: function (this: InstanceInternals<TDocument, TInstance>, value: any) {  (<TDocument & { [prop: string]: any }>this._modified)[property] = value;  },  enumerable: true  });  });   return <any>virtualClass; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/database.ts","isNil","{  return obj === undefined || obj === null; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/database.ts","unwrap","{  let primitive = (/string|number|boolean/).test(typeof value);  let unwrapped = isNil(value) || primitive ? { } : value;   // Change Nil values to null  if (isNil(value)) {  Object.defineProperty(unwrapped, '$value', {  enumerable: false,  value: null  });  }   let initialValues = { key, value, exists, priority };   return ['value', 'exists', 'key', 'priority'].reduce((p, c) => {  if ((c === 'value' && !primitive ) || isNil(initialValues[c])) { return p; }  Object.defineProperty(p, `$${c}`, {  enumerable: false,  value: initialValues[c]  });  return p;  }, unwrapped); }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/list/emulate-query.ts","isNil","{  return obj === undefined || obj === null; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/list/emulate-query.ts","hasKey","{  return obj && obj[key] !== undefined; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/list/emulate-query.spec.ts","readable","{  const maxLength = 50;  const base = object ? JSON.stringify(object) : 'an undefined value';  return base.length > maxLength ? base.substr(0, maxLength) + '…' : base; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/offline-storage/localforage.ts","LocalForageToken","{  return new OpaqueToken('localforage'); }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/offline-storage/localforage.ts","localforageFactory","{  return <any>localforage; }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/offline-storage/offline-write.ts","OfflineWrite","{  return localUpdateService.update('write', (writeCache: WriteCache) => {  if (!writeCache) {  writeCache = {  lastId: 0,  cache: {}  };  }  writeCache.lastId++;  writeCache.cache[writeCache.lastId] = {type: type, ref: ref, method: method, args: args};  return writeCache;  }).then((writeCache: WriteCache) => {  const id = writeCache.lastId;  firebasePromise.then(() => {  WriteComplete(id, localUpdateService);  });  }); }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/offline-storage/offline-write.ts","WriteComplete","{  return localUpdateService.update('write', (writeCache: WriteCache) => {  delete writeCache.cache[id];  return writeCache;  }); }"
"../test-repos/adriancarriger_angularfire2-offline/src/database/offline-storage/local-update-service.ts","LOCAL_UPDATE_SERVICE_PROVIDER_FACTORY","{  return parent || new LocalUpdateService(token); }"
"../test-repos/adriancarriger_angularfire2-offline/src/index.ts","ANGULARFIRE_OFFLINE_PROVIDER_FACTORY","{  return parent || new AngularFireOfflineDatabase(AngularFireDatabase, token, LocalUpdateService ); }"
"../test-repos/akserg_ng2-dnd/tests/dnd.sortable.spec.ts","swap","{  swapMultiple(nodes, firstNodeId, nodes, secondNodeId); }"
"../test-repos/akserg_ng2-dnd/tests/dnd.sortable.spec.ts","swapMultiple","{  triggerEvent(<HTMLElement>nodesOne[firstNodeId], 'dragstart', 'MouseEvent');  triggerEvent(<HTMLElement>nodesTwo[secondNodeId], 'dragenter', 'MouseEvent'); }"
"../test-repos/akserg_ng2-dnd/tests/dnd.component.factory.ts","triggerEvent","{  var event:Event = document.createEvent(eventType);  event.initEvent(eventName, true, true);  elem.dispatchEvent(event); }"
"../test-repos/akserg_ng2-dnd/src/dnd.service.ts","dragDropServiceFactory","{  return new DragDropService(); }"
"../test-repos/akserg_ng2-dnd/src/dnd.service.ts","dragDropSortableServiceFactory","{  return new DragDropSortableService(config); }"
"../test-repos/akserg_ng2-dnd/src/dnd.utils.ts","isString","{  return typeof obj === 'string'; }"
"../test-repos/akserg_ng2-dnd/src/dnd.utils.ts","isPresent","{  return obj !== undefined && obj !== null; }"
"../test-repos/akserg_ng2-dnd/src/dnd.utils.ts","isFunction","{  return typeof obj === 'function'; }"
"../test-repos/akserg_ng2-dnd/src/dnd.utils.ts","createImage","{  let img:HTMLImageElement = new HTMLImageElement();  img.src = src;  return img; }"
"../test-repos/akserg_ng2-dnd/src/dnd.utils.ts","callFun","{  return fun(); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-retry/src/delayFunction.ts","buildDelayFunction","{  let baseDelay;  if (jitter) {  // If we're jittering, baseDelay is half of the maximum delay for that  // attempt (and is, on average, the delay we will encounter).  baseDelay = initial;  } else {  // If we're not jittering, adjust baseDelay so that the first attempt  // lines up with initialDelay, for everyone's sanity.  baseDelay = initial / 2;  }   return function delayFunction(count: number) {  let delay = Math.min(max, baseDelay * 2 ** count);  if (jitter) {  // We opt for a full jitter approach for a mostly uniform distribution,  // but bound it within initialDelay and delay for everyone's sanity.  delay = Math.random() * delay;  }   return delay;  }; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-retry/src/__tests__/delayFunction.ts","delayRange","{  const results = [];  for (let i = 1; i <= count; i++) {  results.push(delayFunction(i));  }  return results;  }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-retry/src/retryFunction.ts","buildRetryFunction","{  return function retryFunction(count, operation, error) {  if (count >= max) return false;  return retryIf ? retryIf(error, operation) : !!error;  }; }"
"../test-repos/apollographql_apollo-link/packages/zen-observable-ts/src/zenObservable.ts","require","no body"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/test-utils/testingUtils.ts","checkCalls","{  expect(calls.length).toBe(results.length);  calls.map((call, i) => expect(call.data).toEqual(results[i])); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/test-utils/testingUtils.ts","testLinkResults","{  const { link, context, variables } = params;  const results = params.results || [];  const query = params.query || sampleQuery;  const done = params.done || (() => void 0);   const spy = jest.fn();  execute(link, { query, context, variables }).subscribe({  next: spy,  error: error => {  expect(error).toEqual(results.pop());  checkCalls(spy.mock.calls[0], results);  if (done) {  done();  }  },  complete: () => {  checkCalls(spy.mock.calls[0], results);  if (done) {  done();  }  },  }); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/link.ts","execute","{  return (  link.request(  createOperation(  operation.context,  transformOperation(validateOperation(operation)),  ),  ) || Observable.of()  ); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","validateOperation","{  const OPERATION_FIELDS = [  'query',  'operationName',  'variables',  'extensions',  'context',  ];  for (let key of Object.keys(operation)) {  if (OPERATION_FIELDS.indexOf(key) < 0) {  throw new Error(`illegal argument: ${key}`);  }  }   return operation; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","isTerminating","{  return link.request.length <= 1; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","toPromise","{  let completed = false;  return new Promise<R>((resolve, reject) => {  observable.subscribe({  next: data => {  if (completed) {  console.warn(  `Promise Wrapper does not support multiple results from Observable`,  );  } else {  completed = true;  resolve(data);  }  },  error: reject,  });  }); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","fromPromise","{  return new Observable<T>(observer => {  promise  .then((value: T) => {  observer.next(value);  observer.complete();  })  .catch(observer.error.bind(observer));  }); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","fromError","{  return new Observable<T>(observer => {  observer.error(errorValue);  }); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","transformOperation","{  const transformedOperation: GraphQLRequest = {  variables: operation.variables || {},  extensions: operation.extensions || {},  operationName: operation.operationName,  query: operation.query,  };   // best guess at an operation name  if (!transformedOperation.operationName) {  transformedOperation.operationName =  typeof transformedOperation.query !== 'string'  ? getOperationName(transformedOperation.query)  : '';  }   return transformedOperation as Operation; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","createOperation","{  let context = { ...starting };  const setContext = next => {  if (typeof next === 'function') {  context = { ...context, ...next(context) };  } else {  context = { ...context, ...next };  }  };  const getContext = () => ({ ...context });   Object.defineProperty(operation, 'setContext', {  enumerable: false,  value: setContext,  });   Object.defineProperty(operation, 'getContext', {  enumerable: false,  value: getContext,  });   Object.defineProperty(operation, 'toKey', {  enumerable: false,  value: () => getKey(operation),  });   return operation as Operation; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link/src/linkUtils.ts","getKey","{  // XXX we're assuming here that variables will be serialized in the same order.  // that might not always be true  return `${print(operation.query)}|${JSON.stringify(operation.variables)}|${  operation.operationName  }`; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-batch/src/__tests__/batchLink.ts","requestToKey","{  const queryString =  typeof request.query === 'string' ? request.query : print(request.query);   return JSON.stringify({  variables: request.variables || {},  query: queryString,  }); }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-batch/src/__tests__/batchLink.ts","createMockBatchHandler","{  const mockedResponsesByKey: { [key: string]: MockedResponse[] } = {};   const mockBatchHandler: BatchHandler = (operations: Operation[]) => {  return new Observable(observer => {  const results = operations.map(operation => {  const key = requestToKey(operation);  const responses = mockedResponsesByKey[key];  if (!responses || responses.length === 0) {  throw new Error(  `No more mocked responses for the query: ${print(  operation.query,  )}, variables: ${JSON.stringify(operation.variables)}`,  );  }   const { result, error } = responses.shift()!;   if (!result && !error) {  throw new Error(  `Mocked response should contain either result or error: ${key}`,  );  }   if (error) {  observer.error(error);  }   return result;  });   observer.next(results);  });  };   (mockBatchHandler as any).addMockedResponse = (  mockedResponse: MockedResponse,  ) => {  const key = requestToKey(mockedResponse.request);  let _mockedResponses = mockedResponsesByKey[key];  if (!_mockedResponses) {  _mockedResponses = [];  mockedResponsesByKey[key] = _mockedResponses;  }  _mockedResponses.push(mockedResponse);  };   mockedResponses.map((mockBatchHandler as any).addMockedResponse);   return mockBatchHandler; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-dedup/src/__tests__/dedupLink.ts","getOperationName","{  let res: string | null = null;  doc.definitions.forEach(definition => {  if (definition.kind === 'OperationDefinition' && definition.name) {  res = definition.name.value;  }  });  return res; }"
"../test-repos/apollographql_apollo-link/packages/apollo-link-http/src/httpLink.ts","rewriteURIForGET","{  // Implement the standard HTTP GET serialization, plus 'extensions'. Note  // the extra level of JSON serialization!  const queryParams = [];  const addQueryParam = (key: string, value: string) => {  queryParams.push(`${key}=${encodeURIComponent(value)}`);  };   if ('query' in body) {  addQueryParam('query', body.query);  }  if (body.operationName) {  addQueryParam('operationName', body.operationName);  }  if (body.variables) {  let serializedVariables;  try {  serializedVariables = serializeFetchParameter(  body.variables,  'Variables map',  );  } catch (parseError) {  return { parseError };  }  addQueryParam('variables', serializedVariables);  }  if (body.extensions) {  let serializedExtensions;  try {  serializedExtensions = serializeFetchParameter(  body.extensions,  'Extensions map',  );  } catch (parseError) {  return { parseError };  }  addQueryParam('extensions', serializedExtensions);  }   // Reconstruct the URI with added query params.  // XXX This assumes that the URI is well-formed and that it doesn't  // already contain any of these query params. We could instead use the  // URL API and take a polyfill (whatwg-url@6) for older browsers that  // don't support URLSearchParams. Note that some browsers (and  // versions of whatwg-url) support URL but not URLSearchParams!  let fragment = '',  preFragment = chosenURI;  const fragmentStart = chosenURI.indexOf('#');  if (fragmentStart !== -1) {  fragment = chosenURI.substr(fragmentStart);  preFragment = chosenURI.substr(0, fragmentStart);  }  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';  const newURI =  preFragment + queryParamsPrefix + queryParams.join('&') + fragment;  return { newURI }; }"
"../test-repos/apollographql_react-apollo/test/test-utils/createClient.ts","createClient","{  return new ApolloClient({  link: mockSingleLink({  request: { query, variables },  result: { data },  }),  cache: new InMemoryCache({ addTypename: false }),  }); }"
"../test-repos/apollographql_react-apollo/test/test-utils/wait.ts","wait","{  return new Promise(resolve => setTimeout(() => resolve(), ms)); }"
"../test-repos/apollographql_react-apollo/test/test-utils/stripSymbols.ts","stripSymbols","{  return JSON.parse(JSON.stringify(data)); }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","getProps","{  return (element as ReactElement<P>).props || (element as PreactElement<P>).attributes; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","isReactElement","{  return !!(element as any).type; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","isComponentClass","{  return Comp.prototype && (Comp.prototype.render || Comp.prototype.isReactComponent); }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","providesChildContext","{  return !!(instance as any).getChildContext; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","walkTree","{  if (Array.isArray(element)) {  element.forEach(item => walkTree(item, context, visitor));   return;  }   if (!element) return;   // a stateless functional component or a class  if (isReactElement(element)) {  if (typeof element.type === 'function') {  const Comp = element.type;  const props = Object.assign({}, Comp.defaultProps, getProps(element));  let childContext = context;  let child;   // Are we are a react class?  // https://github.com/facebook/react/blob/master/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L66  if (isComponentClass(Comp)) {  const instance = new Comp(props, context);  // In case the user doesn't pass these to super in the constructor  instance.props = instance.props || props;  instance.context = instance.context || context;  // set the instance state to null (not undefined) if not set, to match React behaviour  instance.state = instance.state || null;   // Override setState to just change the state, not queue up an update.  // (we can't do the default React thing as we aren't mounted 'properly'  // however, we don't need to re-render as well only support setState in  // componentWillMount, which happens *before* render).  instance.setState = newState => {  if (typeof newState === 'function') {  // React's TS type definitions don't contain context as a third parameter for  // setState's updater function.  // Remove this cast to `any` when that is fixed.  newState = (newState as any)(instance.state, instance.props, instance.context);  }  instance.state = Object.assign({}, instance.state, newState);  };   // this is a poor man's version of  // https://github.com/facebook/react/blob/master/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L181  if (instance.componentWillMount) {  instance.componentWillMount();  }   if (providesChildContext(instance)) {  childContext = Object.assign({}, context, instance.getChildContext());  }   if (visitor(element, instance, context) === false) {  return;  }   child = instance.render();  } else {  // just a stateless functional  if (visitor(element, null, context) === false) {  return;  }   child = Comp(props, context);  }   if (child) {  if (Array.isArray(child)) {  child.forEach(item => walkTree(item, context, visitor));  } else {  walkTree(child, childContext, visitor);  }  }  } else {  // a basic string or dom element, just get children  if (visitor(element, null, context) === false) {  return;  }   if (element.props && element.props.children) {  Children.forEach(element.props.children, (child: any) => {  if (child) {  walkTree(child, context, visitor);  }  });  }  }  } else if (typeof element === 'string' || typeof element === 'number') {  // Just visit these, they are leaves so we don't keep traversing.  visitor(element, null, context);  }  // TODO: Portals? }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","hasFetchDataFunction","{  return typeof (instance as any).fetchData === 'function'; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","isPromise","{  return typeof (query as any).then === 'function'; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","getQueriesFromTree","{  const queries: QueryTreeResult<Cache>[] = [];   walkTree(rootElement, rootContext, (element, instance, context) => {  const skipRoot = !fetchRoot && element === rootElement;  if (skipRoot) return;   if (instance && isReactElement(element) && hasFetchDataFunction(instance)) {  const query = instance.fetchData();  if (isPromise<Object>(query)) {  queries.push({ query, element, context });   // Tell walkTree to not recurse inside this component; we will  // wait for the query to execute before attempting it.  return false;  }  }  });   return queries; }"
"../test-repos/apollographql_react-apollo/src/getDataFromTree.ts","getDataFromTree","{  let queries = getQueriesFromTree({ rootElement, rootContext }, fetchRoot);   // no queries found, nothing to do  if (!queries.length) return Promise.resolve();   const errors: any[] = [];  // wait on each query that we found, re-rendering the subtree when it's done  const mappedQueries = queries.map(({ query, element, context }) => {  // we've just grabbed the query for element, so don't try and get it again  return query.then(_ => getDataFromTree(element, context, false)).catch(e => errors.push(e));  });   // Run all queries. If there are errors, still wait for all queries to execute  // so the caller can ignore them if they wish. See https://github.com/apollographql/react-apollo/pull/488#issuecomment-284415525  return Promise.all(mappedQueries).then(_ => {  if (errors.length > 0) {  const error =  errors.length === 1  ? errors[0]  : new Error(`${errors.length} errors were thrown when executing your GraphQL queries.`);  error.queryErrors = errors;  throw error;  }  }); }"
"../test-repos/apollographql_react-apollo/src/parser.ts","parser","{  const cached = cache.get(document);  if (cached) return cached;  // variables  let variables, type, name;   /*   Saftey checks for proper usage of react-apollo   */  invariant(  !!document && !!document.kind,  // tslint:disable-line  `Argument of ${document} passed to parser was not a valid GraphQL ` +  `DocumentNode. You may need to use 'graphql-tag' or another method ` +  `to convert your operation into a document`,  );   const fragments = document.definitions.filter(  (x: DefinitionNode) => x.kind === 'FragmentDefinition',  );   const queries = document.definitions.filter(  (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'query',  );   const mutations = document.definitions.filter(  (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'mutation',  );   const subscriptions = document.definitions.filter(  (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'subscription',  );   invariant(  !fragments.length || (queries.length || mutations.length || subscriptions.length),  `Passing only a fragment to 'graphql' is not yet supported. ` +  `You must include a query, subscription or mutation as well`,  );   invariant(  queries.length + mutations.length + subscriptions.length <= 1,  // tslint:disable-line  `react-apollo only supports a query, subscription, or a mutation per HOC. ` +  `${document} had ${queries.length} queries, ${subscriptions.length} ` +  `subscriptions and ${mutations.length} mutations. ` +  `You can use 'compose' to join multiple operation types to a component`,  );   type = queries.length ? DocumentType.Query : DocumentType.Mutation;  if (!queries.length && !mutations.length) type = DocumentType.Subscription;   const definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;   invariant(  definitions.length === 1,  // tslint:disable-line  `react-apollo only supports one defintion per HOC. ${document} had ` +  `${definitions.length} definitions. ` +  `You can use 'compose' to join multiple operation types to a component`,  );   const definition = definitions[0] as OperationDefinitionNode;  variables = definition.variableDefinitions || [];   if (definition.name && definition.name.kind === 'Name') {  name = definition.name.value;  } else {  name = 'data'; // fallback to using data if no name  }   const payload = { name, type, variables };  cache.set(document, payload);  return payload; }"
"../test-repos/apollographql_react-apollo/src/test-links.ts","requestToKey","{  const queryString = request.query && print(request.query);   const requestKey = {  variables: request.variables || {},  query: queryString,  };   return JSON.stringify(requestKey); }"
"../test-repos/apollographql_react-apollo/src/test-links.ts","mockSingleLink","{  return new MockLink(mockedResponses); }"
"../test-repos/apollographql_react-apollo/src/test-links.ts","mockObservableLink","{  return new MockSubscriptionLink(); }"
"../test-repos/apollographql_react-apollo/src/renderToStringWithData.ts","renderToStringWithData","{  return getDataFromTree(component).then(() => ReactDOM.renderToString(component)); }"
"../test-repos/artemsky_ng-snotify/src/snotify/decorators/set-toast-type.decorator.ts","SetToastType","{  return {  value: function (...args: any[]) {  (args[0] as Snotify).config = {  ...(args[0] as Snotify).config,  type: propertyKey  };  return descriptor.value.apply(this, args);  }  }; }"
"../test-repos/artemsky_ng-snotify/src/snotify/decorators/transform-argument.decorator.ts","TransformArgument","{  if (propertyKey === SnotifyStyle.async) {  return {  value: function (...args: any[]) {  let result;  if (args.length === 2) {  result = {  title: null,  body: args[0],  config: null,  action: args[1]  }  } else if (args.length === 3) {  if (typeof args[1] === 'string') {  result = {  title: args[1],  body: args[0],  config: null,  action: args[2]  }  } else {  result = {  title: null,  body: args[0],  config: args[2],  action: args[1]  }  }  } else {  result = {  title: args[1],  body: args[0],  config: args[3],  action: args[2]  };  }  return descriptor.value.apply(this, [result as Snotify]);  }  };  } else {  return {  value: function (...args: any[]) {  let result;  if (args.length === 1) {  result = {  title: null,  body: args[0],  config: null  }  } else if (args.length === 3) {  result = {  title: args[1],  body: args[0],  config: args[2]  }  } else {  result = {  title: null,  config: null,  body: args[0],  [typeof args[1] === 'string' ? 'title' : 'config']: args[1]  };  }  return descriptor.value.apply(this, [result as Snotify]);  }  };  }  }"
"../test-repos/artemsky_ng-snotify/src/snotify/utils.ts","uuid","{  return Math.floor(Math.random() * (Date.now() - 1)) + 1; }"
"../test-repos/artemsky_ng-snotify/src/snotify/utils.ts","isObject","{  return (item && typeof item === 'object' && !Array.isArray(item) && item !== null); }"
"../test-repos/artemsky_ng-snotify/src/snotify/utils.ts","mergeDeep","{  const target = {};  if (!sources.length) {  return target;  }   while (sources.length > 0) {  const source = sources.shift();  if (isObject(source)) {  for (const key in source) {  if (isObject(source[key])) {  target[key] = mergeDeep(target[key], source[key]);  } else {  Object.assign(target, { [key]: source[key] });  }  }  }  }  return target; }"
"../test-repos/artemsky_ng-snotify/src/snotify/utils.ts","animate","{  let endTime;  requestAnimationFrame((timestamp) => endTime = timestamp + duration);  const calculate = () => {  requestAnimationFrame((timestamp) => {  const runtime = timestamp - endTime;  const progress = Math.min(runtime / duration, 1) + start;  if (runtime < duration) {  if (callback(+(100 * progress).toFixed(2), progress)) {  calculate();  }  }  })  } }"
"../test-repos/biesbjerg_ngx-translate-extract/src/utils/utils.ts","_","{  return key; }"
"../test-repos/btroncone_ngrx-store-localstorage/spec/index_spec.ts","mockStorageKeySerializer","{ return key; }"
"../test-repos/cbowdon_TsMonad/test/examples.ts","getBusPass","{  return age > 100 ?  Maybe.nothing<BusPass>() :  Maybe.just(new BusPass())  }"
"../test-repos/cbowdon_TsMonad/test/examples.ts","getBusPass","{  return age > 100 ?  Either.left<string, BusPass>('Too young for a bus pass') :  Either.right<string, BusPass>(new BusPass());  }"
"../test-repos/cbowdon_TsMonad/src/writer.ts","writer","{  return Writer.writer(story, value); }"
"../test-repos/cbowdon_TsMonad/src/maybe.ts","maybe","{  return Maybe.maybe(t); }"
"../test-repos/cbowdon_TsMonad/src/either.ts","exists","{  return t !== null && t !== undefined; }"
"../test-repos/cbowdon_TsMonad/src/either.ts","either","{  if (exists(l) && exists(r)) {  throw new TypeError('Cannot construct an Either with both a left and a right');  }  if (!exists(l) && !exists(r)) {  throw new TypeError('Cannot construct an Either with neither a left nor a right');  }  if (exists(l) && !exists(r)) {  return Either.left<L,R>(l);  }  if (!exists(l) && exists(r)) {  return Either.right<L,R>(r);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/addTypeName.ts","transformDocument","{  return context.parseOperation({  rootId: 'abc',  document: context.transformDocument(gql(operation)),  });  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/addTypeName.ts","fieldNames","{  const names = [] as string[];  for (const selection of selectionSet.selections) {  if (selection.kind !== 'Field') continue;  names.push(selection.name.value);  }  return names;  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/entityTransformation.ts","queryWithTypename","{  const rawOperation = query(gqlString, variables, rootId);  return { ...rawOperation, document: addTypenameToDocument(rawOperation.document) };  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/entityTransformation.ts","mixinHelperMethods","{  if (obj['__typename'] === 'viewer') {  const newPrototype = _.clone(Object.getPrototypeOf(obj));  Object.assign(newPrototype, proto);  Object.setPrototypeOf(obj, newPrototype);  }  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/entityTransformation.ts","mixinHelperMethods","{  if (obj['__typename'] === 'user') {  const newPrototype = _.clone(Object.getPrototypeOf(obj));  Object.assign(newPrototype, proto);  Object.setPrototypeOf(obj, newPrototype);  }  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/entityTransformation.ts","mixinHelperMethods","{  if (obj['__typename'] === 'user') {  const newPrototype = _.clone(Object.getPrototypeOf(obj));  Object.assign(newPrototype, proto);  Object.setPrototypeOf(obj, newPrototype);  }  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/context/CacheContext/entityTransformation.ts","mixinHelperMethods","{  if (obj['__typename'] === 'viewer') {  const newPrototype = _.clone(Object.getPrototypeOf(obj));  Object.assign(newPrototype, proto);  Object.setPrototypeOf(obj, newPrototype);  }  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/util/ast/selectionSetIsStatic.ts","selection","{  return gql(source).definitions[0].selectionSet;  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/util/ast/selectionSetIsStatic.ts","fragmentGetter","{  return undefined;  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/ParsedQueryNode/expandVariables.ts","makeFieldMap","{  return new QueryInfo(context, buildRawOperationFromQuery(gql(query))).parsed;  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/ParsedQueryNode/fragments.ts","parseOperation","{  const document = gql(operationString);  const operation = getOperationOrDie(document);  const FragmentMap = fragmentMapForDocument(document);  return parseQuery(context, FragmentMap, operation.selectionSet);  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/ParsedQueryNode/static.ts","parseOperation","{  const operation = getOperationOrDie(gql(operationString));  return parseQuery(context, {}, operation.selectionSet);  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/ParsedQueryNode/directives.ts","parseOperation","{  const document = gql(operationString);  const operation = getOperationOrDie(document);  const FragmentMap = fragmentMapForDocument(document);  return parseQuery(context, FragmentMap, operation.selectionSet);  }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/migrate/entitiesReferencedInParameterizedValue.ts","createNewCacheSnapshot","{  const snapshot = createGraphSnapshot(  {  one: {  two: [  {  three: {  id: 31,  four: { five: 1 },  color: 'blue',  __typename: 'THREE',  },  },  {  three: {  id: 32,  four: { five: 1 },  color: 'gold',  __typename: 'THREE',  },  },  null,  ],  },  },  `query nested($id: ID!) {  one {  two(id: $id) {  three {  id  four(extra: true) {  five  }  color  __typename  }  }  }  }`,  cacheContext,  { id: 1 }  );  return new CacheSnapshot(snapshot, snapshot, new OptimisticUpdateQueue()); }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/migrate/entityMigrations.ts","createNewCacheSnapshot","{  const snapshot = createGraphSnapshot(  {  foo: 123,  bar: 'asdf',  viewer: {  id: 'a',  first: 'Jonh',  last: 'Doe',  __typename: 'Viewer',  },  },  `{ foo bar viewer { id first last __typename } }`,  cacheContext  );  return new CacheSnapshot(snapshot, snapshot, new OptimisticUpdateQueue()); }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/restore/basic/arrayOfReferencesOffARoot.ts","entityTransformer","{  if (node['__typename'] === 'viewer') {  Object.setPrototypeOf(node, Viewer.prototype);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/restore/basic/multipleReferencesOffARoot.ts","entityTransformer","{  switch (node['__typename']) {  case 'Foo':  Object.setPrototypeOf(node, Foo.prototype);  break;  case 'Bar':  Object.setPrototypeOf(node, Bar.prototype);  break;  } }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/restore/basic/nestedReferencesInArray.ts","entityTransformer","{  if (node['__typename'] === 'Three') {  Object.setPrototypeOf(node, Three.prototype);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/test/unit/operations/restore/basic/nestedReference.ts","entityTransformer","{  if (node['__typename'] === 'Three') {  Object.setPrototypeOf(node, Three.prototype);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/test/helpers/serialization.ts","createGraphSnapshot","{  return createSnapshot(  payload,  gqlString,  gqlVariables,  rootId,  cacheContext  ).snapshot; }"
"../test-repos/convoyinc_apollo-cache-hermes/test/helpers/context.ts","createStrictCacheContext","{  return new CacheContext(strictConfig); }"
"../test-repos/convoyinc_apollo-cache-hermes/test/helpers/write.ts","createSnapshot","{   const rawOperation = query(gqlString, gqlVariables, rootId);   return write(  cacheContext,  new GraphSnapshot(),  { ...rawOperation, document: cacheContext.transformDocument(rawOperation.document) },  payload  ); }"
"../test-repos/convoyinc_apollo-cache-hermes/test/helpers/write.ts","updateSnapshot","{   const rawOperation = query(gqlString, gqlVariables, rootId);   return write(  cacheContext,  baseline,  { ...rawOperation, document: cacheContext.transformDocument(rawOperation.document) },  payload  ); }"
"../test-repos/convoyinc_apollo-cache-hermes/test/helpers/graphql.ts","query","{  return {  rootId: rootId || StaticNodeId.QueryRoot,  document: gql(gqlString),  variables,  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/schema.ts","isSerializable","{  if (isScalar(value)) {  // NaN is considered to typeof number  const isNaNValue = Number.isNaN(value as any);  return allowUndefined ? !isNaNValue : !isNaNValue && value !== undefined;  }   if (isObject(value)) {  for (const propName of Object.getOwnPropertyNames(value)) {  if (!isSerializable(value[propName], allowUndefined)) {  return false;  }  }  return true;  }   if (Array.isArray(value)) {  for (const element of value) {  if (!isSerializable(element, allowUndefined)) {  return false;  }  }  return true;  }   return false; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/context/CacheContext.ts","_makeEntityIdMapper","{  return function entityIdForNode(node: JsonObject) {  if (!isObject(node)) return undefined;   // We don't trust upstream implementations.  const entityId = mapper(node);  if (typeof entityId === 'string') return entityId;  if (typeof entityId === 'number') return String(entityId);  return undefined;  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/context/CacheContext.ts","defaultEntityIdMapper","{  return node.id; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/context/CacheContext.ts","operationCacheKey","{  if (fragmentName) {  return `${fragmentName}❖${document.loc!.source.body}`;  }  return document.loc!.source.body; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/context/ConsoleTracer.ts","_makeDefaultEmitter","{  const method = console[level] || console.log; // eslint-disable-line no-console  return function defaultLogger(message: string, ...args: any[]) {  method.call(console, `[Cache] ${message}`, ...args);  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","variableDefaultsInOperation","{  const defaults = {};  if (operation.variableDefinitions) {  for (const definition of operation.variableDefinitions) {  if (definition.type.kind === 'NonNullType') continue; // Required.   const { defaultValue } = definition;  defaults[definition.variable.name.value] = isObject(defaultValue) ? valueFromNode(defaultValue as ValueNode) : null;  }  }   return defaults; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","fragmentMapForDocument","{  const map: FragmentMap = {};  for (const definition of document.definitions) {  if (definition.kind !== 'FragmentDefinition') continue;  map[definition.name.value] = definition;  }   return map; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","selectionSetIsStatic","{  for (const selection of selectionSet.selections) {  if (selection.kind === 'Field') {  if (!fieldIsStatic(selection)) return false;  if (selection.selectionSet && !selectionSetIsStatic(selection.selectionSet, fragmentGetter)) return false;   } else if (selection.kind === 'FragmentSpread') {  if (!fragmentGetter) {  throw new Error(`fragmentGetter is required for selection sets with ...fragments`);  }  const fragmentSet = fragmentGetter(selection.name.value);  if (!fragmentSet) {  throw new Error(`Unknown fragment ${selection.name.value} in isSelectionSetStatic`);  }   if (!selectionSetIsStatic(fragmentSet, fragmentGetter)) return false;   } else if (selection.kind === 'InlineFragment') {  if (!selectionSetIsStatic(selection.selectionSet, fragmentGetter)) return false;   } else {  throw new Error(`Unknown selection type ${(selection as any).kind} in isSelectionSetStatic`);  }  }   return true; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","fieldIsStatic","{  const isActuallyStatic = !fieldHasAlias(field) && !fieldIsParameterized(field);  return isActuallyStatic || fieldHasStaticDirective(field); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","fieldHasAlias","{  return !!field.alias; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","fieldIsParameterized","{  return !!(field.arguments && field.arguments.length); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/ast.ts","fieldHasStaticDirective","{  if (!directives) return false;  return directives.some(directive => directive.name.value === 'static'); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/collection.ts","deepGet","{  return path.length ? lodashGet(target, path) : target; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/collection.ts","pathBeginsWith","{  if (target.length < prefix.length) return false;  for (let i = 0; i < prefix.length; i++) {  if (prefix[i] !== target[i]) return false;  }  return true; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/collection.ts","addToSet","{  for (const value of source) {  target.add(value);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/collection.ts","lazyImmutableDeepSet","{  if (!path.length) return value;   let parentNode;  let targetNode: any = target;  let originalNode: any = original;  // We assume that the last path component is the key of a value; not a  // container, so we stop there.  for (let i = 0; i < path.length; i++) {  const key = path[i];  // If the target still references the original's objects, we need to diverge  if (!targetNode || targetNode === originalNode) {  if (typeof key === 'number') {  targetNode = originalNode ? [...originalNode] : [];  } else if (typeof key === 'string') {  targetNode = originalNode ? { ...originalNode } : {};  } else {  throw new Error(`Unknown path type ${JSON.stringify(key)} in path ${JSON.stringify(path)} at index ${i}`);  }   if (i === 0) {  // Make sure we have a reference to the new target. We can keep the  // reference here because 'target' is pointing as currentNode.data.  target = targetNode;  } else {  parentNode[path[i - 1]] = targetNode;  }  }   // Regardless, we keep walking deeper.  parentNode = targetNode;  targetNode = targetNode[key];  originalNode = originalNode && originalNode[key];  }   // Finally, set the value in our previously or newly cloned target.  parentNode[path[path.length - 1]] = value;   return target as TEntity; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/primitive.ts","isScalar","{  return value === null || typeof value !== 'object'; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/primitive.ts","isObject","{  return value !== null && typeof value === 'object' && !Array.isArray(value); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/primitive.ts","isObjectOrNull","{  return typeof value === 'object' && !Array.isArray(value); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/primitive.ts","isNil","{  return value === null || value === undefined || Number.isNaN(value); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/primitive.ts","isNumber","{  return typeof element === 'number' && !Number.isNaN(element); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/references.ts","removeNodeReference","{  const references = snapshot[direction];  if (!references) return true;   const fromIndex = getIndexOfGivenReference(references, id, path);  if (fromIndex < 0) return false;  references.splice(fromIndex, 1);   if (!references.length) {  snapshot[direction] = undefined;  }   return !references.length; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/references.ts","addNodeReference","{  let references = snapshot[direction];  if (!references) {  references = snapshot[direction] = [];  }   const idx = getIndexOfGivenReference(references, id, path);  if (idx === -1) {  references.push({ id, path });  return true;  }  return false; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/references.ts","hasNodeReference","{  const references = snapshot[type];  if (!references || getIndexOfGivenReference(references, id, path) === -1) return false;  return true; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/references.ts","getIndexOfGivenReference","{  return references.findIndex((reference) => {  return reference.id === id && isEqual(reference.path, path);  }); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/references.ts","isReferenceField","{  const references = snapshot['outbound'];  if (!references) return false;  const index = references.findIndex((reference) => {  return isEqual(reference.path, path);  });  return (index >= 0); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/tree.ts","walkOperation","{   // Perform the walk as a depth-first traversal; and unlike the payload walk,  // we don't bother tracking the path.  const stack = [new OperationWalkNode(rootOperation, result)];   while (stack.length) {  const { parsedOperation, parent } = stack.pop()!;  // We consider null nodes to be skippable (and satisfy the walk).  if (parent === null) continue;   // Fan-out for arrays.  if (Array.isArray(parent)) {  // Push in reverse purely for ergonomics: they'll be pulled off in order.  for (let i = parent.length - 1; i >= 0; i--) {  stack.push(new OperationWalkNode(parsedOperation, parent[i]));  }  continue;  }   const fields: string[] = [];  // TODO: Directives?  for (const fieldName in parsedOperation) {  fields.push(fieldName);  const nextParsedQuery = parsedOperation[fieldName].children;  if (nextParsedQuery) {  stack.push(new OperationWalkNode(nextParsedQuery, get(parent, fieldName)));  }  }   if (fields.length) {  const shouldStop = visitor(parent, fields);  if (shouldStop) return;  }  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/util/tree.ts","get","{  // Remember: arrays are typeof 'object', too.  return value !== null && typeof value === 'object' ? value[key] : undefined; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/errors.ts","prettyPath","{  return path.length ? path.join('.') : '[]'; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/nodes/clone.ts","cloneNodeSnapshot","{  const inbound = parent.inbound ? [...parent.inbound] : undefined;  const outbound = parent.outbound ? [...parent.outbound] : undefined;   if (parent instanceof EntitySnapshot) {  return new EntitySnapshot(parent.data, inbound, outbound);  } else if (parent instanceof ParameterizedValueSnapshot) {  return new ParameterizedValueSnapshot(parent.data, inbound, outbound);  } else {  throw new Error(`Unknown node type: ${Object.getPrototypeOf(parent).constructor.name}`);  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/extract.ts","extract","{  const result: Serializable.GraphSnapshot = {};  const entities = graphSnapshot._values;  // We don't need to check for hasOwnProperty because data._values is  // created with prototype of 'null'  for (const id in entities) {  const nodeSnapshot = entities[id];  const { outbound, inbound } = nodeSnapshot;   let type: Serializable.NodeSnapshotType;  if (nodeSnapshot instanceof EntitySnapshot) {  type = Serializable.NodeSnapshotType.EntitySnapshot;  } else if (nodeSnapshot instanceof ParameterizedValueSnapshot) {  type = Serializable.NodeSnapshotType.ParameterizedValueSnapshot;  } else {  throw new Error(`${nodeSnapshot.constructor.name} does not have corresponding enum value in Serializable.NodeSnapshotType`);  }   const serializedEntity: Serializable.NodeSnapshot = { type };   if (outbound) {  serializedEntity.outbound = outbound;  }   if (inbound) {  serializedEntity.inbound = inbound;  }   // Extract data value  const extractedData = extractSerializableData(graphSnapshot, nodeSnapshot);  if (extractedData !== undefined) {  if (cacheContext.tracer.warning) {  try {  if (!isSerializable(extractedData, /* allowUndefined */ true)) {  cacheContext.tracer.warning(`Data at entityID ${id} is unserializable`);  }  } catch (error) {  cacheContext.tracer.warning(`Data at entityID ${id} is unserializable because of stack overflow`);  cacheContext.tracer.warning(error);  }  }  serializedEntity.data = extractedData;  }   result[id] = serializedEntity;  }   return result; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/extract.ts","extractSerializableData","{  // If there is no outbound, then data is a value  // 'data' can also be undefined or null even though there exist an  // outbound reference (e.g referencing ParameterizedValueSnapshot).  // We can simply skip extraction of such data.  if (!nodeSnapshot.outbound || !nodeSnapshot.data) {  return nodeSnapshot.data;  }   // Type annotation is needed otherwise type of entity.data is not nullable  // and so does extractedData which will cause an error when we assing 'null'.  let extractedData: JsonValue | null = nodeSnapshot.data;   // Set all the outbound path (e.g reference) to undefined.  for (const outbound of nodeSnapshot.outbound) {  // Only reference to EntitySnapshot is recorded in the data property  // So we didn't end up set the value to be 'undefined' in the output  // in every case  if (graphSnapshot.getNodeSnapshot(outbound.id) instanceof EntitySnapshot) {  // we have to write out 'null' here to differentiate between  // data doesn't exist and data is a reference.  //  // In the case of parameterized field hanging off of a root  // the data at the ROOTQUERY node will be undefined with outbound  // reference to the parameterized node.  extractedData = lazyImmutableDeepSet(extractedData, nodeSnapshot.data, outbound.path, outbound.path.length === 0 ? null : undefined);  }  }   return extractedData; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/migrate.ts","migrateEntity","{   // Only if object and if valid migrationMap is provided  if (!isObject(snapshot.data) || !migrationMap) return snapshot;   let typeName = snapshot.data.__typename as string | undefined;  if (!typeName) typeName = 'Query';  if (!migrationMap[typeName]) return snapshot;  for (const field in migrationMap[typeName]) {  const fieldMigration = migrationMap[typeName][field];  if (!fieldMigration) continue;  // References work in very specific way in Hermes. If client tries  // to migrate them at will, bad things happnen. Let's not let them shoot  // themselves  if (isReferenceField(snapshot, [field])) {  throw new Error(`${typeName}.${field} is a reference field. Migration is not allowed`);  }  snapshot.data[field] = fieldMigration(snapshot.data[field]);  }   return snapshot; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/migrate.ts","migrate","{  if (migrationMap) {  const entities = cacheSnapshot.baseline._values;  for (const id in entities) {  const nodeSnapshot = entities[id];  if (nodeSnapshot instanceof EntitySnapshot) {  migrateEntity(nodeSnapshot, migrationMap);  }  }  }  return cacheSnapshot; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/restore.ts","restore","{  const { nodesMap, editedNodeIds } = createGraphSnapshotNodes(serializedState, cacheContext);  const graphSnapshot = new GraphSnapshot(nodesMap);   return {  cacheSnapshot: new CacheSnapshot(graphSnapshot, graphSnapshot, new OptimisticUpdateQueue()),  editedNodeIds,  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/restore.ts","createGraphSnapshotNodes","{  const nodesMap: NodeSnapshotMap = Object.create(null);  const editedNodeIds = new Set<NodeId>();   // Create entity nodes in the GraphSnapshot  for (const nodeId in serializedState) {  const { type, data, inbound, outbound } = serializedState[nodeId];   let nodeSnapshot;  switch (type) {  case Serializable.NodeSnapshotType.EntitySnapshot:  nodeSnapshot = new EntitySnapshot(data as JsonObject, inbound, outbound);  break;  case Serializable.NodeSnapshotType.ParameterizedValueSnapshot:  nodeSnapshot = new ParameterizedValueSnapshot(data as JsonValue, inbound, outbound);  break;  default:  throw new Error(`Invalid Serializable.NodeSnapshotType ${type} at ${nodeId}`);  }   nodesMap[nodeId] = nodeSnapshot!;  editedNodeIds.add(nodeId);  }   // Patch data property and reconstruct references  restoreEntityReferences(nodesMap, cacheContext);   return { nodesMap, editedNodeIds }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/restore.ts","restoreEntityReferences","{  const { entityTransformer, entityIdForValue } = cacheContext;   for (const nodeId in nodesMap) {  const { data, outbound } = nodesMap[nodeId];  if (entityTransformer && isObject(data) && entityIdForValue(data)) {  entityTransformer(data);  }   // If it doesn't have outbound then 'data' doesn't have any references  // If it is 'undefined' means that there is no data value  // in both cases, there is no need for modification.  if (!outbound || data === undefined) {  continue;  }   for (const { id: referenceId, path } of outbound) {  const referenceNode = nodesMap[referenceId];  if (referenceNode instanceof EntitySnapshot && data === null) {  // data is a reference.  nodesMap[nodeId].data = referenceNode.data;  } else if (referenceNode instanceof ParameterizedValueSnapshot) {  // This is specifically to handle a sparse array which happen  // when each element in the array reference data in a  // ParameterizedValueSnapshot.  // (see: parameterizedFields/nestedParameterizedReferenceInArray.ts)  // We only want to try walking if its data contains an array  const indexToArrayIndex = lodashFindIndex(path, isNumber);  if (indexToArrayIndex !== -1) {  tryRestoreSparseArray(data, path, 0);  }  } else if (Array.isArray(data) || isObject(data)) {  lodashSet(data, path, referenceNode.data);  }  }  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/restore.ts","tryRestoreSparseArray","{  if (data === undefined) {  // There should never be 'undefined'  throw new Error(`Unexpected 'undefined' in the path [${possibleSparseArrayPaths}] at index ${idx}`);  }   if (idx >= possibleSparseArrayPaths.length || data === null || isScalar(data)) {  return;  }   const prop = possibleSparseArrayPaths[idx];  if (Array.isArray(data) && typeof prop === 'number' && data[prop] === null) {  // truely make it sparse rather than just set 'undefined''  delete data[prop];  return;  }   tryRestoreSparseArray(data[prop], possibleSparseArrayPaths, idx + 1); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/prune.ts","prune","{  const queryResult = read(context, raw, snapshot);  const pruned = write(  context,  new GraphSnapshot(),  raw,  queryResult.result && queryResult.complete ? queryResult.result : {} as JsonObject  );  return {  snapshot: pruned.snapshot,  complete: queryResult.complete,  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/write.ts","write","{  let tracerContext;  if (context.tracer.writeStart) {  tracerContext = context.tracer.writeStart(raw, payload);  }   // We _could_ go purely functional with the editor, but it's honestly pretty  // convenient to follow the builder function instead - it'd end up passing  // around a context object anyway.  const editor = new SnapshotEditor(context, snapshot);  const { warnings } = editor.mergePayload(raw, payload);  const newSnapshot = editor.commit();   if (context.tracer.writeEnd) {  context.tracer.writeEnd(context.parseOperation(raw), { payload, newSnapshot, warnings }, tracerContext);  }   return newSnapshot; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/operations/SnapshotEditor.ts","nodeIdForParameterizedValue","{  return `${containerId}❖${JSON.stringify(path)}❖${JSON.stringify(args)}`; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","parseQuery","{  const variables = new Set<string>();  const parsedQuery = _buildNodeMap(variables, context, fragments, selectionSet);  if (!parsedQuery) {  throw new Error(`Parsed a query, but found no fields present; it may use unsupported GraphQL features`);  }   return { parsedQuery, variables }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_buildNodeMap","{  if (!selectionSet) return undefined;   const nodeMap = Object.create(null);  for (const selection of selectionSet.selections) {  if (selection.kind === 'Field') {  // The name of the field (as defined by the query).  const name = selection.alias ? selection.alias.value : selection.name.value;  const children = _buildNodeMap(variables, context, fragments, selection.selectionSet, [...path, name]);   let args, schemaName;  // fields marked as @static are treated as if they are a static field in  // the schema. E.g. parameters are ignored, and an alias is considered  // to be truth.  if (!fieldHasStaticDirective(selection)) {  args = _buildFieldArgs(variables, selection.arguments);  schemaName = selection.alias ? selection.name.value : undefined;  }   const hasParameterizedChildren = areChildrenDynamic(children);   const node = new ParsedQueryNode(children, schemaName, args, hasParameterizedChildren);  nodeMap[name] = _mergeNodes([...path, name], node, nodeMap[name]);   } else if (selection.kind === 'FragmentSpread') {  const fragment = fragments[selection.name.value];  if (!fragment) {  throw new Error(`Expected fragment ${selection.name.value} to be defined`);  }   const fragmentMap = _buildNodeMap(variables, context, fragments, fragment.selectionSet, path);  if (fragmentMap) {  for (const name in fragmentMap) {  nodeMap[name] = _mergeNodes([...path, name], fragmentMap[name], nodeMap[name]);  }  }   } else if (context.tracer.warning) {  context.tracer.warning(`${selection.kind} selections are not supported; query may misbehave`);  }   _collectDirectiveVariables(variables, selection);  }   return Object.keys(nodeMap).length ? nodeMap : undefined; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","areChildrenDynamic","{  if (!children) return undefined;  for (const name in children) {  const child = children[name];  if (child.hasParameterizedChildren) return true;  if (child.args) return true;  if (child.schemaName) return true; // Aliases are dynamic at read time.  }  return undefined; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_buildFieldArgs","{  if (!argumentsNode) return undefined;   const args = {};  for (const arg of argumentsNode) {  // Mapped name of argument to it JS value  args[arg.name.value] = _valueFromNode(variables, arg.value);  }   return Object.keys(args).length ? args : undefined; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_valueFromNode","{  return valueFromNode(node, ({ name: { value } }) => {  variables.add(value);  return new VariableArgument(value);  }); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_collectDirectiveVariables","{  const { directives } = node;  if (!directives) return;   for (const directive of directives) {  if (!directive.arguments) continue;   for (const argument of directive.arguments) {  valueFromNode(argument.value, ({ name: { value } }) => {  variables.add(value);  });  }  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_mergeNodes","{  if (!source) return target;  if (!isEqual(target.args, source.args)) {  throw new ConflictingFieldsError(`parameterization mismatch`, path, [target, source]);  }  if (target.schemaName !== source.schemaName) {  throw new ConflictingFieldsError(`alias mismatch`, path, [target, source]);  }  if (!source.children) return target;   if (!target.children) {  target.children = source.children;  } else {  for (const name in source.children) {  target.children[name] = _mergeNodes([...path, name], source.children[name], target.children[name]);  }  }   if (source.hasParameterizedChildren && !target.hasParameterizedChildren) {  target.hasParameterizedChildren = true;  }   return target; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","expandVariables","{  return _expandVariables(parsed, variables)!; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_expandVariables","{  if (!parsed) return undefined;   const newMap = {};  for (const key in parsed) {  const node = parsed[key];  if (node.args || node.hasParameterizedChildren) {  newMap[key] = new ParsedQueryNode(  _expandVariables(node.children, variables),  node.schemaName,  expandFieldArguments(node.args, variables),  node.hasParameterizedChildren,  );  // No variables to substitute for this subtree.  } else {  newMap[key] = node;  }  }   return newMap; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","expandFieldArguments","{  return args ? _expandArgument(args, variables) as JsonObject : undefined; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/ParsedQueryNode.ts","_expandArgument","{  if (arg instanceof VariableArgument) {  if (!variables || !(arg.name in variables)) {  throw new Error(`Expected variable $${arg.name} to exist for query`);  }  return variables[arg.name];  } else if (Array.isArray(arg)) {  return arg.map(v => _expandArgument(v, variables));  } else if (isObject(arg)) {  const expanded = {};  for (const key in arg) {  expanded[key] = _expandArgument(arg[key], variables);  }  return expanded;  } else {  // TS isn't inferring that arg cannot contain any VariableArgument values.  return arg as JsonValue;  } }"
"../test-repos/convoyinc_apollo-cache-hermes/src/apollo/Transaction.ts","getOriginalFieldArguments","{  // Split `${containerId}❖${JSON.stringify(path)}❖${JSON.stringify(args)}`  const idComponents = id.split('❖');  if (idComponents.length < 3) {  return undefined;  }  return JSON.parse(idComponents[2]); }"
"../test-repos/convoyinc_apollo-cache-hermes/src/apollo/util.ts","buildRawOperationFromQuery","{  return {  rootId: rootId || StaticNodeId.QueryRoot,  document,  variables,  }; }"
"../test-repos/convoyinc_apollo-cache-hermes/src/apollo/util.ts","buildRawOperationFromFragment","{  return {  rootId,  document: getFragmentQueryDocument(fragmentDocument, fragmentName),  variables,  fragmentName,  fromFragmentDocument: true,  }; }"
"../test-repos/dixso_custombox/src/custombox.spec.ts","hasElement","{  return document.body.contains(document.querySelector(element)); }"
"../test-repos/dixso_custombox/src/custombox.spec.ts","getAfterEach","{  for (let i = 1; i < 3; i++) {  let elem = document.getElementById(`foo-${i}`);  elem.parentNode.removeChild(elem);  }   // custombox-content  let contents = document.querySelectorAll('.custombox-content');  for (let i = 0, t = contents.length; i < t; i++) {  contents[i].parentNode.removeChild(contents[i]);  }   // custombox-overlay  let overlays = document.querySelectorAll('.custombox-overlay');  for (let i = 0, t = overlays.length; i < t; i++) {  overlays[i].parentNode.removeChild(overlays[i]);  }   // custombox-loader  let loaders = document.querySelectorAll('.custombox-loader');  for (let i = 0, t = loaders.length; i < t; i++) {  loaders[i].parentNode.removeChild(loaders[i]);  }   // custombox-reference  let reference = document.querySelectorAll('.custombox-reference');  for (let i = 0, t = reference.length; i < t; i++) {  reference[i].parentNode.removeChild(reference[i]);  } }"
"../test-repos/dobjs_dob/tests/util.test.ts","immediate","{  if (time) {  return new Promise(resolve => setTimeout(() => {  fn()  resolve()  }, time));  }   return Promise.resolve().then(() => {  fn()  }) }"
"../test-repos/dobjs_dob/tests/event.test.ts","changeValue","{  count += changedValue  }"
"../test-repos/dobjs_dob/tests/event.test.ts","changeValue","{  count += changedValue  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","getCounter","{  return dynamicObj.counter  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","testObserve","{  data = dynamicObj.prop  numOfRuns++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","testObserve","{  data = dynamicObj.prop1 + dynamicObj.prop2  numOfRuns++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","test1","{  dynamicObj1.prop = dynamicObj2.prop  numOfRuns1++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","test2","{  dynamicObj2.prop = dynamicObj1.prop  numOfRuns2++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","testObserve","{  data = dynamicObj.prop  numOfRuns++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","testObserve","{  data = dynamicObj.prop  numOfRuns++  }"
"../test-repos/dobjs_dob/tests/observer.test.ts","runSomeThing","{  // use b  // tslint:disable-next-line:no-unused-expression  dynamicObj.b  }"
"../test-repos/dobjs_dob/demos/atom/computed-async.ts","isPromiseLike","{  return result && typeof (result as any).then === 'function'; }"
"../test-repos/dobjs_dob/demos/atom/computed-async.ts","computedAsync","no body"
"../test-repos/dobjs_dob/demos/atom/computed-async.ts","computedAsync","no body"
"../test-repos/dobjs_dob/demos/atom/computed-async.ts","computedAsync","{  if (arguments.length === 1) {  return new ComputedAsync<T>(init as IComputedAsyncOptions<T>);  }   return new ComputedAsync<T>({  init: init as T,  fetch: fetch!,  delay  }); }"
"../test-repos/dobjs_dob/demos/async/index.ts","waitOneMinute","{  return new Promise(resolve => {  setTimeout(resolve, 1000)  }) }"
"../test-repos/dobjs_dob/src/built-ins/weak-map.ts","shim","{  target.$raw = {}   for (const method of all) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.$raw[method] = function () {  native[method].apply(target, arguments)  }  }   for (const getter of getters) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[getter] = function (key: string) {  let value = native[getter].apply(this, arguments)   globalState.event.emit('get', { target, key: null, value })   value = proxyValue(this, key, value)   bindCurrentReaction(this, key)   return value  }  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.set = function (key: string, value: any) {  const oldValue = this.get(key)  const result = native.set.apply(this, arguments)   globalState.event.emit('set', { target, key, oldValue, value })   if (oldValue !== value) {  queueRunReactions(this, key)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.delete = function (key: string) {  const has = this.has(key)  const result = native.delete.apply(this, arguments)   globalState.event.emit('deleteProperty', { target, key })   if (has) {  queueRunReactions(this, key)  }  return result  }   return target }"
"../test-repos/dobjs_dob/src/built-ins/set.ts","shim","{  target.$raw = {}   for (const method of all) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.$raw[method] = function () {  native[method].apply(target, arguments)  }  }   for (const getter of getters) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[getter] = function (value: string) {  let result = native[getter].apply(this, arguments)   globalState.event.emit('get', { target, key: null, value: result })   result = proxyValue(this, value, result)   bindCurrentReaction(this, value)   return result  }  }   for (const iterator of iterators) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[iterator] = function () {  bindCurrentReaction(this, masterValue)  return native[iterator].apply(this, arguments)  }  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.add = function (value: string) {  const has = this.has(value)  const result = native.add.apply(this, arguments)   globalState.event.emit('set', { target, key: null, value, oldValue: null })   if (!has) {  queueRunReactions(this, value)  queueRunReactions(this, masterValue)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.delete = function (value: string) {  const has = this.has(value)  const result = native.delete.apply(this, arguments)   globalState.event.emit('deleteProperty', { target, key: null })   if (has) {  queueRunReactions(this, value)  queueRunReactions(this, masterValue)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.clear = function () {  const size = this.size  const result = native.clear.apply(this, arguments)  if (size) {  queueRunReactions(this, masterValue)  }  return result  }   Object.defineProperty(target, 'size', {  get: function get() {  const proto = Object.getPrototypeOf(this)  const size = Reflect.get(proto, 'size', this)  bindCurrentReaction(this, masterValue)  return size  }  })   return target }"
"../test-repos/dobjs_dob/src/built-ins/weak-set.ts","shim","{  target.$raw = {}   for (const method of all) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.$raw[method] = function () {  native[method].apply(target, arguments)  }  }   for (const getter of getters) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[getter] = function (value: string) {  let result = native[getter].apply(this, arguments)   globalState.event.emit('get', { target, key: null, value: result })   result = proxyValue(this, value, result)   bindCurrentReaction(this, value)   return result  }  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.add = function (value: string) {  const has = this.has(value)  const result = native.add.apply(this, arguments)   globalState.event.emit('set', { target, key: null, value, oldValue: null })   if (!has) {  queueRunReactions(this, value)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.delete = function (value: string) {  const has = this.has(value)  const result = native.delete.apply(this, arguments)   globalState.event.emit('deleteProperty', { target, key: null })   if (has) {  queueRunReactions(this, value)  }  return result  }   return target }"
"../test-repos/dobjs_dob/src/built-ins/map.ts","shim","{  target.$raw = {}   for (const method of all) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.$raw[method] = function () {  native[method].apply(target, arguments)  }  }   for (const getter of getters) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[getter] = function (key: string) {  let value = native[getter].apply(this, arguments)   globalState.event.emit('get', { target, key, value })   value = proxyValue(this, key, value)   bindCurrentReaction(this, key)   return value  }  }   for (const iterator of iterators) {  // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target[iterator] = function () {  bindCurrentReaction(this, masterKey)  return native[iterator].apply(this, arguments)  }  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.set = function (key: string, value: any) {  const oldValue = this.get(key)  const result = native.set.apply(this, arguments)   globalState.event.emit('set', { target, key, oldValue, value })   if (oldValue !== value) {  queueRunReactions(this, key)  queueRunReactions(this, masterKey)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.delete = function (key: string) {  const has = this.has(key)  const result = native.delete.apply(this, arguments)   globalState.event.emit('deleteProperty', { target, key })   if (has) {  queueRunReactions(this, key)  queueRunReactions(this, masterKey)  }  return result  }   // tslint:disable-next-line:space-before-function-paren only-arrow-functions  target.clear = function () {  const size = this.size  const result = native.clear.apply(this, arguments)  if (size) {  queueRunReactions(this, masterKey)  }  return result  }   Object.defineProperty(target, 'size', {  get: function get() {  const proto = Object.getPrototypeOf(this)  const size = Reflect.get(proto, 'size', this)  bindCurrentReaction(this, masterKey)  return size  }  })   return target }"
"../test-repos/dobjs_dob/src/debug.ts","require","no body"
"../test-repos/dobjs_dob/src/debug.ts","reportChange","{  if (globalState.currentDebugOutputAction) {  globalState!.currentDebugOutputAction!.changeList!.push(change)  } else { // Changes out of Action.  globalState.event.emit('debug', {  id: createUniqueId(),  name: null,  changeList: [change],  type: 'isolated'  })  } }"
"../test-repos/dobjs_dob/src/debug.ts","getCallStack","{  const callStack: PropertyKey[] = []   if (!globalState.parentInfo.has(target)) { // Hit top.  callStack.unshift(target.constructor.name)  } else {  let currentTarget: object = target  let runCount = 0   while (globalState.parentInfo.has(currentTarget)) {  const parentInfo = globalState.parentInfo.get(currentTarget)   // add key to call stack  callStack.unshift(parentInfo!.key)   // If has no parent's parent, add parent's name to call stack.  if (!globalState.parentInfo.has(parentInfo!.parent)) {  callStack.unshift(parentInfo!.parent.constructor.name)  }   currentTarget = parentInfo!.parent   runCount++  if (runCount >= globalState.getCallstackMaxCount) {  break  }  }  }   return callStack }"
"../test-repos/dobjs_dob/src/utils.ts","isPrimitive","{  if (value === null || value === undefined) {  return true  }   if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value instanceof Date) {  return true  }   return false }"
"../test-repos/dobjs_dob/src/utils.ts","inAction","{  return globalState.batchDeep !== 0 }"
"../test-repos/dobjs_dob/src/utils.ts","inTrack","{  return !!globalState.currentReaction }"
"../test-repos/dobjs_dob/src/utils.ts","getBinder","{  let keysForObject = globalState.objectReactionBindings.get(object)   if (!keysForObject) {  keysForObject = new Map()  globalState.objectReactionBindings.set(object, keysForObject)  }   let reactionsForKey = keysForObject.get(key)   if (!reactionsForKey) {  reactionsForKey = new Set()  keysForObject.set(key, reactionsForKey)  }   return {  binder: keysForObject,  keyBinder: reactionsForKey,  } }"
"../test-repos/dobjs_dob/src/utils.ts","startDebug","{  globalState.useDebug = true }"
"../test-repos/dobjs_dob/src/utils.ts","stopDebug","{  globalState.useDebug = false }"
"../test-repos/dobjs_dob/src/utils.ts","useStrict","{  globalState.strictMode = true }"
"../test-repos/dobjs_dob/src/utils.ts","cancelStrict","{  globalState.strictMode = false }"
"../test-repos/dobjs_dob/src/utils.ts","createUniqueId","{  return globalState.uniqueIdCounter++ }"
"../test-repos/dobjs_dob/src/observer.ts","createObservableObject","{  if (isPrimitive(obj)) {  throw TypeError(`dob not support ${obj}, because it is a basic type.`)  }   if (globalState.proxies.has(obj)) {  return globalState.proxies.get(obj)  }   // Proxy inert packaging.  return toObservable(obj) }"
"../test-repos/dobjs_dob/src/observer.ts","createObservableObjectDecorator","{  function wrap(...args: any[]) {  return createObservableObject(new target(...args))  }  return wrap as any }"
"../test-repos/dobjs_dob/src/observer.ts","wrap","{  return createObservableObject(new target(...args))  }"
"../test-repos/dobjs_dob/src/observer.ts","toObservable","{  if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -1) {  // Ignore observable  return obj  }   let dynamicObject: T   const builtIn = builtIns.get(obj.constructor)  if (typeof builtIn === 'function' || typeof builtIn === 'object') {  // support: map weakMap set weakSet.  dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue)  } else if (!builtIn) {  dynamicObject = new Proxy(obj, {  get(target, key, receiver) {  let value = Reflect.get(target, key, receiver)   // Get origin object.  if (key === '$raw') {  return target  }   // Getter event.  globalState.event.emit('get', { target, key, value })   bindCurrentReaction(target, key)   value = getProxyValue(target, key, value)   return value  },   set(target, key, value, receiver) {  const oldValue = Reflect.get(target, key, receiver)   // If the new value is an object, the original object is preferentially taken.  if (typeof value === 'object' && value) {  value = value.$raw || value  }   globalState.event.emit('set', { target, key, value, oldValue })   const result = Reflect.set(target, key, value, receiver)   // If the length of attribute changed, or the new value is different from the old value, trigger observer queue task.  // This step should be done after `Reflect.set` to ensure that the trigger is using a new value.  if (key === 'length' || value !== oldValue) {  queueRunReactions<T>(target, key)  }   return result  },   deleteProperty(target, key) {  const hasKey = Reflect.has(target, key)   globalState.event.emit('deleteProperty', { target, key })   const result = Reflect.deleteProperty(target, key)   if (hasKey) {  queueRunReactions(target, key)  }   return result  }  })  } else {  dynamicObject = obj  }   globalState.proxies.set(obj, dynamicObject)  globalState.proxies.set(dynamicObject, dynamicObject)  globalState.originObjects.set(dynamicObject, obj)   globalState.objectReactionBindings.set(obj, new Map())   return dynamicObject }"
"../test-repos/dobjs_dob/src/observer.ts","getProxyValue","{  // If the value is a HTMLElement object, it returns directly to the original object, because the original object cannot be encapsulated.  if (typeof window !== 'undefined' && value instanceof HTMLElement) {  return value  }   // If the value is an object, the proxy object is taken priority.  const resultIsObject = typeof value === 'object' && value  const existProxy = resultIsObject && globalState.proxies.get(value)   if (resultIsObject) {  return existProxy || toObservable(value)  }   return value }"
"../test-repos/dobjs_dob/src/observer.ts","queueRunReactions","{  // If in strict mode, and not in the batch, throw error.  if (globalState.strictMode && globalState.batchDeep === 0) {  throw Error('You are not allowed to modify observable value out of Action.')  }   const { keyBinder } = getBinder(target, key)   Array.from(keyBinder).forEach(reaction => {  if (inAction()) {  globalState.pendingReactions.add(reaction)  } else {  // Not in Action, added to the queue if the queue already has a value, or directly execute if the queue has no value.  if (globalState.pendingReactions.size === 0) {  runReaction(reaction)  } else {  globalState.pendingReactions.add(reaction)  runPendingReactions()  }  }  }) }"
"../test-repos/dobjs_dob/src/observer.ts","runReaction","{  reaction.run() }"
"../test-repos/dobjs_dob/src/observer.ts","runPendingReactions","{  // The number of queue executions.  let currentRunCount = 0   globalState.pendingReactions.forEach(observer => {  currentRunCount++   if (currentRunCount >= MAX_RUN_COUNT) {  globalState.pendingReactions.clear()  return  }   runReaction(observer)  })   // Clear pending reactions.  globalState.pendingReactions.clear() }"
"../test-repos/dobjs_dob/src/observer.ts","bindCurrentReaction","{  // Add listener to this key, which not be tracked in the runInAction  // InBatch as long as non zero, that runInAction is over  if (!globalState.currentReaction || inAction()) {  return  }   const { keyBinder } = getBinder(object, key)   // If this key is not bound with the current reaction, bind it.  if (!keyBinder.has(globalState.currentReaction)) {  keyBinder.add(globalState.currentReaction)  globalState.currentReaction.addBinder(keyBinder)  } }"
"../test-repos/dobjs_dob/src/observer.ts","isObservable","{  return (globalState.proxies.get(obj) === obj) }"
"../test-repos/dobjs_dob/src/observer.ts","observe","{  const reaction = new Reaction('observe', () => {  reaction.track(callback)  }, delay)   // Run in initialization  if (inAction()) {  // If in the action, directly added to the queue, such as the implementation of the action will automatically execute this queue.  globalState.pendingReactions.add(reaction)  } else {  reaction.run()  }   return {  unobserve: () => {  reaction.dispose()  }  } }"
"../test-repos/dobjs_dob/src/observer.ts","startBatch","{  if (globalState.batchDeep === 0) {  // If starting a new queue from deep 0, clear the original queue.  globalState.pendingReactions = new Set()  }   globalState.batchDeep++   globalState.event.emit('startBatch', null) }"
"../test-repos/dobjs_dob/src/observer.ts","endBatch","{  if (--globalState.batchDeep === 0) {  runPendingReactions()  }   globalState.event.emit('endBatch', null) }"
"../test-repos/dobjs_dob/src/observer.ts","Action","no body"
"../test-repos/dobjs_dob/src/observer.ts","Action","no body"
"../test-repos/dobjs_dob/src/observer.ts","Action","{  if (arg2 === undefined) {  return runInAction.call(null, arg1, arg1.name)  }  return actionDecorator.call(null, arg1, arg1.constructor.name + '.' + arg2, arg3) }"
"../test-repos/dobjs_dob/src/observer.ts","actionDecorator","{  const func = descriptor.value  return {  get() {  return (...args: any[]) => {  return runInAction(func.bind(this, ...args), propertyKey)  }  }  } }"
"../test-repos/dobjs_dob/src/observer.ts","runInAction","{  globalState.event.emit('runInAction', debugName)   startBatch()   try {  return fn()  } finally {  endBatch()  } }"
"../test-repos/dobjs_dob/src/observer.ts","observable","{  if (typeof target === 'function') { // 挂在 class 的 decorator  return createObservableObjectDecorator(target)  } else {  return createObservableObject(target as any) as T  } }"
"../test-repos/dobjs_dob/src/observer.ts","Static","{  Object.defineProperty(obj, globalState.ignoreDynamicSymbol, {  value: true  })  return obj }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-generators/src/get-generator.ts","getGeneratorConfig","{  return definitions[name]; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/test-matchers/custom-matchers.ts","toBeSimilarStringTo","{  const strippedA = oneLine`${received}`;  const strippedB = oneLine`${argument}`;   if (strippedA === strippedB) {  return {  message: () => ( `expected ${received}  not to be similar (strip-indent) string to  ${argument}`  ),  pass: true,  };  } else {  return {  message: () => ( `expected ${received}  to be similar (strip-indent) string to  ${argument}`  ),  pass: false,  };  } }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/prepare-documents-only.ts","prepareSchemaForDocumentsOnly","{  let copy = Object.assign({}, templateContext);   copy.interfaces = [];  copy.unions = [];  copy.types = [];  copy.hasInterfaces = false;  copy.hasUnions = false;  copy.hasTypes = false;   return copy; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-single-file.ts","generateSingleFile","{  debugLog(`[generateSingleFile] Compiling single file to: ${config.outFile}`);   return [  {  filename: config.outFile,  content: compiledIndexTemplate({  config: config.config,  currentTime: moment().format(),  ...(!executionSettings.generateSchema) ? prepareSchemaForDocumentsOnly(templateContext) : templateContext,  operations: documents.operations,  fragments: documents.fragments,  hasFragments: documents.hasFragments,  hasOperations: documents.hasOperations,  }),  },  ]; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleSchema","{  debugLog(`[handleSchema] called`);   return [{  filename: prefixAndPath + '.' + (fileExtension || ''),  content: compiledTemplate({  config: extraConfig,  ...schemaContext  }),  }]; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleAll","{  debugLog(`[handleAll] called`);   return [{  filename: prefixAndPath + '.' + (fileExtension || ''),  content: compiledTemplate({  ...schemaContext,  config: extraConfig,  operations: documents.operations,  fragments: documents.fragments,  hasFragments: documents.hasFragments,  hasOperations: documents.hasOperations,  }),  }]; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleDocuments","{  debugLog(`[handleDocuments] called`);   return [{  filename: prefixAndPath + '.' + (fileExtension || ''),  content: compiledTemplate({  config: extraConfig,  operations: documents.operations,  fragments: documents.fragments,  hasFragments: documents.hasFragments,  hasOperations: documents.hasOperations,  }),  }]; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleType","{  debugLog(`[handleType] called`);   return schemaContext.types.map((type: Type) => ({  filename: prefixAndPath + sanitizeFilename(type.name, 'type') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...type,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleInputType","{  debugLog(`[handleInputType] called`);   return schemaContext.inputTypes.map((type: Type) => ({  filename: prefixAndPath + sanitizeFilename(type.name, 'input-type') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...type,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleUnion","{  debugLog(`[handleUnion] called`);   return schemaContext.unions.map((union: Union) => ({  filename: prefixAndPath + sanitizeFilename(union.name, 'union') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...union,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleEnum","{  debugLog(`[handleEnum] called`);   return schemaContext.enums.map((en: Enum) => ({  filename: prefixAndPath + sanitizeFilename(en.name, 'enum') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...en,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleScalar","{  debugLog(`[handleScalar] called`);   return schemaContext.scalars.map((scalar: Scalar) => ({  filename: prefixAndPath + sanitizeFilename(scalar.name, 'scalar') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...scalar,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleInterface","{  debugLog(`[handleInterface] called`);   return schemaContext.interfaces.map((inf: Interface) => ({  filename: prefixAndPath + sanitizeFilename(inf.name, 'interface') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...inf,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleOperation","{  debugLog(`[handleOperation] called`);   return documents.operations.map((operation: Operation) => ({  filename: prefixAndPath + sanitizeFilename(operation.name, operation.operationType) + '.' + (fileExtension || ''),  content: compiledTemplate({  ...operation,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","handleFragment","{  debugLog(`[handleFragment] called`);   return documents.fragments.map((fragment: Fragment) => ({  filename: prefixAndPath + sanitizeFilename(fragment.name, 'fragment') + '.' + (fileExtension || ''),  content: compiledTemplate({  ...fragment,  config: extraConfig,  }),  })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","parseTemplateName","{  let splitted = (path.basename(templateName)).split('.');  let hasPrefix = true;   if (splitted.length === 3) {  splitted.unshift('');  hasPrefix = false;  }   if (splitted.length > 4 && templateName.includes('/')) {  splitted = [  splitted.slice(0, splitted.length - 3).join('.'),  splitted[2],  splitted[3],  splitted[4],  ];  }   const templateExtension = splitted[3];   if (templateExtension && ALLOWED_CUSTOM_TEMPLATE_EXT.includes(templateExtension)) {  const compilationContext = splitted[2];  const prefix = splitted[0];  const fileExtension = splitted[1];  const handler = handlersMap[compilationContext];   if (handler) {  const pref = path.resolve(path.dirname(templateName) + '/', prefix);   return {  prefix: hasPrefix ? ['all', 'documents', 'schema'].includes(compilationContext) ? pref : pref + '.' : pref + '/',  handler,  fileExtension,  };  }  }   return null; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/generate-multiple-files.ts","generateMultipleFiles","{  debugLog(`[generateMultipleFiles] Compiling multiple files...`);  const result: FileOutput[] = [];  const schemaContext = (!executionSettings.generateSchema) ? prepareSchemaForDocumentsOnly(templateContext) : templateContext;   Object.keys(templates).forEach(templateName => {  debugLog(`[generateMultipleFiles] Checking template: ${templateName}`);   const templateFn = templates[templateName];   if (handlersMap[templateName]) {  debugLog(`[generateMultipleFiles] Using simple handle of type: ${templateName}`);   const handler = handlersMap[templateName];   result.push(...handler(templateFn, schemaContext, documents, {  ...(config.config),  currentTime: moment().format(),  }, config.filesExtension));  } else {  const parsedTemplateName = parseTemplateName(templateName);  debugLog(`[generateMultipleFiles] Using custom template handlers, parsed template name result: `, parsedTemplateName);   if (parsedTemplateName !== null) {  result.push(...parsedTemplateName.handler(templateFn, schemaContext, documents, {  ...config.config,  currentTime: moment().format(),  }, parsedTemplateName.fileExtension, parsedTemplateName.prefix));  }  }  });   return result; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/flatten-types.ts","buildModelFromField","{  const modelName = handleNameDuplications(pascalCase(field.name), result);   return {  schemaBaseType: field.type,  modelType: modelName,  fields: field.fields,  fragmentsSpread: field.fragmentsSpread,  inlineFragments: field.inlineFragments,  hasFields: field.hasFields,  hasFragmentsSpread: field.hasFragmentsSpread,  hasInlineFragments: field.hasInlineFragments,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/flatten-types.ts","buildModelFromInlineFragment","{  const modelName = handleNameDuplications(pascalCase(fragment.onType) + 'InlineFragment', result);   return {  schemaBaseType: fragment.onType,  modelType: modelName,  fields: fragment.fields,  fragmentsSpread: fragment.fragmentsSpread,  inlineFragments: fragment.inlineFragments,  hasFields: fragment.hasFields,  hasFragmentsSpread: fragment.hasFragmentsSpread,  hasInlineFragments: fragment.hasInlineFragments,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/flatten-types.ts","flattenSelectionSet","{  selectionSet.forEach((item: SelectionSetItem) => {  if (isFieldNode(item)) {  if (item.selectionSet.length > 0) {  const model = buildModelFromField(item, result);  item.type = model.modelType;  result.push(model);   flattenSelectionSet(item.selectionSet, result);  }  } else if (isInlineFragmentNode(item)) {  const model = buildModelFromInlineFragment(item, result);  item.onType = model.modelType;  result.push(model);   flattenSelectionSet(item.selectionSet, result);  }  });   return result; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/flatten-types.ts","flattenTypes","{  return {  operations: document.operations.map<FlattenOperation>((operation: Operation): FlattenOperation => {  return {  isFlatten: true,  ...operation,  innerModels: flattenSelectionSet(operation.selectionSet),  } as FlattenOperation;  }),  fragments: document.fragments.map<FlattenFragment>((fragment: Fragment): FlattenFragment => {  return {  isFlatten: true,  ...fragment,  innerModels: flattenSelectionSet(fragment.selectionSet),  } as FlattenFragment;  }),  hasOperations: document.hasOperations,  hasFragments: document.hasFragments,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/field-type-to-string.ts","getFieldTypeAsString","{  if (field.isEnum) {  return 'enum';  } else if (field.isType) {  return 'type';  } else if (field.isInputType) {  return 'input-type';  } else if (field.isScalar) {  return 'scalar';  } else if (field.isInterface) {  return 'interface';  } else if (field.isUnion) {  return 'union';  } else {  return '';  } }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/compile.ts","compileTemplate","{  if (!config) {  throw new Error(`compileTemplate requires a valid GeneratorConfig object!`);  }   debugLog(`[compileTemplate] starting to compile template with input type = ${config.inputType}`);  debugLog(`[compileTemplate] settings = `, settings);   initHelpers(config, templateContext);  const executionSettings = Object.assign(DEFAULT_SETTINGS, settings);  const templates = config.templates;   Object.keys(templates).forEach((templateName: string) => {  debugLog(`[compileTemplate] register partial template ${templateName}`);   registerPartial(templateName, templates[templateName]);  });   let mergedDocuments: Document;   if (!executionSettings.generateDocuments) {  debugLog(`[compileTemplate] generateDocuments is false, ignoring documents...`);   mergedDocuments = {  fragments: [],  operations: [],  hasFragments: false,  hasOperations: false,  };  } else {  mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {  const opArr = [...previousValue.operations, ...item.operations] as Operation[];  const frArr = [...previousValue.fragments, ...item.fragments] as Fragment[];   return {  operations: opArr,  fragments: frArr,  hasFragments: frArr.length > 0,  hasOperations: opArr.length > 0,  };  }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);   debugLog(  `[compileTemplate] all documents merged into single document, total of ${mergedDocuments.operations.length} operations and ${mergedDocuments.fragments.length} fragments`  );   if (config.flattenTypes) {  debugLog(`[compileTemplate] flattenTypes is true, flattening all selection sets from all documents...`);   mergedDocuments = flattenTypes(mergedDocuments);  }  }   if (config.inputType === EInputType.SINGLE_FILE) {  if (!templates['index']) {  throw new Error(`Template 'index' is required when using inputType = SINGLE_FILE!`);  }   if (!config.outFile) {  throw new Error('Config outFile is required when using inputType = SINGLE_FILE!');  }   debugLog(`[compileTemplate] Executing generateSingleFile...`);   return generateSingleFile(  compile(cleanTemplateComments(templates['index'])),  executionSettings,  config,  templateContext,  mergedDocuments,  );  } else if (config.inputType === EInputType.MULTIPLE_FILES || config.inputType === EInputType.PROJECT) {  if (config.inputType === EInputType.MULTIPLE_FILES) {  if (!config.filesExtension) {  throw new Error('Config filesExtension is required when using inputType = MULTIPLE_FILES!');  }  }   debugLog(`[compileTemplate] Executing generateMultipleFiles...`);   const compiledTemplates = Object.keys(templates).map(templateName => {  debugLog(`[compileTemplate] Compiling template: ${templateName}...`);  const compiledTemplate = compile(cleanTemplateComments(templates[templateName], templateName));   return {  key: templateName,  value: compiledTemplate,  };  }).reduce((prev, item) => {  prev[item.key] = item.value;   return prev;  }, {}) as { [name: string]: Function[] };   debugLog(`[compileTemplate] Templates names: `, Object.keys(compiledTemplates));   return generateMultipleFiles(  compiledTemplates,  executionSettings,  config,  templateContext,  mergedDocuments,  );  } else {  throw new Error(`Invalid inputType specified: ${config.inputType}!`);  } }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/sanitizie-filename.ts","sanitizeFilename","{  const cleanName = name.replace(/[^a-z0-9]/gi, '_').toLowerCase();   return cleanName === '' ? cleanName : cleanName + '.' + graphQlType; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-compiler/src/clean-template.ts","cleanTemplateComments","{  debugLog(`[cleanTemplateComments] called, looking for magic comments in ${debugFilename}...`);   if (template.match(/\/\*\s*gqlgen/ig)) {  debugLog(`[cleanTemplateComments] Found magic comment 'gqlgen' in template ${debugFilename}...`, template);   const result = template  .replace(/.*({{.*}})/ig, (all, group) => {   if (all.toLowerCase().includes('gqlgen')) {  return all;  }   return all.replace(/{{/g, '\\{{');  })  .replace(/\/\*\s*gqlgen\s*(.*?)\s*\*\//gi, (all, group) => group ? group : all);   debugLog(`[cleanTemplateComments] template ${debugFilename} modified, result is: `, template);   return result;  }   debugLog(`[cleanTemplateComments] ${debugFilename} does not contains any magic comments, skipping...`);   return template; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-cli/src/cli.ts","collect","{  memo.push(val);   return memo; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-cli/src/loaders/templates-scanner.ts","scanForTemplatesInPath","{  const absolutePath = path.resolve(process.cwd(), dirPath);  const globPattern = `${absolutePath}/**/*.@(${fileExtensions.join('|')})`;  debugLog(`[scanForTemplatesInPath] Scanning for templates using glob pattern: ${globPattern}`);   const results = glob.sync(globPattern);   debugLog(`[scanForTemplatesInPath] Got results from glob: `, results);   return results.reduce((prev, filePath) => {  prev[filePath] = fs.readFileSync(filePath).toString();   return prev;  }, {}); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/tests/resolve-type-indicators.spec.ts","parseAndBuildSchema","{  const schema = buildASTSchema(parse(`  type Query {  test: Int  }  ${str}  `));   return schema.getTypeMap()[typeName] as T;  }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/tests/transform-fields.spec.ts","parseAndBuildSchema","{  return buildASTSchema(parse(`  type Query {  test: Int  }  ${str}  `)).getTypeMap()[typeName] as T;  }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/tests/transform-arguments.spec.ts","parseAndBuildSchema","{  return buildASTSchema(parse(`  type Query {  test: Int  }  ${str}  `)).getTypeMap()[typeName] as T;  }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/utils/get-directives.ts","getDirectives","{  const schemaDirectives: GraphQLDirective[] = schema.getDirectives ? schema.getDirectives() : [];  const astNode = node['astNode'];  let result: DirectiveUseMap = {};   if (astNode) {  schemaDirectives.forEach((directive: GraphQLDirective) => {  const directiveValue = getDirectiveValues(directive, astNode);   if (directiveValue !== undefined) {  result[directive.name] = directiveValue || {};  }  });  }   return result; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/utils/object-map-to-array.ts","objectMapToArray","{  return Object.keys(objectMap).map(key => ({ key, value: objectMap[key] })); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/utils/introspection-to-schema.ts","introspectionToGraphQLSchema","{  validateIntrospection(introspectionQuery);   return buildClientSchema(introspectionQuery); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/utils/get-field-def.ts","getFieldDef","{  const name = fieldAST.name.value;   if (name === '__typename') {  return null;  }   if (parentType instanceof GraphQLObjectType ||  parentType instanceof GraphQLInterfaceType) {  return parentType.getFields()[name];  }   return null; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/transform-document.ts","transformDocument","{  const result: Document = {  fragments: [],  operations: [],  hasFragments: false,  hasOperations: false,  };   const definitions = (documentNode.definitions || []);   debugLog(`[transformDocument] transforming total of ${definitions.length} definitions...`);   definitions.forEach((definitionNode: DefinitionNode) => {  if (definitionNode.kind === OPERATION_DEFINITION) {  result.operations.push(transformOperation(schema, definitionNode as OperationDefinitionNode));  } else if (definitionNode.kind === FRAGMENT_DEFINITION) {  result.fragments.push(transformFragment(schema, definitionNode as FragmentDefinitionNode));  } else {  console.log(`WARNING: It seems like you provided a GraphQL schema instead of GraphQL document: `);  console.log(definitionNode);  }  });   result.hasFragments = result.fragments.length > 0;  result.hasOperations = result.operations.length > 0;   return result; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/build-selection-set.ts","separateSelectionSet","{  const fields = selectionSet.filter(n => isFieldNode(n));  const fragmentsSpread = selectionSet.filter(n => isFragmentSpreadNode(n));  const inlineFragments = selectionSet.filter(n => isInlineFragmentNode(n));   return {  fragmentsSpread,  fields,  inlineFragments,  hasFragmentsSpread: fragmentsSpread.length > 0,  hasFields: fields.length > 0,  hasInlineFragments: inlineFragments.length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/build-selection-set.ts","buildSelectionSet","{  return ((node && node.selections ? node.selections : []) as SelectionNode[]).map<SelectionSetItem>((selectionNode: SelectionNode): SelectionSetItem => {  if (selectionNode.kind === FIELD) {  const fieldNode = selectionNode as FieldNode;  const name = fieldNode.alias && fieldNode.alias.value ? fieldNode.alias.value : fieldNode.name.value;  debugLog(`[buildSelectionSet] transforming FIELD with name ${name}`);  const field = getFieldDef(rootObject, fieldNode);   if (!field) {  debugLog(`[buildSelectionSet] Ignoring field because of null result from getFieldDef...`);   return null;  }   const resolvedType = resolveType(field.type);  const childSelectionSet = buildSelectionSet(schema, getNamedType(field.type), fieldNode.selectionSet);  const namedType = getNamedType(field.type);  const indicators = resolveTypeIndicators(namedType);   return {  isField: true,  isFragmentSpread: false,  isInlineFragment: false,  isLeaf: childSelectionSet.length === 0,  name,  selectionSet: childSelectionSet,  ...separateSelectionSet(childSelectionSet),  type: resolvedType.name,  isRequired: resolvedType.isRequired,  isArray: resolvedType.isArray,  isEnum: indicators.isEnum,  isScalar: indicators.isScalar,  isInterface: indicators.isInterface,  isUnion: indicators.isUnion,  isInputType: indicators.isInputType,  isType: indicators.isType,  } as SelectionSetFieldNode;  } else if (selectionNode.kind === FRAGMENT_SPREAD) {  const fieldNode = selectionNode as FragmentSpreadNode;  debugLog(`[buildSelectionSet] transforming FRAGMENT_SPREAD with name ${fieldNode.name.value}...`);   return {  isField: false,  isFragmentSpread: true,  isInlineFragment: false,  isLeaf: true,  fragmentName: fieldNode.name.value,  } as SelectionSetFragmentSpread;  } else if (selectionNode.kind === INLINE_FRAGMENT) {  debugLog(`[buildSelectionSet] transforming INLINE_FRAGMENT...`);   const fieldNode = selectionNode as InlineFragmentNode;  const nextRoot = typeFromAST(schema, fieldNode.typeCondition);  const childSelectionSet = buildSelectionSet(schema, nextRoot, fieldNode.selectionSet);   return {  isField: false,  isFragmentSpread: false,  isInlineFragment: true,  isLeaf: childSelectionSet.length === 0,  selectionSet: childSelectionSet,  ...separateSelectionSet(childSelectionSet),  onType: fieldNode.typeCondition.name.value,  } as SelectionSetInlineFragment;  } else {  throw new Error(`Unexpected GraphQL type: ${(selectionNode as any).kind}!`);  }  }).filter(item => item); // filter to remove null types }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/transform-operation.ts","transformOperation","{  const name = operationNode.name && operationNode.name.value ? operationNode.name.value : '';  debugLog(`[transformOperation] transforming operation ${name} of type ${operationNode.operation}`);   const root: GraphQLObjectType = getRoot(schema, operationNode);  const variables = transformVariables(schema, operationNode);  const directives = getDirectives(schema, operationNode);  const selectionSet = buildSelectionSet(schema, root, operationNode.selectionSet);   return {  name,  selectionSet,  operationType: operationNode.operation,  variables: variables,  hasVariables: variables.length > 0,  isQuery: operationNode.operation === 'query',  isMutation: operationNode.operation === 'mutation',  isSubscription: operationNode.operation === 'subscription',  document: print(operationNode),  directives,  usesDirectives: Object.keys(directives).length > 0,  ...separateSelectionSet(selectionSet),  } as Operation; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/transform-fragment-document.ts","transformFragment","{  debugLog(`[transformFragment] transforming fragment ${fragment.name.value} on type ${fragment.typeCondition.name.value}`);   const root = typeFromAST(schema, fragment.typeCondition);  const name = fragment.name.value;  const onType = fragment.typeCondition.name.value;  const directives = getDirectives(schema, fragment);  const selectionSet = buildSelectionSet(schema, root, fragment.selectionSet);   return {  name,  onType,  selectionSet,  document: print(fragment),  directives,  usesDirectives: Object.keys(directives).length > 0,  ...separateSelectionSet(selectionSet),  } as Fragment; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/operations/transform-variables.ts","transformVariables","{  return definitionNode.variableDefinitions.map<Variable>((variableDefinition: VariableDefinitionNode): Variable => {  const typeFromSchema = typeFromAST(schema, variableDefinition.type);  const resolvedType = resolveType(typeFromSchema);  debugLog(`[transformVariables] transforming variable ${variableDefinition.variable.name.value} of type ${resolvedType.name}`);  const namedType = getNamedType(typeFromSchema);  const indicators = resolveTypeIndicators(namedType);   return {  name: variableDefinition.variable.name.value,  type: resolvedType.name,  isArray: resolvedType.isArray,  isRequired: resolvedType.isRequired,  isEnum: indicators.isEnum,  isScalar: indicators.isScalar,  isInterface: indicators.isInterface,  isUnion: indicators.isUnion,  isInputType: indicators.isInputType,  isType: indicators.isType,  };  }); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/types.ts","isFieldNode","{  return node['name'] !== undefined && node['selectionSet'] !== undefined && node['type'] !== undefined; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/types.ts","isFragmentSpreadNode","{  return node['fragmentName'] !== undefined; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/types.ts","isInlineFragmentNode","{  return node['selectionSet'] !== undefined && node['onType'] !== undefined; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/resolve-type.ts","isRequired","{  return (String(type)).indexOf('!') > -1; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/resolve-type.ts","isArray","{  return (String(type)).indexOf('[') > -1; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/resolve-type.ts","resolveType","{  const name = getNamedType(type).name;  debugLog(`[resolveType] resolving type ${name}`);   return {  name,  isRequired: isRequired(type),  isArray: isArray(type),  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-enum.ts","transformGraphQLEnum","{  debugLog(`[transformGraphQLEnum] transformed enum ${graphqlEnum.name}`);  const directives = getDirectives(schema, graphqlEnum);   const enumValues = graphqlEnum.getValues().map<EnumValue>((enumItem: GraphQLEnumValue) => {  return <EnumValue>{  name: enumItem.name,  description: enumItem.description || '',  value: enumItem.value  };  });   return {  name: graphqlEnum.name,  description: graphqlEnum.description || '',  values: enumValues,  directives,  usesDirectives: Object.keys(directives).length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-directives.ts","transformDirectives","{  return directives.map<Directive>((directive: GraphQLDirective): Directive => {  const args = resolveArguments(schema, directive.args);  const locations = directive.locations || [];   return {  name: directive.name,  description: directive.description || '',  hasArguments: args.length > 0,  arguments: args,  locations,   onFragmentSpread: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),  onInlineFragment: locations.includes(DirectiveLocation.INLINE_FRAGMENT),  onQuery: locations.includes(DirectiveLocation.QUERY),  onMutation: locations.includes(DirectiveLocation.MUTATION),  onSubscription: locations.includes(DirectiveLocation.SUBSCRIPTION),  onFragment: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),  onField: locations.includes(DirectiveLocation.FIELD),   onSchema: locations.includes(DirectiveLocation.SCHEMA),  onScalar: locations.includes(DirectiveLocation.SCALAR),  onFieldDefinition: locations.includes(DirectiveLocation.FIELD_DEFINITION),  onEnum: locations.includes(DirectiveLocation.ENUM),  onEnumValue: locations.includes(DirectiveLocation.ENUM_VALUE),  onObject: locations.includes(DirectiveLocation.OBJECT),  onInputObject: locations.includes(DirectiveLocation.INPUT_OBJECT),  onInputField: locations.includes(DirectiveLocation.INPUT_FIELD_DEFINITION),  onArgument: locations.includes(DirectiveLocation.ARGUMENT_DEFINITION),  onInterface: locations.includes(DirectiveLocation.INTERFACE),  onUnion: locations.includes(DirectiveLocation.UNION),  };  }); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-union.ts","transformUnion","{  debugLog(`[transformUnion] transformed union ${union.name}`);  const directives = getDirectives(schema, union);   return {  name: union.name,  description: union.description || '',  possibleTypes: union.getTypes().map(type => type.name),  directives,  usesDirectives: Object.keys(directives).length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/resolve-type-indicators.ts","resolveTypeIndicators","{  const isEnum = namedType['getValues'] !== undefined;   return {  isType: namedType instanceof GraphQLObjectType,  isScalar: namedType instanceof GraphQLScalarType,  isInterface: namedType instanceof GraphQLInterfaceType,  isUnion: namedType instanceof GraphQLUnionType,  isInputType: namedType instanceof GraphQLInputObjectType,  isEnum: namedType instanceof GraphQLEnumType,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/schema-to-template-context.ts","schemaToTemplateContext","{  debugLog('[schemaToTemplateContext] started...');   const directives = getDirectives(schema, schema);  const result: SchemaTemplateContext = {  types: [],  inputTypes: [],  enums: [],  unions: [],  scalars: [],  interfaces: [],  definedDirectives: [],  // Indicators  hasTypes: false,  hasInputTypes: false,  hasEnums: false,  hasUnions: false,  hasScalars: false,  hasInterfaces: false,  hasDefinedDirectives: false,  rawSchema: schema,  directives,  usesDirectives: Object.keys(directives).length > 0,  };   const rawTypesMap = schema.getTypeMap();  const typesMap = clearTypes(rawTypesMap);  const typesArray = objectMapToArray<GraphQLNamedType>(typesMap);   debugLog(`[schemaToTemplateContext] Got total of ${typesArray.length} types in the GraphQL schema`);   typesArray.map((graphQlType: { key: string, value: GraphQLNamedType }) => {  const actualTypeDef = graphQlType.value;   if (actualTypeDef instanceof GraphQLObjectType) {  result.types.push(transformGraphQLObject(schema, actualTypeDef));  } else if (actualTypeDef instanceof GraphQLInputObjectType) {  result.inputTypes.push(transformGraphQLObject(schema, actualTypeDef));  } else if (actualTypeDef instanceof GraphQLEnumType) {  result.enums.push(transformGraphQLEnum(schema, actualTypeDef));  } else if (actualTypeDef instanceof GraphQLUnionType) {  result.unions.push(transformUnion(schema, actualTypeDef));  } else if (actualTypeDef instanceof GraphQLInterfaceType) {  result.interfaces.push(transformInterface(schema, actualTypeDef));  } else if (actualTypeDef instanceof GraphQLScalarType) {  result.scalars.push(transformScalar(schema, actualTypeDef));  } else {  throw new Error(`Unexpected GraphQL type definition: ${graphQlType.key} (As string: ${String(actualTypeDef)})`);  }  });   result.definedDirectives = transformDirectives(schema, schema.getDirectives() || []);   result.hasTypes = result.types.length > 0;  result.hasInputTypes = result.inputTypes.length > 0;  result.hasEnums = result.enums.length > 0;  result.hasUnions = result.unions.length > 0;  result.hasScalars = result.scalars.length > 0;  result.hasInterfaces = result.interfaces.length > 0;  result.hasDefinedDirectives = result.definedDirectives.length > 0;   debugLog(`[schemaToTemplateContext] done, results is: `, result);   return result; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-fields.ts","resolveFields","{  const fieldsArray = objectMapToArray<GraphQLField<any, any>>(rawFields);   return fieldsArray.map<Field>((item: { key: string, value: GraphQLField<any, any> }): Field => {  const type = resolveType(item.value.type);  const resolvedArguments = resolveArguments(schema, item.value.args || []);  const namedType = getNamedType(item.value.type);  const indicators = resolveTypeIndicators(namedType);  const directives = getDirectives(schema, item.value);   debugLog(`[resolveFields] transformed field ${item.value.name} of type ${type}, resolved type is: `, type);   return {  name: item.value.name,  description: item.value.description || '',  arguments: resolvedArguments,  type: type.name,  isArray: type.isArray,  isRequired: type.isRequired,  hasArguments: resolvedArguments.length > 0,  isEnum: indicators.isEnum,  isScalar: indicators.isScalar,  isInterface: indicators.isInterface,  isUnion: indicators.isUnion,  isInputType: indicators.isInputType,  isType: indicators.isType,  directives,  usesDirectives: Object.keys(directives).length > 0,  };  }); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-object.ts","transformGraphQLObject","{  debugLog(`[transformGraphQLObject] transforming type ${object.name}`);  const resolvedFields = resolveFields(schema, (object as any).getFields());  const resolvedInterfaces = object instanceof GraphQLObjectType ? object.getInterfaces().map(inf => inf.name) : [];  const directives = getDirectives(schema, object);   return {  name: object.name,  description: object.description || '',  fields: resolvedFields,  interfaces: resolvedInterfaces,  isInputType: object instanceof GraphQLInputObjectType,  hasFields: resolvedFields.length > 0,  hasInterfaces: resolvedInterfaces.length > 0,  directives,  usesDirectives: Object.keys(directives).length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/resolve-arguments.ts","resolveArguments","{  return args.map((arg: GraphQLArgument): Argument => {  const type = resolveType(arg.type);  const namedType = getNamedType(arg.type);  const indicators = resolveTypeIndicators(namedType);  const directives = getDirectives(schema, arg);   debugLog(`[resolveArguments] resolving argument ${arg.name} of type ${type.name}...`);   return {  name: arg.name,  description: arg.description || '',  type: type.name,  isRequired: type.isRequired,  isArray: type.isArray,  isEnum: indicators.isEnum,  isScalar: indicators.isScalar,  isInterface: indicators.isInterface,  isUnion: indicators.isUnion,  isInputType: indicators.isInputType,  isType: indicators.isType,  directives,  usesDirectives: Object.keys(directives).length > 0,  };  }); }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-scalar.ts","transformScalar","{  debugLog(`[transformInterface] transformed custom scalar ${scalar.name}`);  const directives = getDirectives(schema, scalar);   return {  name: scalar.name,  description: scalar.description || '',  directives,  usesDirectives: Object.keys(directives).length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/schema/transform-interface.ts","transformInterface","{  debugLog(`[transformInterface] transformed interface ${gqlInterface.name}`);   const resolvedFields = resolveFields(schema, gqlInterface.getFields());  const directives = getDirectives(schema, gqlInterface);   return {  name: gqlInterface.name,  description: gqlInterface.description || '',  fields: resolvedFields,  hasFields: resolvedFields.length > 0,  directives,  usesDirectives: Object.keys(directives).length > 0,  }; }"
"../test-repos/dotansimha_graphql-code-generator/packages/graphql-codegen-core/src/debugging.ts","debugLog","{  if (process.env.DEBUG !== undefined) {  console.log(...args);  } }"
"../test-repos/dwyl_hapi-typescript-example/test/utils.ts","createTaskDummy","{  var user = {  name: name || 'dummy task',  description: description || 'I'm a dummy task!'  };   if (userId) {  user['userId'] = userId;  }   return user; }"
"../test-repos/dwyl_hapi-typescript-example/test/utils.ts","createUserDummy","{  var user = {  email: email || 'dummy@mail.com',  name: 'Dummy Jones',  password: '123123'  };   return user; }"
"../test-repos/dwyl_hapi-typescript-example/test/utils.ts","clearDatabase","{  var promiseUser = database.userModel.remove({});  var promiseTask = database.taskModel.remove({});   Promise.all([promiseUser, promiseTask]).then(() => {  done();  }).catch((error) => {  console.log(error);  }); }"
"../test-repos/dwyl_hapi-typescript-example/test/utils.ts","createSeedTaskData","{  return database.userModel.create(createUserDummy())  .then((user) => {  return Promise.all([  database.taskModel.create(createTaskDummy(user._id, 'Task 1', 'Some dummy data 1')),  database.taskModel.create(createTaskDummy(user._id, 'Task 2', 'Some dummy data 2')),  database.taskModel.create(createTaskDummy(user._id, 'Task 3', 'Some dummy data 3')),  ]);  }).then((task) => {  done();  }).catch((error) => {  console.log(error);  }); }"
"../test-repos/dwyl_hapi-typescript-example/test/utils.ts","createSeedUserData","{  database.userModel.create(createUserDummy())  .then((user) => {  done();  })  .catch((error) => {  console.log(error);  }); }"
"../test-repos/dwyl_hapi-typescript-example/src/configurations/index.ts","getDatabaseConfig","{  return configs.get('database'); }"
"../test-repos/dwyl_hapi-typescript-example/src/configurations/index.ts","getServerConfigs","{  return configs.get('server'); }"
"../test-repos/dwyl_hapi-typescript-example/src/tasks/routes.ts","../test-repos/dwyl_hapi-typescript-example/src/tasks/index.ts","init","{  Routes(server, configs, database); }"
"../test-repos/dwyl_hapi-typescript-example/src/database.ts","init","{   (<any>Mongoose).Promise = Promise;  Mongoose.connect(process.env.MONGO_URL || config.connectionString);   let mongoDb = Mongoose.connection;   mongoDb.on('error', () => {  console.log(`Unable to connect to database: ${config.connectionString}`);  });   mongoDb.once('open', () => {  console.log(`Connected to database: ${config.connectionString}`);  });   return {  taskModel: TaskModel,  userModel: UserModel  }; }"
"../test-repos/dwyl_hapi-typescript-example/src/users/routes.ts","../test-repos/dwyl_hapi-typescript-example/src/users/index.ts","init","{  Routes(server, configs, database); }"
"../test-repos/dwyl_hapi-typescript-example/src/users/user.ts","hashPassword","{  if (!password) {  return null;  }   return Bcrypt.hashSync(password, Bcrypt.genSaltSync(8)); }"
"../test-repos/dwyl_hapi-typescript-example/src/server.ts","init","{   return new Promise<Hapi.Server>(resolve => {   const port = process.env.PORT || configs.port;  const server = new Hapi.Server();   server.connection({  port: port,  routes: {  cors: true  }  });   if (configs.routePrefix) {  server.realm.modifiers.route.prefix = configs.routePrefix;  }   // Setup Hapi Plugins  const plugins: Array<string> = configs.plugins;  const pluginOptions = {  database: database,  serverConfigs: configs  };   let pluginPromises = [];   plugins.forEach((pluginName: string) => {  var plugin: IPlugin = (require('./plugins/' + pluginName)).default();  console.log(`Register Plugin ${plugin.info().name} v${plugin.info().version}`);  pluginPromises.push(plugin.register(server, pluginOptions));  });   Promise.all(pluginPromises).then(() => {  console.log('All plugins registered successfully.');   console.log('Register Routes');  Tasks.init(server, configs, database);  Users.init(server, configs, database);  console.log('Routes registered sucessfully.');   resolve(server);  });  }); }"
"../test-repos/editor-rs_vscode-rust/src/OutputChannelProcess.ts","create","{  if (spawnOptions === undefined) {  spawnOptions = {};  }  spawnOptions.stdio = 'pipe';  const spawnedProcess = spawn(spawnCommand, spawnArgs, spawnOptions);  const outputChannel = window.createOutputChannel(outputChannelName);  outputChannel.show();  const result = await process(spawnedProcess, outputChannel);  if (result.success && result.code === 0) {  outputChannel.hide();  outputChannel.dispose();  }  return result; }"
"../test-repos/editor-rs_vscode-rust/src/OutputChannelProcess.ts","process","{  const stdout = '';  const captureStdout = getOption(options, o => o.captureStdout, false);  subscribeToDataEvent(process.stdout, outputChannel, captureStdout, stdout);  const stderr = '';  const captureStderr = getOption(options, o => o.captureStderr, false);  subscribeToDataEvent(process.stderr, outputChannel, captureStderr, stderr);  return new Promise<Success | Error>(resolve => {  const processProcessEnding = (code: number) => {  resolve({  success: true,  code,  stdout,  stderr  });  };  // If some error happens, then the 'error' and 'close' events happen.  // If the process ends, then the 'exit' and 'close' events happen.  // It is known that the order of events is not determined.  let processExited = false;  let processClosed = false;  process.on('error', (error: any) => {  outputChannel.appendLine(`error: error=${error}`);  resolve({ success: false });  });  process.on('close', (code, signal) => {  outputChannel.appendLine(`\nclose: code=${code}, signal=${signal}`);  processClosed = true;  if (processExited) {  processProcessEnding(code);  }  });  process.on('exit', (code, signal) => {  outputChannel.appendLine(`\nexit: code=${code}, signal=${signal}`);  processExited = true;  if (processClosed) {  processProcessEnding(code);  }  });  }); }"
"../test-repos/editor-rs_vscode-rust/src/OutputChannelProcess.ts","getOption","{  if (options === undefined) {  return defaultValue;  }  const option = getOption(options);  if (option === undefined) {  return defaultValue;  }  return option; }"
"../test-repos/editor-rs_vscode-rust/src/OutputChannelProcess.ts","subscribeToDataEvent","{  readable.on('data', chunk => {  const chunkAsString = typeof chunk === 'string' ? chunk : chunk.toString();  outputChannel.append(chunkAsString);  if (saveData) {  dataStorage += chunkAsString;  }  }); }"
"../test-repos/editor-rs_vscode-rust/src/UserInteraction/AskUserToAnswerYesOrNo.ts","askUserToAnswerYesOrNo","{  const yesChoice: MessageItem = { title: 'Yes' };  const noChoice: MessageItem = { title: 'No', isCloseAffordance: true };  const choice = await window.showInformationMessage(message, { modal: true }, yesChoice, noChoice);  return choice === yesChoice; }"
"../test-repos/editor-rs_vscode-rust/src/UserInteraction/AskUserWhatConfigurationToSaveParameterIn.ts","askUserWhatConfigurationToSaveParameterIn","{  const userConfigurationChoice = 'User configuration';  const workspaceConfigurationChoice = 'Workspace configuration';  while (true) {  const choice = await window.showInformationMessage(  'What configuration do you want to save the parameter in?',  { modal: true },  userConfigurationChoice,  workspaceConfigurationChoice  );  switch (choice) {  case userConfigurationChoice:  return UserOrWorkspaceConfiguration.User;  case workspaceConfigurationChoice:  return UserOrWorkspaceConfiguration.Workspace;  default:  // Ask the user if the dialog has been dismissed intentionally and that the  // parameter shouldn't be saved. If the user doesn't confirm it, then we continue asking  if (await askUserToConfirmCancellation()) {  return undefined;  }  break;  }  } }"
"../test-repos/editor-rs_vscode-rust/src/UserInteraction/AskUserWhatConfigurationToSaveParameterIn.ts","askUserToConfirmCancellation","{  return await askUserToAnswerYesOrNo('The dialog has been dismissed. Do you want to cancel setting the configuration parameter?'); }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","askUserToChooseMode","{  const message = 'Choose a mode in which the extension will function';  const rlsChoice = 'RLS';  const legacyChoice = 'Legacy';  const readAboutChoice = 'Read about modes';  while (true) {  const choice = await window.showInformationMessage(message, rlsChoice, legacyChoice,  readAboutChoice);  switch (choice) {  case rlsChoice:  return Mode.RLS;  case legacyChoice:  return Mode.Legacy;  case readAboutChoice:  open('https://github.com/editor-rs/vscode-rust/blob/master/doc/main.md');  break;  default:  return undefined;  }  } }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","askPermissionToInstall","{  const installChoice = 'Install';  const message = `It seems ${what} is not installed. Do you want to install it?`;  const choice = await window.showInformationMessage(message, installChoice);  return choice === installChoice; }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","installComponent","{  window.showInformationMessage(`${componentName} is being installed. It can take a while`);  const componentInstalled = await installComponent();  logger.debug(`${componentName} has been installed=${componentInstalled} `);  if (componentInstalled) {  window.showInformationMessage(`${componentName} has been installed successfully`);  } else {  window.showErrorMessage(`${componentName} has not been installed. Check the output channel 'Rust Logging'`);  }  return componentInstalled;  }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","handleMissingRustupUserToolchain","{  class Item implements QuickPickItem {  public toolchain: Toolchain;  public label: string;  public description: string;   public constructor(toolchain: Toolchain, shouldLabelContainHost: boolean) {  this.toolchain = toolchain;  this.label = toolchain.toString(shouldLabelContainHost, true);  this.description = '';  }  }  const functionLogger = logger.createChildLogger('handleMissingRustupUserToolchain: ');  functionLogger.debug(`toolchainKind=${toolchainKind}`);  await window.showInformationMessage(`To properly function, the extension needs to know what ${toolchainKind} you want to use`);  const toolchains = getToolchains();  if (toolchains.length === 0) {  functionLogger.error('no toolchains');  return;  }  const toolchainsHaveOneHost = toolchains.every(t => t.host === toolchains[0].host);  const items = toolchains.map(t => new Item(t, !toolchainsHaveOneHost));  const item = await window.showQuickPick(items);  if (!item) {  return;  }  setToolchain(item.toolchain); }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","processPossibleSetButMissingUserToolchain","{  const functionLogger = logger.createChildLogger('processPossibleSetButMissingUserToolchain: ');  functionLogger.debug(`toolchainKind=${toolchainKind}`);  const userToolchain = getToolchain(rustup);  if (userToolchain === undefined) {  functionLogger.debug(`no user ${toolchainKind}`);  return;  }  if (rustup.isToolchainInstalled(userToolchain)) {  functionLogger.debug(`user ${toolchainKind} is installed`);  return;  }  logger.error(`user ${toolchainKind} is not installed`);  window.showErrorMessage(`The specified ${toolchainKind} is not installed`);  setToolchain(rustup)(undefined); }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","activate","{  const loggingManager = new LoggingManager();  const logger = loggingManager.getLogger();  const functionLogger = logger.createChildLogger('activate: ');  const rustup = await Rustup.create(logger.createChildLogger('Rustup: '));  if (rustup) {  await rustup.updateToolchains();  processPossibleSetButMissingUserToolchain(  functionLogger,  rustup,  'toolchain',  (r: Rustup) => r.getUserToolchain(),  (r: Rustup) => r.setUserToolchain  );  if (!rustup.getUserToolchain()) {  await handleMissingRustupUserToolchain(  functionLogger,  'toolchain',  rustup.getToolchains.bind(rustup),  rustup.setUserToolchain.bind(rustup)  );  }  const userToolchain = rustup.getUserToolchain();  if (userToolchain) {  await rustup.updateSysrootPath(userToolchain);  await rustup.updateComponents(userToolchain);  await rustup.updatePathToRustSourceCodePath();  }  }  const rustSource = await RustSource.create(rustup);  const configuration = new Configuration(logger.createChildLogger('Configuration: '));  const cargoInvocationManager = new CargoInvocationManager(rustup);  const rlsConfiguration = await RlsConfiguration.create(rustup, rustSource);  if (configuration.mode() === undefined) {  // The current configuration does not contain any specified mode and hence we should try to  // choose one.  const mode = await askUserToChooseMode();  switch (mode) {  case Mode.Legacy:  configuration.setMode(Mode.Legacy);  break;  case Mode.RLS:  configuration.setMode(Mode.RLS);  break;  case undefined:  break;  }  }  const currentWorkingDirectoryManager = new CurrentWorkingDirectoryManager();  const shellProviderManager = new ShellProviderManager(logger);  const cargoManager = new CargoManager(  ctx,  configuration,  cargoInvocationManager,  currentWorkingDirectoryManager,  shellProviderManager,  logger.createChildLogger('Cargo Manager: ')  );  addExecutingActionOnSave(ctx, configuration, cargoManager);  if (configuration.mode() === Mode.RLS) {  const rlsMode = new RlsMode(  configuration,  rlsConfiguration,  rustup,  cargoInvocationManager,  logger.createChildLogger('RlsMode: '),  ctx  );  const started = await rlsMode.start();  if (started) {  return;  }  }  // If we got here, then the chosen mode is not RLS  switch (configuration.mode()) {  case Mode.Legacy:  case undefined:  await runInLegacyMode(  ctx,  configuration,  cargoInvocationManager,  rustSource,  rustup,  currentWorkingDirectoryManager,  shellProviderManager,  logger  );  break;  case Mode.RLS:  break;  } }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","runInLegacyMode","{  const legacyModeManager = await LegacyModeManager.create(  context,  configuration,  cargoInvocationManager,  rustSource,  rustup,  currentWorkingDirectoryManager,  shellProviderManager,  logger.createChildLogger('Legacy Mode Manager: ')  );  await legacyModeManager.start(); }"
"../test-repos/editor-rs_vscode-rust/src/extension.ts","addExecutingActionOnSave","{  context.subscriptions.push(workspace.onDidSaveTextDocument(document => {  if (!window.activeTextEditor) {  return;  }  const activeDocument = window.activeTextEditor.document;  if (document !== activeDocument) {  return;  }  if (document.languageId !== 'rust' || !document.fileName.endsWith('.rs')) {  return;  }  const actionOnSave = configuration.getActionOnSave();  if (!actionOnSave) {  return;  }  switch (actionOnSave) {  case 'build':  cargoManager.executeBuildTask(CommandInvocationReason.ActionOnSave);  break;  case 'check':  cargoManager.executeCheckTask(CommandInvocationReason.ActionOnSave);  break;  case 'clippy':  cargoManager.executeClippyTask(CommandInvocationReason.ActionOnSave);  break;  case 'doc':  cargoManager.executeDocTask(CommandInvocationReason.ActionOnSave);  break;  case 'run':  cargoManager.executeRunTask(CommandInvocationReason.ActionOnSave);  break;  case 'test':  cargoManager.executeTestTask(CommandInvocationReason.ActionOnSave);  break;  }  })); }"
"../test-repos/editor-rs_vscode-rust/src/Utils.ts","surround_by_double_quotes","{  if (!s.startsWith(''')) {  s = '''.concat(s);  }  if (!s.endsWith(''')) {  s = s.concat(''');  }  return s; }"
"../test-repos/editor-rs_vscode-rust/src/CommandLine.ts","getCommandToSetEnvVar","{  switch (shell) {  case Shell.PowerShell:  return `$ENV:${varName}='${varValue}'`;  case Shell.Cmd:  return `set ${varName}=${varValue}`;  case Shell.Shell:  case Shell.Wsl:  return ` export ${varName}=${varValue}`;  } }"
"../test-repos/editor-rs_vscode-rust/src/CommandLine.ts","escapeSpaces","{  if (!s.includes(' ')) {  return s;  }  switch (shell) {  case Shell.PowerShell:  // Unescape  s = s.replace(new RegExp('` ', 'g'), ' ');  // Escape  return s.replace(new RegExp(' ', 'g'), '` ');  case Shell.Cmd:  s = s.concat();  if (!s.startsWith(''')) {  s = '''.concat(s);  }  if (!s.endsWith(''')) {  s = s.concat(''');  }  return s;  case Shell.Shell:  case Shell.Wsl:  s = s.concat();  if (!s.startsWith('\'')) {  s = '\''.concat(s);  }  if (!s.endsWith('\'')) {  s = s.concat('\'');  }  return s;  } }"
"../test-repos/editor-rs_vscode-rust/src/CommandLine.ts","getCommandToChangeWorkingDirectory","{  if (shell === Shell.Wsl) {  workingDirectory = correctPath(workingDirectory);  }  return getCommandForArgs(shell, ['cd', workingDirectory]); }"
"../test-repos/editor-rs_vscode-rust/src/CommandLine.ts","getCommandForArgs","{  args = args.map(a => escapeSpaces(a, shell));  return args.join(' '); }"
"../test-repos/editor-rs_vscode-rust/src/CommandLine.ts","getCommandToExecuteStatementsOneByOneIfPreviousIsSucceed","{  if (statements.length === 0) {  return '';  }  if (shell === Shell.PowerShell) {  let command = statements[0];  for (let i = 1; i < statements.length; ++i) {  command += `; if ($?) { ${statements[i]}; }`;  }  return command;  } else {  // The string starts with space to make sh not save the command.  // This code is also executed for cmd on Windows, but leading space doesn't break anything  let command = ' ' + statements[0];  for (let i = 1; i < statements.length; ++i) {  command += ` && ${statements[i]}`;  }  return command;  } }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/RustSource.ts","getPath","{  const userPath = await getUserPath();  if (userPath) {  return userPath;  }  if (rustup) {  return rustup.getPathToRustSourceCode();  } else {  return undefined;  } }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/RustSource.ts","getUserPath","{  const configurationPath = await getConfigurationPath();  if (configurationPath) {  return configurationPath;  }  return await getEnvPath(); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/RustSource.ts","checkPath","{  if (!path) {  return undefined;  }  if (await FileSystem.doesPathExist(path)) {  return path;  } else {  return undefined;  } }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/RustSource.ts","getConfigurationPath","{  const path = Configuration.getPathConfigParameter('rustLangSrcPath');  return await checkPath(path); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/RustSource.ts","getEnvPath","{  const path = Configuration.getPathEnvParameter('RUST_SRC_PATH');  return await checkPath(path); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Rustup.ts","getUserConfiguration","{  const configuration = Configuration.getConfiguration();  if (!configuration) {  return undefined;  }  const rustupConfiguration = configuration.get<any>('rustup');  if (!rustupConfiguration) {  return undefined;  }  return rustupConfiguration; }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Rustup.ts","getToolchainFromConfigurationParameter","{  const rustupConfiguration = getUserConfiguration();  if (!rustupConfiguration) {  return undefined;  }  const toolchainAsString = rustupConfiguration[parameter];  if (!toolchainAsString) {  return undefined;  }  const toolchain = Toolchain.parse(toolchainAsString);  if (toolchain) {  return toolchain;  } else {  return undefined;  } }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Rustup.ts","getUserNightlyToolchain","{  return getToolchainFromConfigurationParameter('nightlyToolchain'); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Rustup.ts","getUserToolchain","{  return getToolchainFromConfigurationParameter('toolchain'); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Rustup.ts","updateUserConfigurationParameter","{  let configuration = getUserConfiguration();  if (!configuration) {  configuration = {};  }  updateParameter(configuration);  Configuration.getConfiguration().update('rustup', configuration, true); }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Configuration.ts","asConfigurationParameterValue","{  switch (mode) {  case Mode.Legacy:  return 'legacy';  case Mode.RLS:  return 'rls';  case undefined:  return null;  } }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Configuration.ts","mode","{  const configuration = Configuration.getConfiguration();  const value: string | null | undefined = configuration[Properties.mode];  if (typeof value === 'string') {  switch (value) {  case asConfigurationParameterValue(Mode.Legacy):  return Mode.Legacy;  case asConfigurationParameterValue(Mode.RLS):  return Mode.RLS;  default:  return undefined;  }  } else {  return undefined;  }  }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Configuration.ts","findRacerPathSpecifiedByUser","{  const methodLogger = logger.createChildLogger('findRacerPathSpecifiedByUser: ');  let path: string | undefined | null = Configuration.getPathConfigParameter('racerPath');  if (!path) {  methodLogger.debug(`path=${path}`);  return undefined;  }  path = expandTilde(path);  methodLogger.debug(`path=${path}`);  const foundPath: string | undefined = await FileSystem.findExecutablePath(path);  methodLogger.debug(`foundPath=${foundPath}`);  return foundPath;  }"
"../test-repos/editor-rs_vscode-rust/src/components/configuration/Configuration.ts","findDefaultRacerPath","{  const methodLogger = logger.createChildLogger('findDefaultRacerPath: ');  const foundPath: string | undefined = await FileSystem.findExecutablePath('racer');  methodLogger.debug(`foundPath=${foundPath}`);  return foundPath;  }"
"../test-repos/editor-rs_vscode-rust/src/components/cargo/diagnostic_utils.ts","normalizeDiagnosticPath","{  if (isAbsolute(diagnosticPath)) {  return diagnosticPath;  } else {  return join(projectPath, diagnosticPath);  } }"
"../test-repos/editor-rs_vscode-rust/src/components/cargo/diagnostic_utils.ts","addUniqueDiagnostic","{  const uri = Uri.file(diagnostic.filePath);   const fileDiagnostics = diagnostics.get(uri);   if (!fileDiagnostics) {  // No diagnostics for the file  // The diagnostic is unique  diagnostics.set(uri, [diagnostic.diagnostic]);  } else if (isUniqueDiagnostic(diagnostic.diagnostic, fileDiagnostics)) {  const newFileDiagnostics = fileDiagnostics.concat([diagnostic.diagnostic]);  diagnostics.set(uri, newFileDiagnostics);  } }"
"../test-repos/editor-rs_vscode-rust/src/components/cargo/diagnostic_utils.ts","isUniqueDiagnostic","{  const foundDiagnostic = diagnostics.find(uniqueDiagnostic => {  if (!diagnostic.range.isEqual(uniqueDiagnostic.range)) {  return false;  }   if (diagnostic.message !== uniqueDiagnostic.message) {  return false;  }   return true;  });   return !foundDiagnostic; }"
"../test-repos/editor-rs_vscode-rust/src/components/cargo/output_channel_task_manager.ts","prependArgsWithMessageFormatIfRequired","{  if (!parseOutput) {  return;  }   // Prepend arguments with arguments making cargo print output in JSON.  switch (command) {  case 'build':  case 'check':  case 'clippy':  case 'test':  case 'run':  args = ['--message-format', 'json'].concat(args);  break;  }  }"
"../test-repos/editor-rs_vscode-rust/src/components/completion/completion_manager.ts","pushBlock","{  if (codeBlock) {  processedDocs.push({  language: 'rust',  value: currentBlock.join('\n')  });  } else {  processedDocs.push(currentBlock.join('\n'));  }  }"
"../test-repos/editor-rs_vscode-rust/src/Shell.ts","fromString","{  switch (s) {  case 'powershell':  return Shell.PowerShell;  case 'cmd':  return Shell.Cmd;  case 'shell':  return Shell.Shell;  case 'wsl':  return Shell.Wsl;  default:  return undefined;  } }"
"../test-repos/editor-rs_vscode-rust/src/Shell.ts","toString","{  switch (shell) {  case Shell.PowerShell:  return 'powershell';  case Shell.Cmd:  return 'cmd';  case Shell.Shell:  return 'shell';  case Shell.Wsl:  return 'wsl';  } }"
"../test-repos/editor-rs_vscode-rust/src/WslShellUtils.ts","correctPath","{  const disk = path.substr(0, 1).toLowerCase(); // For `C:\\Directory` it will be `C`  path = path.replace(new RegExp('\\\\', 'g'), '/'); // After the line it will look like `C:/Directory`  const pathWithoutDisk = path.substring(path.indexOf('/') + 1); // For `C:/Directory` it will be `Directory`  return `/mnt/${disk}/${pathWithoutDisk}`; }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","setValidationRules","{  //console.log('\n setValidationRules: ', rules_str);  //http://stackoverflow.com/questions/18840080/updating-firebase-security-rules-through-firebaseref-set  var https = require('https');     //equivelent of curl -X PUT -d '{ 'rules': { '.read': true } }' https://SampleChat.firebaseio-demo.com/.settings/rules.json?auth=FIREBASE_SECRET  var options = {   hostname: FIREBASE_LOCATION,   port: 443,   path: '/.settings/rules.json?auth='+FIREBASE_SECRET,   method: 'PUT'  };    var req = https.request(options, function(res) {   //console.log('statusCode: ', res.statusCode);   //console.log('headers: ', res.headers);    res.on('data', function(d) {   process.stdout.write(d);   var data = JSON.parse(d); //check the return json's status that Firebase writes     if (data.status == 'ok'){    //so Firebase says it uploaded ok  cb(null);   } else {  //went wrong   cb (data);   }     });  });    req.write( rules_str , 'utf8' );//write the actual rules in the request payload  req.end();   req.on('error', function(e) {   console.error(e);//the whole request went bad which is not a good   cb(e, null);  }); }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","assertSetValidationRules","{  setValidationRules(rules_str, function(err){  if (err) {  test.ok(false);  } else {  test.ok(true);  }  cb(err);  }) }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","getValidationRules","{  console.log('\n getValidationRules');  //http://stackoverflow.com/questions/18840080/updating-firebase-security-rules-through-firebaseref-set  var https = require('https');     //curl https://SampleChat.firebaseio-demo.com/.settings/rules.json?auth=FIREBASE_SECRET  var options = {   hostname: FIREBASE_LOCATION,   port: 443,   path: '/.settings/rules.json?auth='+FIREBASE_SECRET,   method: 'GET'  };    var req = https.request(options, function(res) {   console.log('statusCode: ', res.statusCode);   console.log('headers: ', res.headers);    res.on('data', function(d) {   var data = d.toString();   console.log('\n', data);   cb(null, data);   });  });    req.end();   req.on('error', function(e) {   console.error(e);//the whole request went bad which is not a good   cb(e, null);  }); }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","getAuthToken","{  var FBTokenGenMod = require('firebase-token-generator');  var FBTokenGenerator = new FBTokenGenMod(FIREBASE_SECRET);  return FBTokenGenerator.createToken({ username: username }, {admin: admin, simulate:simulate}); }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","login","{  sandbox.auth(AUTH_TOKEN, cb); }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","loginAs","{  login(exports.getAuthToken(username, admin), cb); }"
"../test-repos/firebase_blaze_compiler/test/firebase_io.ts","simulateLoginAs","{  login(exports.getAuthToken(username, admin, true), cb); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testValidSchema","{  var firebase_schema = blaze.load_yaml('schema/schema.yaml');  var metaschema = fs.readFileSync('schema/jsonschema', {encoding: 'utf8'});   var valid = tv4.validate(firebase_schema, metaschema, false, false);   test.deepEqual(tv4.getMissingUris(), []);   test.ok(valid);  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testStructureValidation","{  var structure_example = blaze.load_yaml('examples/structure.yaml');  test.ok(blaze.validate_rules(structure_example));  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testStructureParsing","{  var structure_example: Json.JValue = blaze.load_yaml('examples/structure.yaml');  var rule = blaze.Rules.parse(structure_example.asObject());  console.log(rule);  test.ok(rule.schema != null);  test.ok(rule.functions['isLoggedIn'] != null);  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testAntiCases","{   //load all anti-cases  var files = fs.readdirSync('test/anticases'); //it doesn't like directories   for (var i in files){  if (!files.hasOwnProperty(i)) continue;  var path:string = 'test/anticases/'+files[i];   blaze.load_yaml_collection(path, function(anticase: Json.JValue){  var failed = compiler.compileJSON(anticase) == null;  if (!failed){  console.error('passed anticase:-');  console.error(anticase.toJSON());  }   test.ok(failed);  //I would like to halt the test but an error can't be thrown and  //you don't want the async done to be called twice   });  }   test.done(); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testMailValidation","{  var mail_example = blaze.load_yaml('examples/mail_example.yaml');  test.ok(blaze.validate_rules(mail_example));  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/validation_test.ts","testRequiredArray","{  var schema_yaml =  'schema:\n'+  ' type: object\n'+  ' required: object\n'; //should fail because required is not an array    var schema: Json.JValue = Json.parse_yaml(schema_yaml);   try {  blaze.validate_rules(schema);  test.ok(false);  } catch(err) {  test.ok(true);  }   test.ok(compiler.compileJSON(schema) == null);  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/scenarios_test.ts","run","{  globals.debug = true;  //called if this file is run, used to enable runtime debugging  console.log('working?', checkScenario('./test/scenarios/accessContext.yaml')) }"
"../test-repos/firebase_blaze_compiler/test/scenarios_test.ts","testFiles","{  globals.debug = false;  //load all anti-cases  var files = fs.readdirSync('test/scenarios');   for (var i in files){  if (!files.hasOwnProperty(i)) continue;   var path: string = 'test/scenarios/' + files[i];   console.log('checking', path);  test.ok(checkScenario(path), 'error on file ' + path);  }  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/parse_test.ts","testEntryParseRoot1","{  var entry: blaze.AccessEntry = blaze.AccessEntry.parse(Json.parse('{'location': '/'}'));  test.deepEqual(entry.location, []);  var entry: blaze.AccessEntry = blaze.AccessEntry.parse(Json.parse('{'location': ''}'));  test.deepEqual(entry.location, []);  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testSetup","{  async.series([  firebase_io.setValidationRules.bind(null, compiler.compile('examples/mail_example.yaml', true).code)  ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testWriteInbox","{  async.series([  test_utils.assert_admin_can_write.bind(null, '/', {}, test),   //check from field must be correct  test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/inbox/1', {  from: 'george',  to: 'bill',  message: 'Hi Bill!'  }, test),   //check spurious fields can't be added  test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/inbox/1', {  from: 'tom',  to: 'bill',  message: 'Hi Bill!',  spurious: 'spurious data'  }, test),   //correct write:-  test_utils.assert_can_write.bind(null, 'tom', '/users/bill/inbox/1', {  from: 'tom',  to: 'bill',  message: 'Hi Bill!'  }, test),   //check even the sender cannot delete a sent mail  test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/inbox/1', {}, test),   //check the inbox owner cannot tamper with message fields  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/inbox/1/message', 'bill gets my inheritance', test),  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/inbox/1/from', 'bill', test)   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testDeleteInbox","{  async.series([  test_utils.assert_admin_can_write.bind(null, '/', {}, test),   test_utils.assert_can_write.bind(null, 'tom', '/users/bill/inbox/1', {  from: 'tom',  to: 'bill',  message: 'Hi Bill!'  }, test),   //sender can't delete their sent mail  test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/inbox/1', {}, test),  //receiver can delete their received mail  test_utils.assert_can_write.bind (null, 'bill', '/users/bill/inbox/1', {}, test)   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testWriteOutbox","{  async.series([  test_utils.assert_admin_can_write.bind(null, '/', {}, test),   //check from field must be correct  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'joe',  to: 'tom',  message: 'Hi Tom!'  }, test),   //check spurious fields can't be added  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'bill',  to: 'tom',  message: 'Hi Tom!',  spurious: 'spurious'  }, test),   //correct write:-  test_utils.assert_can_write.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'bill',  to: 'tom',  message: 'Hi Tom!'  }, test),   //check even the receiver cannot delete a sent mail  test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/outbox/1', {}, test),   //check the outbox owner cannot tamper with message fields  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/outbox/1/message', 'bill gets my inheritance', test),  test_utils.assert_cant_write.bind(null, 'bill', '/users/bill/outbox/1/from', 'bill', test)   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testDeleteOutbox","{  async.series([  test_utils.assert_admin_can_write.bind(null, '/', {}, test),   //correct write:-  test_utils.assert_can_write.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'bill',  to: 'tom',  message: 'Hi Tom!'  }, test),   test_utils.assert_cant_write.bind(null, 'tom', '/users/bill/outbox/1', {}, test),  test_utils.assert_can_write.bind(null, 'bill', '/users/bill/outbox/1', {}, test)   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/mail_example_test.ts","testReadboxes","{  async.series([  test_utils.assert_admin_can_write.bind(null, '/', {}, test),   //write some messages to bills boxes  test_utils.assert_can_write.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'bill',  to: 'tom',  message: 'Hi Tom!'  }, test),   //correct write:-  test_utils.assert_can_write.bind(null, 'tom', '/users/bill/inbox/1', {  from: 'tom',  to: 'bill',  message: 'Hi Bill!'  }, test),   //check strangers can't read other people's mail  test_utils.assert_cant_read.bind(null, 'tom', '/users/bill/outbox/1', test),  test_utils.assert_cant_read.bind(null, 'tom', '/users/bill/inbox/1', test),   //check bill can read sent and received mail  test_utils.assert_can_read.bind(null, 'bill', '/users/bill/outbox/1', {  from: 'bill',  to: 'tom',  message: 'Hi Tom!'  }, test),   test_utils.assert_can_read.bind(null, 'bill', '/users/bill/inbox/1', {  from: 'tom',  to: 'bill',  message: 'Hi Bill!'  }, test)    ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSimplify1","{  var unoptimized:string = 'true && (false && (true && false) && (true && false) && true)';  var optimized = optimizer.simplify(unoptimized);  console.log(optimized);  //it be nice if this expanded to just && but because of lazy evaluation is not actually equivalent in general  test.notEqual(unoptimized, optimized);  test.ok(optimized.length < unoptimized.length, 'no improvement');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSimplify2","{  var unoptimized:string = '5 / (7 * 6)';  var optimized = optimizer.simplify(unoptimized);  test.equal(optimized, '5/(7*6)');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSimplify3","{  var unoptimized:string = '(5 / 6) * 7';  var optimized = optimizer.simplify(unoptimized);  test.equal(optimized, '5/6*7');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes0","{  //single quote string are fine as is  var unoptimized: string = 'a == ''';  var optimized = optimizer.sanitizeQuotes(unoptimized);  test.equal(optimized, 'a == ''');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes1","{  //double quote needs to be moved into a single quote string  var unoptimized: string = 'a == \'\'';  var optimized = optimizer.sanitizeQuotes(unoptimized);  test.equal(optimized, 'a == ''');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes2","{  //unescaped single quote needs to be escaped when moved into a single quote string  var unoptimized: string = 'a == \''\'';  var optimized = optimizer.sanitizeQuotes(unoptimized);  test.equal(optimized, 'a == '\\''');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes3","{  //escaped double quote can stay as is  var unoptimized: string = 'a == '\\''';  var optimized = optimizer.sanitizeQuotes(unoptimized);  //test.equal(optimized, 'a == '\\\'''); <- what I expected by falafel must be processing  test.equal(optimized, 'a == '\'''); //<-- still valid construction though  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes4","{  //escaped double quote can stay as is  var unoptimized: string = 'a == '' || b == \'\'';  var optimized = optimizer.sanitizeQuotes(unoptimized);  test.equal(optimized, 'a == '' || b == ''');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testSanitizeQuotes5","{  //escaped double quote can stay as is  var unoptimized: string = 'a == '\'\''';  var optimized = optimizer.sanitizeQuotes(unoptimized);  test.equal(optimized, 'a == '\\'\\''');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testEscapeQuotes1","{  //single quotes must be escaped  test.equal(optimizer.escapeSingleQuotes('''), '\\'');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testEscapeQuotes2","{  //single quotes must be escaped  test.equal(optimizer.escapeSingleQuotes(''''), '\\'\\'');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testEscapeEscapes1","{  //regex is escaped  var unoptimized: string = '/\\d/';  var optimized = optimizer.escapeEscapes(unoptimized);  test.equal(optimized, '/\\\\d/');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testPrune","{  test.equal(optimizer.pruneBooleanLiterals('!true'), 'false');  test.equal(optimizer.pruneBooleanLiterals('!false'), 'true');   test.equal(optimizer.pruneBooleanLiterals('true && true'), 'true');  test.equal(optimizer.pruneBooleanLiterals('true && false'), 'false');  test.equal(optimizer.pruneBooleanLiterals('false && true'), 'false');  test.equal(optimizer.pruneBooleanLiterals('false && false'), 'false');   test.equal(optimizer.pruneBooleanLiterals('true && f'), '(f)');  test.equal(optimizer.pruneBooleanLiterals('f && true'), '(f)');  test.equal(optimizer.pruneBooleanLiterals('false && f'), 'false');  test.equal(optimizer.pruneBooleanLiterals('f && false'), 'false');    test.equal(optimizer.pruneBooleanLiterals('true || f'), 'true');  test.equal(optimizer.pruneBooleanLiterals('f || true'), 'true');  test.equal(optimizer.pruneBooleanLiterals('false || f'), '(f)');  test.equal(optimizer.pruneBooleanLiterals('f || false'), '(f)');   test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testChildParentAnnihilation","{  test.equal(optimizer.childParentAnnihilation('data.child('x').parent().val()'), 'data.val()');   test.done(); }"
"../test-repos/firebase_blaze_compiler/test/optimize_test.ts","testClauseRepetitionElimination","{  test.equal(optimizer.clauseRepetitionElimination('a && a'), '((a))'); //bit weird with parenthesis  test.equal(optimizer.clauseRepetitionElimination('a || a'), '((a))');  test.equal(optimizer.clauseRepetitionElimination('a && b && a'), '(a&&b)');  test.equal(optimizer.clauseRepetitionElimination('a && b && b && a && c && a'), '(a&&b&&c)');  test.equal(optimizer.clauseRepetitionElimination('d && b && b && a && c && a'), '(d&&b&&a&&c)');  test.equal(optimizer.clauseRepetitionElimination('d || b || b || a || c || a'), '(d||b||a||c)');   test.done(); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testString","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/string.yaml', true).code, test),  test_utils.assert_can_write.bind (null, 'any', '/', 'correct', test),  test_utils.assert_cant_write.bind(null, 'any', '/', 'incorrect', test), //not in enum  test_utils.assert_cant_write.bind(null, 'any', '/', {'child':'correct'}, test),  test_utils.assert_can_read.bind (null, 'any', '/', 'correct', test)  ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testNumber","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/number.yaml', true).code, test),   test_utils.assert_can_write.bind (null, 'any', '/plain_number', 4, test),  test_utils.assert_can_write.bind (null, 'any', '/plain_number', 4.2, test),  test_utils.assert_can_write.bind (null, 'any', '/plain_number', -5, test),  test_utils.assert_cant_write.bind (null, 'any', '/plain_number', 'str', test),  test_utils.assert_cant_write.bind (null, 'any', '/plain_number', {'a':5}, test),   test_utils.assert_can_write.bind (null, 'any', '/min_number', 5, test),  test_utils.assert_cant_write.bind (null, 'any', '/min_number', 4.9, test),   test_utils.assert_can_write.bind (null, 'any', '/exclusive_min_number', 5.1, test),  test_utils.assert_cant_write.bind (null, 'any', '/exclusive_min_number', 5, test),    test_utils.assert_can_write.bind (null, 'any', '/max_number', 0, test),  test_utils.assert_cant_write.bind (null, 'any', '/max_number', 0.1, test),   test_utils.assert_can_write.bind (null, 'any', '/exclusive_max_number', -.1, test),  test_utils.assert_cant_write.bind (null, 'any', '/exclusive_max_number', 0, test),    ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testFunction_access","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/function_access.yaml', true).code, test),  test_utils.assert_cant_write.bind(null, 'tom', '/', 'string', test),  test_utils.assert_can_write.bind (null, 'not', '/', 'string', test),  test_utils.assert_cant_read.bind (null, 'not', '/', test),  test_utils.assert_can_read.bind (null, 'tom', '/', 'string', test)  ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testAccess","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/access.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/',  {chld1:{grnd1:'1', grnd2:'2'}, chld2:{grnd3:'3', grnd4:'4'}}, test),   test_utils.assert_cant_write.bind(null, 'red', '/chld2', {}, test),  test_utils.assert_cant_write.bind(null, 'red', '/chld2', {}, test),  test_utils.assert_cant_write.bind(null, 'black','/', {}, test),  test_utils.assert_cant_write.bind(null, 'black','/chld1/grnd1', 'string', test),  test_utils.assert_cant_write.bind(null, 'black','/chld1/grnd2', 'string', test),   test_utils.assert_can_write_mock.bind(null, 'red','/chld1/grnd1', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'red','/chld1/grnd2', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'black','/chld2/grnd3', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'black','/chld2/grnd4', 'string', test),   test_utils.assert_can_write_mock.bind(null, 'red', '/chld1', {}, test),  test_utils.assert_can_write_mock.bind(null, 'black','/chld2', {}, test),  test_utils.assert_cant_write.bind(null, 'black','/chld1', {}, test),  test_utils.assert_cant_write.bind(null, 'red', '/chld2', {}, test),   test_utils.assert_cant_write.bind(null, 'red', '/', {}, test),  test_utils.assert_cant_write.bind(null, 'red', '/', {}, test)   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testCascade","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/cascade.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/',{}, test),   test_utils.assert_cant_write.bind(null, 'any','/chld1/grnd1', 'string', test),  test_utils.assert_cant_write.bind(null, 'any','/chld1/grnd2', 'string', test),  test_utils.assert_cant_write.bind(null, 'any','/chld2/grnd3', 'string', test),  test_utils.assert_cant_write.bind(null, 'any','/chld2/grnd4', 'string', test),   test_utils.assert_can_write.bind(null, 'any','/',  {chld1:{grnd1:'1', grnd2:'2'}, chld2:{grnd3:'3', grnd4:'4'}}, test)    ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testRequired","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/required.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/',{}, test),   //should be able to write full try  test_utils.assert_can_write_mock.bind(null, 'any','/',  {chld1:{grnd1:'1', grnd2:'2'}, chld2:{grnd3:'3', grnd4:'4'}},  test),  //or the subtree with both required grandchildren  test_utils.assert_can_write_mock.bind(null, 'any','/chld1',  {grnd1:'1', grnd2:'2'},  test),  test_utils.assert_can_write_mock.bind(null, 'any','/chld2',  {grnd3:'3', grnd4:'4'},  test),  //or jsut one grandchild of the unrequired tree  test_utils.assert_can_write_mock.bind(null, 'any','/chld2/grnd3', '3', test),   //but not one grandchild of the required subtree  test_utils.assert_cant_write.bind(null, 'any','/chld1/grnd1', '1', test)    ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testTypes","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/types.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/',{}, test),   test_utils.assert_can_write_mock.bind(null, 'any','/object', {a:5} , test),  test_utils.assert_can_write_mock.bind(null, 'any','/string', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'any','/number', 1, test),  test_utils.assert_can_write_mock.bind(null, 'any','/boolean', true , test),   test_utils.assert_cant_write.bind(null, 'any','/object', 'string' , test),  test_utils.assert_cant_write.bind(null, 'any','/string', 1 , test),  test_utils.assert_cant_write.bind(null, 'any','/number', true , test),  test_utils.assert_cant_write.bind(null, 'any','/boolean', {a:5} , test),  test_utils.assert_cant_write.bind(null, 'any','/boolean', 'true' , test),   test_utils.assert_cant_write.bind(null, 'any','/extra', true , test),   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testDefinitions","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/definitions.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/', {}, test),   test_utils.assert_can_write.bind(null, 'any','/object', {'boolean':true} , test),  test_utils.assert_can_write_mock.bind(null, 'any','/object/boolean', true , test),  test_utils.assert_can_write_mock.bind(null, 'any','/string', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'any','/number', 1, test),  test_utils.assert_can_write_mock.bind(null, 'any','/boolean', true , test),   test_utils.assert_cant_write.bind(null, 'any','/object', 'string' , test),  test_utils.assert_cant_write.bind(null, 'any','/string', 1 , test),  test_utils.assert_cant_write.bind(null, 'any','/number', true , test),  test_utils.assert_cant_write.bind(null, 'any','/boolean', {a:5} , test),  test_utils.assert_cant_write.bind(null, 'any','/boolean', 'true' , test),   test_utils.assert_cant_write.bind(null, 'any','/extra', true , test),   test_utils.assert_can_write_mock.bind(null, 'any','/object/string', 'string', test),  test_utils.assert_can_write_mock.bind(null, 'any','/object/number', 1, test),  test_utils.assert_can_write_mock.bind(null, 'any','/object/boolean', true , test),    test_utils.assert_cant_write.bind(null, 'any','/object/extra', true , test),   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testAny","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/any.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/',{}, test),   test_utils.assert_can_write_mock.bind(null, 'any','/', true , test),  test_utils.assert_can_write_mock.bind(null, 'any','/', 'string' , test),  test_utils.assert_can_write_mock.bind(null, 'any','/', {chld_str: 'a', chld_bool: true}, test),   test_utils.assert_cant_write.bind(null, 'any','/', {chld_str: false, chld_bool: true} , test),   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testWildchild","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/wildchild.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/wildchild/',{}, test),    test_utils.assert_can_write_mock.bind(null, 'any','/wildchild/chld1', 'Y', test),  test_utils.assert_can_write_mock.bind(null, 'any','/wildchild/chld2', 'Y', test),  test_utils.assert_cant_write.bind(null, 'any','/wildchild/chld1', 'N', test),  test_utils.assert_cant_write.bind(null, 'any','/wildchild/chld2', 'N', test),   test_utils.assert_cant_write.bind(null, 'any','/wildchild/', {chld1:'Y', chld2:'Y'}, test),    test_utils.assert_can_write.bind(null, 'any','/wildchild/extra', 'N', test),    test_utils.assert_can_write.bind(null, 'any', '/wildchild/real', 'Y', test),  test_utils.assert_cant_write.bind(null, 'any', '/wildchild/real', null, test),    ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testWilderchild","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/wildchild.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/wilderchild/',{}, test),    test_utils.assert_can_write_mock.bind(null, 'any','/wilderchild/chld1', 'Y', test),  test_utils.assert_can_write_mock.bind(null, 'any','/wilderchild/chld2', 'Y', test),  test_utils.assert_cant_write.bind(null, 'any','/wilderchild/chld1', 'N', test),  test_utils.assert_cant_write.bind(null, 'any','/wilderchild/chld2', 'N', test),   test_utils.assert_can_write.bind (null, 'any','/wilderchild/', {chld1:'Y', chld2:'Y'}, test),  test_utils.assert_cant_write.bind(null, 'any','/wilderchild/', {chld1:'N', chld2:'Y'}, test),   test_utils.assert_can_write.bind(null, 'any','/wilderchild/extra', 'N', test),   test_utils.assert_can_write.bind(null, 'any', '/wilderchild/real', 'Y', test),  test_utils.assert_can_write.bind(null, 'any', '/wilderchild/real', null, test), //danger introduced by wilder childs   ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testSanitize","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/sanitize.yaml', true).code, test)  ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/codegen_test.ts","testNestedWildchilds","{  async.series([  firebase_io.assertSetValidationRules.bind(null, compiler.compile('test/cases/wildchild.yaml', true).code, test),   test_utils.assert_admin_can_write.bind(null, '/nested/',{}, test),    //anyone can write to grandchildren  test_utils.assert_can_write.bind(null, null,'/nested/a/a/data', 'a', test),  //no-one can delete because of constraint  test_utils.assert_cant_write.bind(null, null,'/nested/a/a/data', null, test),   //authenticated have greater permissions (can't do at the moment)  //test_utils.assert_can_write.bind(null, 'auth', '/nested/a', null, test),  ], test.done.bind(null)); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","translationTestCase","{  var expr = expressions.Expression.parse(from);   var symbols:expressions.Symbols = new expressions.Symbols();  symbols.functions = functions;  var translation = expr.generate(symbols);   test.equal(translation, to); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup1","{  translationTestCase(  'next['c1'].val()',  'newData.child('c1').val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup2","{  translationTestCase(  'next.c1.val()',  'newData.child('c1').val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup3","{  translationTestCase(  'next[prev.val()].val()',  'newData.child(data.val()).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup4","{  translationTestCase(  'next[prev].val()',  'newData.child(data.val()).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup5","{  translationTestCase(  'next[prev.child].val()',  'newData.child(data.child('child').val()).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup6","{  translationTestCase(  'next[prev[child]].val()',  'newData.child(data.child('child').val()).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testArrayLookup7","{  translationTestCase(  'next[prev[child]]['fred'].val()',  'newData.child(data.child('child').val()).child('fred').val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testParent1","{  translationTestCase(  'next.parent()',  'newData.parent()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testParent2","{  translationTestCase(  'next[prev.parent().val()]['blah'].c1.val()',  'newData.child(data.parent().val()).child('blah').child('c1').val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testHasChildren","{  translationTestCase(  'next.c1.hasChildren(['eric'])',  'newData.child('c1').hasChildren(['eric'])',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testContains1","{  translationTestCase(  'next.c1.val().contains('yo')',  'newData.child('c1').val().contains('yo')',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testContains2","{  translationTestCase(  ''yo'.contains('yo')',  ''yo'.contains('yo')',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testContains3","{  translationTestCase(  ''yo'.contains(prev.val())',  ''yo'.contains(data.val())',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testAuth1","{  translationTestCase(  'auth.id',  'auth.id',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testAuth2","{  translationTestCase(  'root.users[auth.id]',  'root.child('users').child(auth.id)',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testCoercion1","{  translationTestCase(  'root.superuser == auth.id',  'root.child('superuser').val()==auth.id',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testCoercion2","{  translationTestCase(  'auth.id == root[next]',  'auth.id==root.child(newData.val()).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","test$var1","{  translationTestCase(  'auth.id == $userid',  'auth.id==$userid',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","test$var3","{  translationTestCase(  'prev[$userid].val()',  'data.child($userid).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","test$var4","{  translationTestCase(  'prev.$userid.val()',  'data.child($userid).val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testNow","{  translationTestCase(  'next < now',  'newData.val()<now',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRoot","{  translationTestCase(  'root.users[auth.id].active == true',  'root.child('users').child(auth.id).child('active').val()==true',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testHasChild","{  translationTestCase(  'next.hasChild('name')',  'newData.hasChild('name')',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testHasChildren1","{  translationTestCase(  'next.hasChildren()',  'newData.hasChildren()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testHasChildren2","{  translationTestCase(  'next.hasChildren(['name', 'age'])',  'newData.hasChildren(['name', 'age'])',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testGetPriority","{  translationTestCase(  'next.getPriority() != null',  'newData.getPriority()!=null',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testLength","{  translationTestCase(  'next.isString()&&next.val().length>=10',  'newData.isString()&&newData.val().length>=10',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testBeginsWith","{  translationTestCase(  'auth.identifier.beginsWith('internal-')',  'auth.identifier.beginsWith('internal-')',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testEndsWith","{  translationTestCase(  'next.val().endsWith('internal-')',  'newData.val().endsWith('internal-')',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testReplace","{  translationTestCase(  'root.users[auth.email.replace('.', ',')].exists()',  'root.child('users').child(auth.email.replace('.', ',')).exists()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testToLowerCase","{  translationTestCase(  'root.users[auth.identifier.toLowerCase()].exists()',  'root.child('users').child(auth.identifier.toLowerCase()).exists()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testToUpperCase","{  translationTestCase(  'root.users[auth.identifier.toUpperCase()].exists()',  'root.child('users').child(auth.identifier.toUpperCase()).exists()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRegex1","{  translationTestCase(  '/regex/',  '/regex/',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRegex2","{  translationTestCase(  '/\\d/',  '/\\d/',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRegex3","{  translationTestCase(  '/\\\\d/',  '/\\\\d/',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRegex4","{  translationTestCase(  'root.val().matches(/regex/)',  'root.val().matches(/regex/)', //this second version needs to be safe inside a ''  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","Function","{  return new expressions.Function(dec, new Json.JString(expr, 0, 0)) }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunctionParsing1","{  var predicate = Function('f(x)', 'true');   test.ok(predicate.signature == 'f(1)');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunctionParsing2","{  var predicate = Function('f()', 'true');   test.ok(predicate.signature == 'f(0)');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunctionParsing3","{  var predicate = Function('f(x, y)', 'true');  test.equals(predicate.signature, 'f(2)');  test.deepEqual(predicate.parameter_map, ['x', 'y']);  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunction1","{  translationTestCase(  'isLoggedIn()',  '(auth.id==null)',  expressions.Functions.parse(  Json.parse('[{'isLoggedIn()':'auth.id == null'}]')  ),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunction2","{  translationTestCase(  'isEqual(prev, next.name)',  '(data.val()==newData.child('name').val())',  expressions.Functions.parse(  Json.parse('[{'isEqual(a, b)':'a == b'}]')  ),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testFunction3","{  translationTestCase(  'isLoggedIn(auth)',  '(auth.id=='yo')',  expressions.Functions.parse(  Json.parse('[{'isLoggedIn(q)':'q.id == \'yo\''}]')  ),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testUnary","{  translationTestCase(  '!isLoggedIn(auth)',  '!(auth.id=='yo')',  expressions.Functions.parse(  Json.parse('[{'isLoggedIn(q)':'q.id == \'yo\''}]')  ),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testSanitizeQuotes1","{  translationTestCase(  '\'string\'=='string'',  '\'string\'=='string'',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testSanitizeQuotes2","{  translationTestCase(  'next['string'] == prev[\'string\']',  'newData.child(\'string\').val()==data.child('string').val()',  new expressions.Functions(),  test  );  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/expressions_test.ts","testRewriteForChild","{  var expr = expressions.Expression.parse('true');  var rewrite = expr.rewriteForChild().toString();  test.equals(rewrite, 'true');  var expr2 = expressions.Expression.parse(rewrite);  var rewrite2 = expr2.rewriteForChild();  test.equals(rewrite2, 'true');  test.done(); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_admin_can_write","{  firebase_io.loginAs('anAdmin', true, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).set(value, function(error){  test.ok(error==null, 'there should not be an error but there was' +  JSON.stringify({function:'assert_admin_can_write', where:where, value:value}));  cb(error);  });  }  }); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_can_read","{  firebase_io.loginAs(who, false, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).once('value', function(data){  test.deepEqual(data.val(), expected);  cb(null);  }, function(error){  test.ok(error==null, 'the once should be error free but isn't' +  JSON.stringify({function:'assert_can_read', who:who, where:where, expected:expected}));  cb(error);  });  }  }); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_cant_read","{  firebase_io.loginAs(who, false, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).once('value', function(data){  test.ok(false, 'should not be able to read');  cb('should not be able to read');  }, function(error){  if(error){  cb(null);  }else{  test.ok(false, 'there should be a permission error but there isn't' +  JSON.stringify({function:'assert_cant_read', who:who, where:where}));  cb('there should be a permission error but there isn't');  }  });  }  }); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_can_write","{  firebase_io.loginAs(who, false, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).set(value, function(error){  test.ok(error==null, 'there should not be an error but there was' +  JSON.stringify({function:'assert_can_write', who:who, where:where, value:value}));  if(error){  cb('there should not be an error but there was');  }else{  cb(null);  }  });  }  }); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_can_write_mock","{  firebase_io.simulateLoginAs(who, false, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).set(value, function(error){  test.ok(error==null, 'there should not be an error but there was' +  JSON.stringify({function:'assert_can_write_mock', who:who, where:where, value:value}));  if(error){  cb('there should not be an error but there was');  }else{  cb(null);  }  });  }  }); }"
"../test-repos/firebase_blaze_compiler/test/test_utils.ts","assert_cant_write","{  firebase_io.loginAs(who, false, function(err){  if(err){  test.ok(false, 'can't login');  cb('can't login')  }else{  firebase_io.sandbox.child(where).set(value, function(error){  test.ok(error!=null,'there should be an error but there wasn't' +  JSON.stringify({function:'assert_cant_write', who:who, where:where, value:value}));  if(error){  cb(null);  }else{  cb('there should be an error but there wasn't');  }  });  }  }); }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","annotate","{  model.schema.root = annotate_schema(model.schema.json, null, null, new SchemaAPI(), model) }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","pushDownConstraints","{  model.schema.root.pushDownConstraints(model.functions, null); }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","pullUpConstraints","{  model.schema.root.pullUpConstraints(model.functions, ''); }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","combineACL","{  model.schema.root.combineACL(model.functions, model.access, []); }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","generateRules","{  var buffer:string[] = [];  buffer.push('{\n');  buffer.push(' 'rules':');   var symbols = new expression.Symbols();  symbols.loadFunction(model.functions);   model.schema.root.generate(symbols, ' ', buffer, false);  buffer.push('}\n');  //convert buffer into big string  var code: string = buffer.join('');  return code; }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","annotate_schema","{  if (node.has('$ref')) {  //we should replace this node with its definition  node = fetchRef(node.getOrThrow('$ref', '').coerceString().value, model);   if (key.indexOf('$') == 0 || key.indexOf('~$') == 0) {  parent.asObject().put(new Json.JString(key, -1, -1), node)  } else {  parent.asObject().getOrThrow('properties', 'no properties defined above reference with key:' + key).asObject().put(new Json.JString(key, -1, -1), node)  }  }   var annotation = new SchemaNode(node);   //recurse to children first in bottom up  if (node.has('properties')) {  node.getOrThrow('properties', '').asObject().forEach(  function(name: Json.JString, child: Json.JValue){  if (name.value.indexOf('$') == 0 || name.value.indexOf('~$') == 0) throw error.message(  'properties cannot start with $ or ~$, you probably want a wild(er)child which is not declared in the properties section'  ).source(name).on(new Error());   annotation.properties[name.value] = annotate_schema(child, node, name.getString(), api, model);  });  }   if (globals.debug) console.log('annotate_schema', node.toJSON());   //wildchilds need special treatment as they are not normal properties but still schema nodes  if (getWildchild(node)){  //add them as a property annotation  var wildname = getWildchild(node).value;  var wildkey = getWildchild(node);   annotation.properties[wildname] = annotate_schema(  node.getOrThrow(wildname, 'cant find wildchild'),  node, wildname, api, model);  //we also convert them into a pattern properties and add it to the JSON schema node so examples can pass  var patternProperties = new Json.JObject();   //so we move the wildchild from the root of the schema declaration,  //into a child of patternProperties so that the JSON schema validator can read it like a pattern  //accepting any property without saying its not declared  node.asObject().put(  new Json.JString('patternProperties', wildkey.start.position, wildkey.end.position),  patternProperties);   patternProperties.put(  new Json.JString(SchemaNode.KEY_PATTERN, 0,0),  node.getOrThrow(wildname, 'cant find wildchild'));  } else {  //console.log('no wildchild')  }   //fill in all defaults for a schema node  api.setContext(node, parent, annotation, model);  annotation.type = node.has('type') ? node.getOrThrow('type', '').asString().value: 'any';   if (!node.has('constraint')) {  node.asObject().put( //synthetically place a constraint in the user source so the SchemaAPI can extend it  new Json.JString('constraint', 0,0),  new Json.JString('true', 0,0)  )  }   annotation.additionalProperties = //objects are allowed extra properties by default  node.has('additionalProperties') ?  node.getOrThrow('additionalProperties', '').asBoolean().value : true;   annotation.examples = node.has('examples') ?  node.asObject().getOrThrow('examples', '').asArray(): new Json.JArray();   annotation.nonexamples = node.has('nonexamples') ?  node.asObject().getOrThrow('nonexamples', '').asArray(): new Json.JArray();   annotation.indexOn = []; //get indexOn, whether specified as a single string or an array  if (node.has('indexOn')) {  var index: Json.JValue = node.asObject().getOrThrow('indexOn', '');  if (index.type == Json.JType.JString) {  annotation.indexOn = [index.asString().value]  } else {  index.asArray().forEach(function (val) {  annotation.indexOn.push(val.asString().value)  })  }  }   //using type information, the metaschema is given an opportunity to customise the node with type specific keywords   if (api.metaschema[annotation.type] != undefined){  if (api.metaschema[annotation.type].validate(node)){  //the user compile could actually add more nodes, see schemaAPI.addProperty  //if this happens annotate_schema needs to be called for new nodes  //entering the system pragmatically in compile (done in addProperty)  api.metaschema[annotation.type].compile(api);  } else {  throw error.validation(  node,  api.metaschema[annotation.type].validator,  'subtree',  'annotation.type',  tv4.error  ).on(new Error());  }  } else {  throw error.source(node).message('unknown type '' + annotation.type + '' no metaschema to validate it').on(new Error());  }   //we parse the constraint after the api has processed it  //as it might have changed the constraints as part of its domain  annotation.constraint = expression.Expression.parseUser(  node.asObject().getOrThrow('constraint', 'no constraint defined').coerceString()  );   //if the user has supplied examples or non examples, the validity of these are checked   annotation.examples.forEach(function(example: Json.JValue){  var valid = tv4.validate(example.toJSON(), node.toJSON(), true, false);  if(!valid){  throw error.validation(  example,  node,  'example',  'schema',  tv4.error  ).on(new Error());  }  });   annotation.nonexamples.forEach(function(nonexample: Json.JValue){  var valid = tv4.validate(nonexample.toJSON(), node.toJSON(), true, false);  if(valid){  throw error.message('nonexample erroneously passed').source(nonexample).on(new Error());  }  });   return annotation; }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","fetchRef","{  //todo: this should probably be routed through tv4's getSchema method properly   //code nicked from tv4.getSchema:  var baseUrl = url; //not interested in yet  var fragment = '';  if (url.indexOf('#') !== -1) {   fragment = url.substring(url.indexOf('#') + 1);   baseUrl = url.substring(0, url.indexOf('#'));  }  var pointerPath = decodeURIComponent(fragment);   if (pointerPath.charAt(0) !== '/') {  throw error.message('$ref URL not starting with / or #/ ' + url).on(new Error())  }   var parts = pointerPath.split('/').slice(1);  var schema:Json.JValue = model.schema.json; //navigate user source   for (var i = 0; i < parts.length; i++) {  var component: string = parts[i].replace(/~1/g, '/').replace(/~0/g, '~');  schema = schema.getOrThrow(component,  [  JSON.stringify(schema.toJSON()),  'could not find schema at ' + component + ' of ' + pointerPath,   ].join('\n'))  }   if (globals.debug) console.log('fetchRef' + url + ' retrieved ' + JSON.stringify(schema.toJSON()));   return schema; }"
"../test-repos/firebase_blaze_compiler/src/schema.ts","getWildchild","{  var wildchild: Json.JString = null;  node.asObject().forEach(  function(keyword: Json.JString, child: Json.JValue){  var name: string = keyword.value;  if (name.indexOf('$') == 0 || name.indexOf('~$') == 0) {  if(wildchild == null) wildchild = keyword;  else{  throw error.message('multiple wildchilds defined:\n').source(node).on(new Error())  }  }  });  return wildchild; }"
"../test-repos/firebase_blaze_compiler/src/expression.ts","isArraySyntaxMemberExpression","{  return node.source().slice(node.object.source().length).trim().charAt(0) == '['; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","optimize","{  //return simplify(javascript_str);   var current_length = javascript_str.length + 1;  while (javascript_str.length < current_length) {  current_length = javascript_str.length;  var current = javascript_str;  //optimize stages  javascript_str = simplify(parentIsObjectCheckRemoval(clauseRepetitionElimination(childParentAnnihilation(pruneBooleanLiterals(javascript_str)))));  }  return current; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","optimizeAndTrim","{  var optimized = optimize(javascript_str);  optimized = optimized.replace(/^\(+true\)+$/, 'true');  optimized = optimized.replace(/^\(+false\)+$/,'false');  return optimized; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","simplify","{  if (simplifyMemory[javascript_str]) return simplifyMemory[javascript_str];   var simplify_fn = function(node){  node.precedence = 1000; //default precedence for all nodes other than operator nodes, e.g. terminals  if(node.type == 'BinaryExpression' || node.type == 'BooleanExpression' || node.type == 'LogicalExpression'){  node.precedence = js_precedence(node.operator); //overwrite with actual precedence  var LHS:any, RHS:any;  if(node.left.precedence >= node.precedence){  LHS = node.left.source(); //LHS is already strongly bound  }else if(node.left.precedence < node.precedence){  LHS = '('+node.left.source()+')'; //LHS is not strongly bound, boost with brackets  }   if(node.right.precedence == node.precedence && isCommunicativeUniquePrecedence(node.operator)){  //special case for communicative operators  RHS = node.right.source();  }else if(node.right.precedence > node.precedence){  //NOTE: > NOT >=  RHS = node.right.source(); //RHS is already strongly bound  }else if(node.right.precedence <= node.precedence){  RHS = '('+node.right.source()+')'; //RHS is not strongly bound, boost with brackets  }  node.update(LHS + node.operator + RHS);  }  };   var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();  simplifyMemory[javascript_str] = result;  return result; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","pruneBooleanLiterals","{  if (pruneBooleanLiteralsMemory[javascript_str]) return pruneBooleanLiteralsMemory[javascript_str];  var simplify_fn = function(node){  if (node.type == 'UnaryExpression') {  //!true => false  if (node.operator == '!' && node.argument.type == 'Literal') {  node.update(!node.argument.value)  }  } else if(node.type == 'LogicalExpression') {  //helper functions for querying literal arguments  node.left.is = function(val) {return node.left.type == 'Literal' && node.left.value == val;};  node.right.is = function(val) {return node.right.type == 'Literal' && node.right.value == val;};   if (node.operator == '&&' && node.left.is(true) && node.right.is(true)) {  node.update('true')  } else if (node.operator == '&&' && node.left.is(false)) {  node.update('false')  } else if (node.operator == '&&' && node.right.is(false)) {  node.update('false')  } else if (node.operator == '&&' && node.left.is(true)) {  node.update('('+node.right.source() + ')')  } else if (node.operator == '&&' && node.right.is(true)) {  node.update('('+node.left.source() + ')')  } else if (node.operator == '||' && node.left.is(false) && node.right.is(false)) {  node.update('false')  } else if (node.operator == '||' && node.left.is(true)) {  node.update('true')  } else if (node.operator == '||' && node.right.is(true)) {  node.update('true')  } else if (node.operator == '||' && node.left.is(false)) {  node.update('('+node.right.source() + ')')  } else if (node.operator == '||' && node.right.is(false)) {  node.update('('+node.left.source() + ')')  }  }  };   var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();  pruneBooleanLiteralsMemory[javascript_str] = result;  return result; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","clauseRepetitionElimination","{  if (clauseRepetitionEliminationMemory[javascript_str]) return clauseRepetitionEliminationMemory[javascript_str];   var simplify_fn = function(node){  if(node.type == 'LogicalExpression') {  if (node.parent.type == 'LogicalExpression' && node.parent.operator == node.operator) {  //so the parent is part of the same group so we don't want to do the expensive optimization yet  } else {  //we are the top level logical expression, lets hunt for repetitions  //the left pointer should be another logical expression  //the right should be a single expression  var operator = node.operator;  var clauses = [];  var logical = node;   while (logical.type == 'LogicalExpression' && logical.operator == operator) {  clauses.push(logical.right.source());  logical = logical.left;  }  clauses.push(logical.source()); //logical was the left of the previous seen logical expression  var clauses = clauses.reverse(); //make the LHS first   for (var primaryClause = 0; primaryClause < clauses.length; primaryClause++) {  for (var repeatClause = primaryClause + 1; repeatClause < clauses.length; repeatClause++) {  if (clauses[primaryClause] == clauses[repeatClause]) {  //secondaryClause repeats the primary clause, so delete it and adjust the indexing  clauses.splice(repeatClause,1);  repeatClause--; //adjustment for an element being removed during a loop  }  }  }   //now clauses should have no repeatitions and should be in the correct order LEFT to RIGHT  node.update(simplify('((' + clauses.join(')' + operator + '(') + '))'))   }  }  };   var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();  clauseRepetitionEliminationMemory[javascript_str] = result;  return result; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","childParentAnnihilation","{  if (childParentAnnihilationMemory[javascript_str]) return childParentAnnihilationMemory[javascript_str];  /* data.child('x').parent().val() AST expansion looks like:-  {  'type': 'Program',  'body': [  {  'type': 'ExpressionStatement',  'expression': {  'type': 'CallExpression',  'callee': {  'type': 'MemberExpression', <--- start hunting here  'computed': false,  'object': {  'type': 'CallExpression', <---- () of parent, this will be removed  'callee': {  'type': 'MemberExpression',  'computed': false,  'object': {  'type': 'CallExpression',  'callee': {  'type': 'MemberExpression',  'computed': false,  'object': { <--- kept  'type': 'Identifier',  'name': 'data'  },  'property': {  'type': 'Identifier',  'name': 'child'  }  },  'arguments': [ <---- irrelavant  {  'type': 'Literal',  'value': 'x',  'raw': ''x''  }  ]  },  'property': {  'type': 'Identifier',  'name': 'parent'  }  },  'arguments': []  },  'property': {  'type': 'Identifier',  'name': 'val'  }  },  'arguments': []  }  }  ] } */  var simplify_fn = function(node){  //detect the above situation and rewrite  if (node.type == 'MemberExpression' &&  node.object.type == 'CallExpression' &&  node.object.arguments.length == 0 &&  node.object.callee.type == 'MemberExpression' &&  node.object.callee.property.type == 'Identifier' &&  node.object.callee.property.name == 'parent' &&  node.object.callee.object.type == 'CallExpression' &&  node.object.callee.object.callee.type == 'MemberExpression' &&  node.object.callee.object.callee.property.type == 'Identifier' &&  node.object.callee.object.callee.property.name == 'child') {   //rewrite node  node.object.update(node.object.callee.object.callee.object.source())  }  };   var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();  childParentAnnihilationMemory[javascript_str] = result;  return result; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","parentIsObjectCheckRemoval","{  if (parentIsObjectCheckRemovalMemory[javascript_str]) return parentIsObjectCheckRemovalMemory[javascript_str];   //if on the top level && we are checking to see if our parent is an object or null, we are doing a redundant check because  //we can only write either null, a primitive or an object at newData location  //therefore our parent will flip only to null, or an object, thus we don't need to check for this pattern   //((!newData.parent().parent().parent().parent().parent().exists()||newData.parent().parent().parent().parent().parent().hasChildren())  var simplify_fn = function(node){  //detect the above situation and rewrite  if (node.type == 'LogicalExpression' && node.operator == '||') {  var match = parent_pattern.exec(node.source());  if (match != null && match[1] == match[2]) { //check the number of '.parent()' match between exists and hasChildren  node.update('true')  }  }  };   var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();  parentIsObjectCheckRemovalMemory[javascript_str] = result;  return result; }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","escapeSingleQuotes","{  string_literal = string_literal.replace(singleQuoteRegex, '\\'');  return string_literal }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","escapeEscapes","{  string_literal = string_literal.replace(escapeRegex, '\\\\');  return string_literal }"
"../test-repos/firebase_blaze_compiler/src/optimizer.ts","sanitizeQuotes","{  var simplify_fn = function(node){  if (node.type == 'Literal') {  //double quoted string needs to be changed to single quotes  if (node.raw.indexOf(''') == 0) node.update(''' + escapeSingleQuotes(node.value) + ''')  }  };   return falafel(javascript_str.toString(), {}, simplify_fn).toString(); }"
"../test-repos/firebase_blaze_compiler/src/blaze.ts","load_yaml","{  var yaml_text = fs.readFileSync(filepath, {encoding: 'utf8'}).toString();  return Json.parse_yaml(yaml_text); }"
"../test-repos/firebase_blaze_compiler/src/blaze.ts","load_json","{  var json_text = fs.readFileSync(filepath, {encoding: 'utf8'}).toString();  return Json.parse(json_text); }"
"../test-repos/firebase_blaze_compiler/src/blaze.ts","load_yaml_collection","{  var yaml_text = fs.readFileSync(filepath, {encoding: 'utf8'}).toString();  Json.parse_yaml_collection(yaml_text, cb); }"
"../test-repos/firebase_blaze_compiler/src/blaze.ts","validate_rules","{  tv4.addSchema('http://firebase.com/schema/types/object#', this.load_yaml(root + 'schema/types/object.yaml').toJSON());  tv4.addSchema('http://firebase.com/schema/types/string#', this.load_yaml(root + 'schema/types/string.yaml').toJSON());  tv4.addSchema('http://firebase.com/schema/types/boolean#',this.load_yaml(root + 'schema/types/boolean.yaml').toJSON());  tv4.addSchema('http://firebase.com/schema/types/number#', this.load_yaml(root + 'schema/types/number.yaml').toJSON());  tv4.addSchema('http://firebase.com/schema/types/any#', this.load_yaml(root + 'schema/types/any.yaml').toJSON());   tv4.addSchema('http://firebase.com/schema#', this.load_yaml(root + 'schema/schema.yaml').toJSON());  tv4.addSchema('http://json-schema.org/draft-04/schema#', fs.readFileSync(root + 'schema/jsonschema', {encoding: 'utf8'}).toString());   var valid: boolean = tv4.validate(rules.toJSON(), this.rules_schema.toJSON(), true, true);  if (!valid){  throw error.validation(  rules,  this.rules_schema,  'blaze file',  'blaze schema',  tv4.error)  .source(rules.lookup(tv4.error.dataPath.split('/')))  .on(new Error())  }   if (tv4.getMissingUris().length != 0){  throw error.missingURI(tv4.getMissingUris()).on(new Error());  }   return valid; }"
"../test-repos/firebase_blaze_compiler/src/java/java.ts","generate","{  console.log('generating', TARGET);  DEBUG = debug;   //big array we put all the output in  var lines: string[] = [];   generate_class(model.schema.root, lines);   fs.writeFile(TARGET, lines.join('\n'));  }"
"../test-repos/firebase_blaze_compiler/src/java/java.ts","generate_class","{  if (DEBUG) console.log('generate_class', schema);   //big array we put all the output in  var lines: string[] = [];    }"
"../test-repos/firebase_blaze_compiler/src/compiler.ts","compileJSON","{  //check user's JSON meets JSON schema spec of rule file  try {  var ok = blaze.validate_rules(json);  if (globals.debug){  console.log('\ninput:');  console.log(JSON.stringify(json.toJSON()));  }   //convert users rule file into a model  var model: blaze.Rules = blaze.Rules.parse(json.asObject());    model.inflateSchema();   //1st pass of compiler,  //metaschema generate constraints for schema  schema.annotate(model);   if(globals.debug){  console.log('\nannotated model:');  console.log(model.schema.root);  }   //2nd pass of compiler  //constraints pushed into leaves  schema.pushDownConstraints(model);  if(globals.debug){  console.log('\npushed down constraint model:');  console.log(model.schema.root);  }   //3rd pass of compiler  //constraints pulled up from leaves  schema.pullUpConstraints(model);  if (globals.debug){  console.log('\npulled up constraint model:');  console.log(model.schema.root);  }   //4th pass pass of compiler, unifying ACL and the schema  schema.combineACL(model);  if (globals.debug){  console.log('\n ACL and schema:');  console.log(model.schema.root);  }  //generate output in security rules 1.0  var code: string = schema.generateRules(model);   //print generate code out  if (globals.debug){  console.log('\ngenerated code:');  console.log(code);  }  //write to file  console.log('\nwriting rules.json');  fs.writeFileSync('rules.json', code);  model.code = code;  return model;   } catch (error){  var source: Json.JValue = <Json.JValue>error.source;  var msg: string = error.message;   if (source) {  console.error('error line ' + source.start.row() + ':' + source.start.col());  console.error(source.toJSON());  }   if (globals.debug) console.error(error.stack); //includes writing message  else{  console.error(msg);  console.error('run with -v option for fuller error messages')  }   return null;  } }"
"../test-repos/firebase_blaze_compiler/src/compiler.ts","compile","{  globals.debug = debug;  //convert to JSON  if (path.slice(path.length-5) == '.json'){  var json: Json.JValue = blaze.load_json(path);  } else {  var json: Json.JValue = blaze.load_yaml(path);  }  return compileJSON(json);  }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","success","{  return Promise.resolve().then(() => true); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","failure","{  return Promise.reject(reason); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","evaluate","{  if (value) {  return success();  }  return failure(errMsg); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","expectEq","{  return evaluate(  left === right,  JSON.stringify(left) + ' does not equal ' + JSON.stringify(right)); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","expectDeepEq","{  return evaluate(  _.isEqual(left, right),  JSON.stringify(left) + ' does not equal ' + JSON.stringify(right)); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","expectMatches","{  return evaluate(  input.match(regexp),  'Input '' + input + '' did not match regexp '' + regexp + '''); }"
"../test-repos/firebase_firebase-functions/integration_test/functions/src/testing.ts","expectReject","{  return function (event) {  return Promise.resolve()  .then(() => f(event))  .then(  () => {  throw new Error('Test should have returned a rejected promise');  },  () => true, // A rejection is what we expected, and so is a positive result.  );  }; }"
"../test-repos/firebase_firebase-functions/spec/providers/firestore.spec.ts","expectedTrigger","{  return {  eventTrigger: {  resource,  eventType: `providers/${firestore.provider}/eventTypes/${eventType}`,  },  };  }"
"../test-repos/firebase_firebase-functions/spec/providers/firestore.spec.ts","constructEvent","{  return {  'data': {  'oldValue': oldValue,  'value': value,  },  'resource': 'projects/pid/databases/(default)/documents/collection/123',  };  }"
"../test-repos/firebase_firebase-functions/spec/providers/firestore.spec.ts","createOldValue","{  return constructValue({  'key1': {  'booleanValue': false,  },  'key2': {  'integerValue': '111',  },  });  }"
"../test-repos/firebase_firebase-functions/spec/providers/firestore.spec.ts","createValue","{  return constructValue({  'key1': {  'booleanValue': true,  },  'key2': {  'integerValue': '123',  },  });  }"
"../test-repos/firebase_firebase-functions/spec/support/helpers.ts","fakeConfig","{  return _.extend({}, data, {  firebase: {  databaseURL: 'https://subdomain.firebaseio.com',  storageBucket: 'bucket',  credential: {  getAccessToken: () => {  return Promise.resolve({  expires_in: 1000,  access_token: 'fake',  });  },  getCertificate: () => Promise.resolve(),  },  },  }); }"
"../test-repos/firebase_firebase-functions/spec/support/helpers.ts","unsetSingleton","{  delete config.singleton; }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockCredentialFetch","{  return nock('http://metadata.google.internal')  .get('/computeMetadata/v1beta1/instance/service-accounts/default/token')  .reply(200, tokenToReturn); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockRCVariableFetch","{  let mock: nock.Scope = nock('https://runtimeconfig.googleapis.com')  .get(`/v1beta1/projects/${projectId}/configs/firebase/variables/${varName}`);   if (token) {  mock = mock.matchHeader('Authorization', `Bearer ${token}`);  }   return mock.reply(200, {text: JSON.stringify(data)}); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockMetaVariableWatch","{  let mock: nock.Scope = nock('https://runtimeconfig.googleapis.com')  .post(`/v1beta1/projects/${projectId}/configs/firebase/variables/meta:watch`);   if (token) {  mock = mock.matchHeader('Authorization', `Bearer ${token}`);  }   return mock.reply(200, {  updateTime,  state: 'UPDATED',  text: JSON.stringify(data),  }); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockMetaVariableWatchTimeout","{  let mock: nock.Scope = nock('https://runtimeconfig.googleapis.com')  .post(`/v1beta1/projects/${projectId}/configs/firebase/variables/meta:watch`);   if (token) {  mock = mock.matchHeader('Authorization', `Bearer ${token}`);  }   return mock.delay(delay).reply(502); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockCreateToken","{  let mock: nock.Scope = nock('https://accounts.google.com').post('/o/oauth2/token');  return mock.reply(200, token); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockRefreshToken","{  let mock: nock.Scope = nock('https://www.googleapis.com').post('/oauth2/v4/token');  return mock.reply(200, token); }"
"../test-repos/firebase_firebase-functions/spec/fixtures/http.ts","mockMetadataServiceToken","{  let mock: nock.Scope = nock('http://metadata.google.internal')  .get('/computeMetadata/v1beta1/instance/service-accounts/default/token');  return mock.reply(200, token); }"
"../test-repos/firebase_firebase-functions/src/testing.ts","whereAreTheBugs","{  return 'Klendathu'; }"
"../test-repos/firebase_firebase-functions/src/cloud-functions.ts","_makeParams","{  if (!event.resource) { // In unit testing, 'resource' may not be populated for a test event.  return event.params || {};  }   let wildcards = triggerResource.match(WILDCARD_REGEX);  let params = {};  if (wildcards) {  let triggerResourceParts = _.split(triggerResource, '/');  let eventResourceParts = _.split(event.resource, '/');  _.forEach(wildcards, wildcard => {  let wildcardNoBraces = wildcard.slice(1,-1);   let position = _.indexOf(triggerResourceParts, wildcard);  params[wildcardNoBraces] = eventResourceParts[position];  });  }   return params; }"
"../test-repos/firebase_firebase-functions/src/cloud-functions.ts","makeCloudFunction","{  let cloudFunction: any = async (event: Event<any>) => {  try {  before(event);   let typedEvent: Event<EventData> = _.cloneDeep(event);  typedEvent.data = dataConstructor(event);  typedEvent.params = _makeParams(event, resource) || {};   let promise = handler(typedEvent);  if (typeof promise === 'undefined') {  console.warn('Function returned undefined, expected Promise or value');  }  return await promise;  } finally {  after(event);  }  };   cloudFunction.__trigger = {  eventTrigger: {  resource,  eventType: `providers/${provider}/eventTypes/${eventType}`,  },  };   return cloudFunction; }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","database","{  return new DatabaseBuilder(posix.join('projects', process.env.GCLOUD_PROJECT, 'databases', database)); }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","namespace","{  return database().namespace(namespace); }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","document","{  return database().document(path); }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","isDeltaDocumentSnapshot","{  return 'exists' in data; }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","getValueProto","{  let data = event.data;  if (_.isEmpty(_.get(data, valueFieldName))) {  // Firestore#snapshot_ takes resource string instead of proto for a non-existent snapshot  return event.resource;  }  let proto = {  fields: _.get(data, [valueFieldName, 'fields'], {}),  createTime: dateToTimestampProto(_.get(data, [valueFieldName, 'createTime'])),  updateTime: dateToTimestampProto(_.get(data, [valueFieldName, 'updateTime'])),  name: _.get(data, [valueFieldName, 'name'], event.resource),  };  return proto; }"
"../test-repos/firebase_firebase-functions/src/providers/firestore.ts","dataConstructor","{  if (isDeltaDocumentSnapshot(raw.data)) {  return raw.data;  }  if (!firestoreInstance) {  firestoreInstance = firebase.firestore(apps().admin);  }  let valueProto = getValueProto(raw, 'value');  let readTime = dateToTimestampProto(_.get(raw.data, 'value.readTime'));  let snapshot = firestoreInstance.snapshot_(valueProto, readTime, 'json') as DeltaDocumentSnapshot;  Object.defineProperty(snapshot, 'previous', {  get: () => {  let oldValueProto = getValueProto(raw, 'oldValue');  let oldReadTime = dateToTimestampProto(_.get(raw.data, 'oldValue.readTime'));  return firestoreInstance.snapshot_(oldValueProto, oldReadTime, 'json') as DeltaDocumentSnapshot;  },  });  return snapshot; }"
"../test-repos/firebase_firebase-functions/src/providers/crashlytics.ts","issue","{  return new IssueBuilder('projects/' + process.env.GCLOUD_PROJECT); }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","event","{  return new AnalyticsEventBuilder(  'projects/' + process.env.GCLOUD_PROJECT + '/events/' + analyticsEventType); }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","copyFieldTo","{  if (from[fromField] !== undefined) {  to[toField] = transform(from[fromField]);  } }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","copyField","{  copyFieldTo(from, to, field, field, transform); }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","copyFields","{  for (let field of fields) {  copyField(from, to, field);  } }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","unwrapValueAsString","{  let key: string = _.keys(wrapped)[0];  return _.toString(wrapped[key]); }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","unwrapValue","{  let key: string = _.keys(wrapped)[0];  let value: string = unwrapValueAsString(wrapped);  return _.includes(xValueNumberFields, key) ? _.toNumber(value) : value; }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","copyTimestampToMillis","{  if (from[fromName] !== undefined) {  to[toName] = <any>_.round(from[fromName] / 1000);  } }"
"../test-repos/firebase_firebase-functions/src/providers/analytics.ts","copyTimestampToString","{  if (from[fromName] !== undefined) {  to[toName] = <any>(new Date(from[fromName] / 1000)).toISOString();  } }"
"../test-repos/firebase_firebase-functions/src/providers/pubsub.ts","topic","{  if (topic.indexOf('/') !== -1) {  throw new Error('Topic name may not have a /');  }   return new TopicBuilder(`projects/${process.env.GCLOUD_PROJECT}/topics/${topic}`); }"
"../test-repos/firebase_firebase-functions/src/providers/storage.ts","bucket","{  if (!/^[a-z\d][a-z\d\\._-]{1,230}[a-z\d]$/.test(bucket)) {  throw new Error('Invalid bucket name ${bucket}');  }  return new BucketBuilder(`projects/_/buckets/${bucket}`); }"
"../test-repos/firebase_firebase-functions/src/providers/storage.ts","object","{  return bucket(config().firebase.storageBucket).object(); }"
"../test-repos/firebase_firebase-functions/src/providers/database.ts","instance","{  return new InstanceBuilder(instance); }"
"../test-repos/firebase_firebase-functions/src/providers/database.ts","ref","{  const normalized = normalizePath(path);  const databaseURL = config().firebase.databaseURL;  if (!databaseURL) {  throw new Error('Missing expected config value firebase.databaseURL, ' +  'config is actually' + JSON.stringify(config()));  }  const match = databaseURL.match(databaseURLRegex);  if (!match) {  throw new Error('Invalid value for config firebase.databaseURL: ' + databaseURL);  }  const subdomain = match[1];  let resource = `projects/_/instances/${subdomain}/refs/${normalized}`;  return new RefBuilder(apps(), resource); }"
"../test-repos/firebase_firebase-functions/src/providers/database.ts","resourceToInstanceAndPath","{  let resourceRegex = `projects/([^/]+)/instances/([^/]+)/refs(/.+)?`;  let match = resource.match(new RegExp(resourceRegex));  if (!match) {  throw new Error(`Unexpected resource string for Firebase Realtime Database event: ${resource}. ` +  'Expected string in the format of 'projects/_/instances/{firebaseioSubdomain}/refs/{ref=**}'');  }  let [, project, dbInstanceName, path] = match;  if (project !== '_') {  throw new Error(`Expect project to be '_' in a Firebase Realtime Database event`);  }  let dbInstance = 'https://' + dbInstanceName + '.firebaseio.com';  return [dbInstance, path]; }"
"../test-repos/firebase_firebase-functions/src/providers/https.ts","onRequest","{  // lets us add __trigger without altering handler:  let cloudFunction: any = (req, res) => { handler(req, res); };  cloudFunction.__trigger = {httpsTrigger: {}};   return cloudFunction; }"
"../test-repos/firebase_firebase-functions/src/providers/auth.ts","user","{  return new UserBuilder('projects/' + process.env.GCLOUD_PROJECT); }"
"../test-repos/firebase_firebase-functions/src/utils.ts","normalizePath","{  if (!path) {  return '';  }  return path.replace(/^\//,'').replace(/\/$/, ''); }"
"../test-repos/firebase_firebase-functions/src/utils.ts","pathParts","{  if (!path || path === '' || path === '/') {  return [];  }  return normalizePath(path).split('/'); }"
"../test-repos/firebase_firebase-functions/src/utils.ts","joinPath","{  return pathParts(base).concat(pathParts(child)).join('/'); }"
"../test-repos/firebase_firebase-functions/src/utils.ts","applyChange","{  // if not mergeable, don't merge  if (!_.isPlainObject(dest) || !_.isPlainObject(src)) {  return dest;  }   return pruneNulls(_.merge({}, src, dest)); }"
"../test-repos/firebase_firebase-functions/src/utils.ts","pruneNulls","{  for (let key in obj) {  if (obj[key] === null) {  delete obj[key];  } else if (_.isPlainObject(obj[key])) {  pruneNulls(obj[key]);  }  }  return obj; }"
"../test-repos/firebase_firebase-functions/src/utils.ts","valAt","{  if (source === null) {  return null;  } else if (typeof source !== 'object') {  return path ? null : source;  }   let parts = pathParts(path);  if (!parts.length) {  return source;  }   let cur = source;  let leaf;  while (parts.length) {  let key = parts.shift();  if (cur[key] === null || leaf) {  return null;  } else if (typeof cur[key] === 'object') {  if (parts.length) {  cur = cur[key];  } else {  return cur[key];  }  } else {  leaf = cur[key];  }  }  return leaf; }"
"../test-repos/firebase_firebase-functions/src/encoder.ts","dateToTimestampProto","{  if (typeof timeString === 'undefined') {  return;  }  let date = new Date(timeString);  let seconds = Math.floor(date.getTime() / 1000);  let nanos = 0;  if (timeString.length > 20) {  const nanoString = timeString.substring(20, timeString.length - 1);  const trailingZeroes = 9 - nanoString.length;  nanos = parseInt(nanoString, 10) * Math.pow(10, trailingZeroes);  }  return { seconds, nanos }; }"
"../test-repos/firebase_firebase-functions/src/apps.ts","apps","{  if (typeof apps.singleton === 'undefined') {  apps.init(config());  }  return apps.singleton; }"
"../test-repos/firebase_firebase-functions/src/apps.ts","delay","{  return new Promise(resolve => {  setTimeout(resolve, delay);  });  }"
"../test-repos/firebase_firebase-functions/src/config.ts","config","{  if (typeof config.singleton === 'undefined') {  const cred = firebase.credential.applicationDefault();  init(cred);  }  return config.singleton; }"
"../test-repos/firebase_firebase-functions/src/config.ts","init","{  let firebaseEnv = {};  if (process.env.FIREBASE_PROJECT) {  firebaseEnv = { firebase: JSON.parse(process.env.FIREBASE_PROJECT) };  }  let merged = firebaseEnv;   try {  merged = _.merge({}, JSON.parse(process.env.CLOUD_RUNTIME_CONFIG), firebaseEnv);  } catch (e) {  try {  let path = process.env.CLOUD_RUNTIME_CONFIG || '../../../.runtimeconfig.json';  merged = _.merge({}, require(path), firebaseEnv);  } catch (e) {  // Do nothing  }  }  if (!hasFirebase(merged)) {  throw new Error('Firebase config variables are not available. ' +  'Please use the latest version of the Firebase CLI to deploy this function.');  }   _.set(merged, 'firebase.credential', credential);  config.singleton = merged; }"
"../test-repos/firebase_firebase-functions/src/config.ts","hasFirebase","{  return _.has(merged, 'firebase'); }"
"../test-repos/funfix_funfix/test-common/setoid-tests.ts","setoidCheck","{   const laws = lawsRef || new SetoidLaws<A>(F)  const eq = (p: Equiv<boolean>) => p.lh === p.rh   jv.property('setoid.reflexivity', genA,  x => eq(laws.reflexivity(x)))   jv.property('setoid.symmetry', genA, genA,  (x, y) => eq(laws.symmetry(x, y)))   jv.property('setoid.transitivity', genA, genA, genA,  (x, y, z) => eq(laws.transitivity(x, y, z))) }"
"../test-repos/funfix_funfix/test-common/monad-tests.ts","monadCheck","{   const laws = lawsRef || new MonadLaws<F>(F)  if (includeSuperTypes) {  applicativeCheck(genFA, genAtoB, genBtoC, genFAtoB, genFBtoC, genA, check, F, laws)  chainRecCheck(genFA, genFB, genFC, genAtoB, genBtoC, genFAtoB, genFBtoC, genA, check, F, laws, false)  }   jv.property('monad.left_identity', genA, jv.fun(genFB),  (a, f) => check(laws.monadLeftIdentity(a, f)))   jv.property('monad.right_identity', genFA,  fa => check(laws.monadRightIdentity(fa)))   jv.property('monad.map', genFA, genAtoB,  (fa, f) => check(laws.monadMap(fa, f)))   jv.property('monad.chainRec_stack_safety',  () => check(laws.monadChainRecStackSafety())) }"
"../test-repos/funfix_funfix/test-common/apply-tests.ts","applyCheck","{   const laws = lawsRef || new ApplyLaws<F>(F)  if (includeSuperTypes) {  functorCheck(genFA, genAtoB, genBtoC, check, F, laws)  }   jv.property('apply.composition', genFA, genFAtoB, genFBtoC,  (fa, fab, fbc) => check(laws.applyComposition(fa, fab, fbc))) }"
"../test-repos/funfix_funfix/test-common/functor-tests.ts","functorCheck","{   const laws = lawsRef || new FunctorLaws<F>(F)   jv.property('functor.identity', genFA,  fa => check(laws.identity(fa)))   jv.property('functor.composition', genFA, genAtoB, genBtoC,  (fa, g, f) => check(laws.composition(fa, f, g))) }"
"../test-repos/funfix_funfix/test-common/chain-tests.ts","chainCheck","{   const laws = lawsRef || new ChainLaws<F>(F)  if (includeSuperTypes) {  applyCheck(genFA, genAtoB, genBtoC, genFAtoB, genFBtoC, check, F, laws)  }   jv.property('chain.associativity', genFA, jv.fun(genFB), jv.fun(genFC),  (fa, fab, fbc) => check(laws.chainAssociativity(fa, fab, fbc)))   jv.property('chain.ap', genFA, genFAtoB,  (fa, fab) => check(laws.chainConsistentApply(fab, fa))) }"
"../test-repos/funfix_funfix/test-common/applicative-tests.ts","applicativeCheck","{   const laws = lawsRef || new ApplicativeLaws<F>(F)  if (includeSuperTypes) {  applyCheck(genFA, genAtoB, genBtoC, genFAtoB, genFBtoC, check, F, laws)  }   jv.property('applicative.identity', genFA,  (fa) => check(laws.applicativeIdentity(fa)))   jv.property('applicative.homomorphism', genA, genAtoB,  (a, f) => check(laws.applicativeHomomorphism(a, f)))   jv.property('applicative.interchange', genA, genFAtoB,  (a, ff) => check(laws.applicativeInterchange(a, ff)))   jv.property('applicative.map', genFA, genAtoB,  (fa, f) => check(laws.applicativeMap(fa, f))) }"
"../test-repos/funfix_funfix/test-common/chain-rec-tests.ts","chainRecCheck","{   const laws = lawsRef || new ChainRecLaws<F>(F)  chainCheck(genFA, genFB, genFC, genAtoB, genBtoC, genFAtoB, genFBtoC, check, F, lawsRef, includeSuperTypes)   jv.property('chainRec.consistency', genA, jv.fun(genFA),  (a, f) => check(laws.chainRecConsistency(a, f))) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/scheduler.test.ts","testErrorReporting","{  return () => {  const dummy = new DummyError('dummy')  let reported: any = null   const p = new Promise<void>((resolve, _) => {  const ec = new GlobalScheduler(true, ExecutionModel.global.get(),  (r: any) => {  reported = r  resolve(undefined)  })   f(ec, () => { throw dummy })  })   return p.then(_ => {  assert.ok(reported, 'reported != null')  assert.equal(reported.message, 'dummy')  })  }  }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","ok","{  return fns.ok(cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","not","{  return fns.ok(!cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","throws","{  return fns.throws(thunk, message) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","equal","{  return fns.ok(is(lh, rh), `${toString(lh)} == ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","notEqual","{  return fns.ok(!is(lh, rh), `${toString(lh)} != ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","fail","{  return fns.fail(message) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/asserts.ts","toString","{  try {  return JSON.stringify(obj)  } catch (e) {  return obj.toString()  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","loop","{  if (n <= 0) return Future.pure(n, ec)  return Future.pure(n, ec).flatMap(x => loop(x - 1))  }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","loop","{  return Future.pure(n, ec).flatMap(n => {  if (n > 0) {  effect += 1  return loop(n - 1, acc + 1)  }  return Future.pure(acc, ec)  })  }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","loop","{  if (n <= 0) return Future.pure(n, s)  return Future.of(() => n, s).flatMap(x => loop(x - 1))  }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","check","{  ec.tick(Duration.days(99))  return is((eq.lh as Future<A>).value(), (eq.rh as Future<A>).value())  }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","asyncSample","{  let sum = 0  for (let i = 0; i < n; i++) {  sum += await Future.of(() => i)  }  return sum }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/future.test.ts","asyncErrorSample","{  const dummy = new DummyError('dummy')  let result = 0   try {  result = await Future.of<number>(() => { throw dummy })  } catch (e) {  if (e === dummy)  result = n + 10  else  throw e  }  return result }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/cancelable.test.ts","ref","{ return Cancelable.of(() => { throw dummy }) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/instances.ts","arbFuture","{  return arbFutureFrom(jv.int32, sc) }"
"../test-repos/funfix_funfix/packages/funfix-exec/test/ts/instances.ts","arbFutureFrom","{  return jv.pair(jv.int32, arbA).smap(  arr => {  const [i, a] = arr  switch (Math.abs(i % 7)) {  case 0:  return Future.pure(a, sc)  case 1:  return Future.raise(new DummyError(`dummy${a}`), sc)  case 2:  return Future.of(() => a, sc)  case 3:  return Future.of(() => { throw new DummyError(`dummy${a}`) }, sc)  case 4:  return Future.of(() => a, sc).map(x => x)  case 5:  return Future.of(() => a, sc).flatMap(x => Future.pure(x, sc))  default:  return Future.create(cb => {  sc.trampoline(() => cb(Success(a)))  }, sc)  }  },  () => undefined  ) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","genericTransformWith","{   const defer = FutureMaker.empty<B>(scheduler)  const cRef = new ChainedCancelable(cancelable)   self.onComplete(tryA => {  let fb: Future<B>  try {  fb = tryA.fold(failure, success)  } catch (e) {  fb = Future.raise(e)  }   // If the resulting Future is already completed, there's no point  // in treating it as being cancelable  if (fb.value().isEmpty()) {  const fbb = fb as any  const cNext = fbb._cancelable   if (cNext && cNext instanceof ChainedCancelable) {  // Trick we are doing to get rid of extraneous memory  // allocations, otherwise we can leak memory  cNext.chainTo(cRef)  } else if (cNext && !(cNext instanceof DummyCancelable)) {  cRef.update(cNext)  }  } else {  // GC purposes  cRef.clear()  }   if (fb instanceof AsyncFuture) {  fb['_state'].chainTo(defer['_state'], scheduler)  } else {  fb.onComplete(defer.tryComplete)  }  })   return defer.future(cRef) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","promiseThen","{   return value => {  if (typeof f !== 'function') return alt(value)   const fb = f(value)  if (!fb) return Future.pure(value, ec)   if (typeof (fb as any).then === 'function')  return Future.fromPromise(fb as IPromiseLike<R>, ec)  else  return Future.pure(fb as R, ec)  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureCancelAll","{  const errors = []  for (let i = 0; i < list.length; i++) {  if (i !== skip)  try { list[i].cancel() } catch (e) { errors.push(e) }  }   if (errors.length > 0) {  for (const e of errors) ec.reportFailure(e)  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureIterableToArray","{  if (!values) return []  if (Object.prototype.toString.call(values) === '[object Array]')  return values as Future<A>[]   const arr: Future<A>[] = []  try {  const cursor = values[Symbol.iterator]()   while (true) {  const item = cursor.next()  if (item.value) arr.push(item.value)  if (item.done) break  }   return arr  } catch (e) {  futureCancelAll(arr, ec)  throw e  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureSequence","{  return Future.create<A[]>(cb => {  try {  // This can throw, handling error below  const futures = futureIterableToArray(values, ec)  // Short-circuit in case the list is empty, otherwise the  // futureSequenceLoop fails (must be non-empty as an invariant)  if (futures.length === 0) return cb(Success([]))  const cRef = Cancelable.of(() => futureCancelAll(futures, ec))   // Creating race condition  let isDone = false  let finishedCount = 0  let finalArray: A[] = []   for (let index = 0; index < futures.length; index++) {  const fi = index  const fa = futures[index]   fa.onComplete(result => {  finishedCount += 1   if (result.isSuccess()) {  if (!isDone) {  finalArray[fi] = result.get()  isDone = finishedCount === futures.length  if (isDone) cb(Success(finalArray))  }  } else {  if (!isDone) {  isDone = true  cRef.cancel()  cb(result as any)  } else {  ec.reportFailure(result.failed().get())  }  }  })  }   return cRef  } catch (e) {  // If an error happens here, it means the conversion from iterable to  // array failed, and the futures we've seen are already canceled  cb(Failure(e))  }  }, ec) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureFirstCompletedOf","{  return Future.create<A>(cb => {  try {  // This can throw, handling error below  const futures = futureIterableToArray(iterable, ec)  // Short-circuit in case the list is empty, otherwise the  // futureSequenceLoop fails (must be non-empty as an invariant)  if (futures.length === 0) return cb(Failure(new IllegalArgumentError('empty list of futures')))   // Creating race condition  let isDone = false   for (let index = 0; index < futures.length; index++) {  const fi = index  const fa = futures[index]   fa.onComplete(result => {  if (!isDone) {  isDone = true  futureCancelAll(futures, ec, fi)  cb(result)  } else if (result.isFailure()) {  ec.reportFailure(result.failed().get())  }  })  }   return Cancelable.of(() => futureCancelAll(futures, ec))  } catch (e) {  // If an error happens here, it means the conversion from iterable to  // array failed, and the futures we've seen are already canceled  cb(Failure(e))  }  }, ec) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureTraverse","{   if (parallelism <= 0) {  throw new IllegalArgumentError(`parallelism <= 0`)  }  return Future.of(() => iterableToArray(list), ec)  .flatMap(values => futureTraverseLoop(values, f, parallelism, ec, 0, [])) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/future.ts","futureTraverseLoop","{   if (index >= list.length) return Future.pure(result, ec)  let batch: Future<B>[] = []  let length = 0   try {  while (index < list.length && length < parallelism) {  batch.push(f(list[index++]))  length += 1  }   const fa = Future.sequence(batch, ec).map(b => {  for (let i = 0; i < b.length; i++) result.push(b[i])  })   if (index >= list.length) {  // We are done, signal final result  return fa.map(() => result)  } else {  // Continue with the next batch  return fa.flatMap(() => futureTraverseLoop(list, f, parallelism, ec, index, result))  }  } catch (e) {  // Batch generation triggered an error  futureCancelAll(batch, ec)  return Future.raise(e)  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/scheduler.ts","safeRunnable","{  return () => { try { r() } catch (e) { reporter(e) } } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/internals.ts","arrayBSearchInsertPos","{   return search => {  let minIndex = 0  let maxIndex = array.length - 1   while (minIndex <= maxIndex) {  const index = (minIndex + maxIndex) / 2 | 0  const current = f(array[index])  const next = index + 1 <= maxIndex ? f(array[index + 1]) : undefined   if (current <= search && (next === undefined || search < next)) {  return index + 1  } else if (current <= search) {  minIndex = index + 1  } else { /* if (current > search) */  maxIndex = index - 1  }  }   return 0  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/internals.ts","iterableToArray","{  if (!values) return []  if (Object.prototype.toString.call(values) === '[object Array]')  return values as A[]   const cursor = values[Symbol.iterator]()  const arr: A[] = []   while (true) {  const item = cursor.next()  if (item.value) arr.push(item.value)  if (item.done) return arr  } }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/internals.ts","log2","{  return Math.log(x) / lnOf2 }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/internals.ts","nextPowerOf2","{  if (nr < 0) throw new IllegalArgumentError('nr must be positive')  const bit = Math.ceil(log2(nr))  return 1 << (bit > 30 ? 30 : (bit & bit)) }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/time.ts","x","{  if (d > over) return MAX  if (d < -over) return MIN  return d * m }"
"../test-repos/funfix_funfix/packages/funfix-exec/src/time.ts","cmp","{  const n = s.unit.convert(o.duration, o.unit)  return n === s.duration  }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","ok","{  return fns.ok(cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","not","{  return fns.ok(!cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","throws","{  return fns.throws(thunk, message) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","equal","{  return fns.ok(is(lh, rh), `${toString(lh)} == ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","notEqual","{  return fns.ok(!is(lh, rh), `${toString(lh)} != ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","fail","{  return fns.fail(message) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/asserts.ts","toString","{  try {  return JSON.stringify(obj)  } catch (e) {  return obj.toString()  } }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/internals.test.ts","arbBox1","{  return arbA.smap(a => new Box1(a), box => box.value) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/internals.test.ts","arbBox2","{  return arbA.smap(a => new Box2(a), box => box.value) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/instances.ts","arbOpt","{  return jv.pair(jv.int32, arbA).smap(  tuple => {  const [i, a] = tuple  return i % 3 !== 0 ? Some(a) : None  },  opt => {  return opt.nonEmpty()  ? [1, opt.value]  : [0, undefined]  }  ) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/instances.ts","arbEither","{  return jv.pair(jv.int32, arbR).smap(  tuple => {  const [l, r] = tuple  return l % 3 !== 0 ? Either.right(r) : Either.left(l)  },  either => {  return either.isLeft()  ? [either.value, undefined as any]  : [1, either.value]  }  ) }"
"../test-repos/funfix_funfix/packages/funfix-core/test/ts/instances.ts","arbTry","{  return jv.pair(jv.int32, arbA).smap(  tuple => {  const [i, a] = tuple  return i % 3 !== 0 ? Success(a) : Failure(i)  },  opt => {  return opt.isSuccess()  ? [1, opt.value]  : [opt.failed().get() as number, undefined]  }  ) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/disjunctions.ts","Left","{  return new TLeft(value) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/disjunctions.ts","Right","{  return new TRight(value) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/disjunctions.ts","Some","{  return new TSome(value) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/disjunctions.ts","Success","{  return new TSuccess(value) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/disjunctions.ts","Failure","{  return new TFailure(e) }"
"../test-repos/funfix_funfix/packages/funfix-core/src/internals.ts","convertToMethod","{  return function (this: any) {  const args = Array.prototype.slice.call(arguments)  args.push(this)  return f.apply(undefined, args)  } }"
"../test-repos/funfix_funfix/packages/funfix-core/src/internals.ts","fantasyLandRegister","{   const c = cls as any  const p = c.prototype   const fl = 'fantasy-land/'  const equals = 'equals'  const flEquals = fl + equals  const map = 'map'  const flMap = fl + map  const ap = 'ap'  const flAp = fl + ap  const flOf = fl + 'of'  const chain = 'chain'  const flChain = fl + chain  const chainRec = 'chainRec'  const flChainRec = fl + chainRec   // Setoid  if (p[equals]) {  p[flEquals] = p[equals]  } else {  /* istanbul ignore else */  if (setoid) p[flEquals] = convertToMethod(setoid.equals)  }  // Functor  if (p[map]) {  p[flMap] = p[map]  } else {  /* istanbul ignore else */  if (monad) p[flMap] = convertToMethod(monad.map)  }  // Apply  if (p[ap]) {  p[flAp] = p[ap]  } else {  /* istanbul ignore else */  if (monad) p[flAp] = convertToMethod(monad.ap)  }  // Applicative  if (c['pure']) {  c[flOf] = c['pure']  } else {  /* istanbul ignore else */  if (monad) c[flOf] = monad.of  }  // Chain  if (p[chain]) {  p[flChain] = p[chain]  } else {  /* istanbul ignore else */  if (monad) p[flChain] = convertToMethod(monad.chain)  }  // ChainRec  if (c[chainRec]) {  c[flChainRec] = c[chainRec]  } else {  /* istanbul ignore else */  if (monad) c[flChainRec] = monad.chainRec  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","ok","{  return fns.ok(cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","not","{  return fns.ok(!cond, message) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","throws","{  return fns.throws(thunk, message) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","equal","{  return fns.ok(is(lh, rh), `${toString(lh)} == ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","notEqual","{  return fns.ok(!is(lh, rh), `${toString(lh)} != ${toString(rh)}`) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","fail","{  return fns.fail(message) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/asserts.ts","toString","{  try {  return JSON.stringify(obj)  } catch (e) {  return obj.toString()  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/eval.test.ts","loop","{  return n <= 0 ? ref :  ref.flatMap(a => loop(n - 1, Eval.now(a + 1)))  }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/instances.ts","arbEval","{  return jv.pair(jv.number, arbA).smap(  v => {  switch (Math.abs(v[0] % 7)) {  case 0:  return Eval.now(v[1])  case 1:  return Eval.always(() => v[1])  case 2:  return Eval.once(() => v[1])  case 3:  return Eval.suspend(() => Eval.now(v[1]))  case 4:  return Eval.always(() => v[1]).map(x => x)  case 5:  return Eval.always(() => v[1]).flatMap(Eval.pure)  default:  return Eval.now(0).flatMap(() => Eval.now(v[1]))  }  },  e => [0, e.get()]  ) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/instances.ts","arbIO","{  return jv.pair(jv.number, arbA).smap(  v => {  switch (Math.abs(v[0] % 11)) {  case 0:  return IO.now(v[1])  case 1:  return IO.raise(v[1])  case 2:  return IO.always(() => v[1])  case 3:  return IO.once(() => v[1])  case 4:  return IO.suspend(() => IO.now(v[1]))  case 5:  return IO.async<A>((ec, cb) => cb(Success(v[1])))  case 6:  return IO.async<A>((ec, cb) => cb(Failure(v[1])))  case 7:  return IO.async<A>((ec, cb) => cb(Success(v[1]))).flatMap(IO.now)  case 8:  return IO.now(0).flatMap(() => IO.now(v[1]))  case 9:  return IO.always(() => v[1]).memoizeOnSuccess()  default:  return IO.suspend(() => IO.pure(v[1])).memoize()  }  },  io => [0, arbA.generator(0)]  ) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","signal","{  return IO.asyncUnsafe<number>((ctx, cb) => {  asyncEC.executeAsync(() => {  ctx.markAsyncBoundary()  cb(Success(n))  })  })  }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","check","{  return eq => {  const a = (eq.lh as IO<any>).run(ec)  const b = (eq.rh as IO<any>).run(ec)  ec.tick(Duration.days(99))  return is(a.value(), b.value())  }  }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","scheduler","{  return new TestScheduler(undefined, ExecutionModel.global.get()) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","flatShallowLoop","{  return f(n).flatMap(n => {  if (n <= 0) return IO.pure(n)  return flatShallowLoop(n - 1, f)  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","flatEagerLoop","{  let cursor = f(n)  for (let i = n - 1; i >= 0; i--) cursor = cursor.flatMap(x => f(x - 1))  return cursor }"
"../test-repos/funfix_funfix/packages/funfix-effect/test/ts/io.test.ts","suspendLoop","{  return IO.suspend(() => {  if (n <= 0) return IO.pure(n)  return suspendLoop(n - 1, f)  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/eval.ts","_popNextBind","{  if (bFirst) return bFirst  if (bRest && bRest.length > 0) return bRest.pop()  return null }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/eval.ts","evalRunLoop","{  let current: Current = start  let bFirst: Bind | null = null  let bRest: CallStack | null = null   while (true) {  switch (current._tag) {  case 'now':  const now = current as Now<A>  const bind = _popNextBind(bFirst, bRest)  if (!bind) return now.value  bFirst = null  current = bind(now.value)  break   case 'always':  case 'once':  current = new Now(current.get())  break   case 'suspend':  current = (current as Suspend<A>).thunk()  break   case 'flatMap':  if (bFirst) {  if (!bRest) bRest = []  bRest.push(bFirst)  }  const fm = current as FlatMap<any, any>  bFirst = fm.f  current = fm.source  break  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/eval.ts","evalSequence","{  return Eval.of(() => iteratorOf(list))  .flatMap(cursor => evalSequenceLoop([], cursor)) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/eval.ts","evalSequenceLoop","{  while (true) {  const elem = cursor.next()  const isDone = elem.done   if (elem.value) {  const io: Eval<A> = elem.value  return io.flatMap(a => {  acc.push(a)  if (isDone) return Eval.pure(acc)  return evalSequenceLoop(acc, cursor)  })  } else {  /* istanbul ignore else */  if (isDone) return Eval.pure(acc)  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioShift","{  return IO.asyncUnsafe<void>((ctx, cb) => {  (ec || ctx.scheduler).executeAsync(() => cb(Try.unit()))  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","_ioPopNextBind","{  let f: Bind | [Bind, Bind] | null | undefined = undefined  if (bFirst) f = bFirst  else if (bRest && bRest.length > 0) f = bRest.pop()  if (f) return typeof f === 'function' ? f : f[0]  return null }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","_ioFindErrorHandler","{  let cursor: any = bFirst  do {  if (cursor && typeof cursor !== 'function') return cursor[1]  cursor = bRest ? bRest.pop() : null  } while (cursor)   return null }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioExecuteAsync","{   if (!context.shouldCancel()) {  context.scheduler.batchIndex = frameIndex   const restart = rcb || new RestartCallback(context, cb)  restart.prepare(bFirst, bRest)  register(context, restart.asFunction)  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioRestartAsync","{   if (!context.shouldCancel())  context.scheduler.executeAsync(() => {  ioGenericRunLoop(start, context.scheduler, context, cb, rcb, bFirstInit, bRestInit)  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioGenericRunLoop","{   let current: Current | Try<any> = start  let bFirst: BindT | null = bFirstInit  let bRest: CallStack | null = bRestInit   const modulus = scheduler.executionModel.recommendedBatchSize - 1  let frameIndex = scheduler.batchIndex   while (true) {  if (current instanceof Try) {  if (current.isSuccess()) {  const bind = _ioPopNextBind(bFirst, bRest)  if (!bind) {  scheduler.batchIndex = frameIndex  return cb(current)  }   try {  current = bind(current.get())  } catch (e) {  current = Try.failure(e)  }  } else {  const bind = _ioFindErrorHandler(bFirst, bRest)  if (!bind) {  scheduler.batchIndex = frameIndex  return cb(current)  }   try {  current = bind((current as Try<never>).failed().get())  } catch (e) {  current = Try.failure(e)  }  }   bFirst = null  const nextIndex = (frameIndex + 1) & modulus  // Should we force an asynchronous boundary?  if (nextIndex) {  frameIndex = nextIndex  } else {  const ctx = context || new IOContext(scheduler)  /* istanbul ignore next */  const boxed = current instanceof Try ? new IOPure(current) : current  ioRestartAsync(boxed, ctx, cb, rcb, bFirst, bRest)  return ctx.connection  }  }  else switch (current._tag) {  case 'pure':  current = (current as IOPure<any>).value  break   case 'always':  current = Try.of((current as IOAlways<any>).thunk)  break   case 'once':  current = (current as IOOnce<any>).runTry()  break   case 'flatMap':  const flatM: IOFlatMap<any, any> = current as any  if (bFirst) {  if (!bRest) bRest = []  bRest.push(bFirst)  }   bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]  current = flatM.source  break   case 'async':  const async: IOAsync<any> = current as any  const ctx = context || new IOContext(scheduler)  ioExecuteAsync(async.register, ctx, cb, rcb, bFirst, bRest, frameIndex)  return ctx.connection   case 'memoize':  const mem: IOMemoize<any> = current as any  return ioStartMemoize(mem, scheduler, context, cb, bFirst, bRest, frameIndex)  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioToFutureGoAsync","{   return Future.create<any>(cb => {  const ctx = new IOContext(scheduler)  if (forcedAsync)  ioRestartAsync(start as any, ctx, cb as any, null, bFirst, bRest)  else  ioGenericRunLoop(start as any, scheduler, ctx, cb as any, null, bFirst, bRest)   return ctx.connection  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","taskToFutureRunLoop","{   let current: Current | Try<any> = start  let bFirst: BindT | null = null  let bRest: CallStack | null = null   const modulus = scheduler.executionModel.recommendedBatchSize - 1  let frameIndex = scheduler.batchIndex   while (true) {  if (current instanceof Try) {  if (current.isSuccess()) {  const bind = _ioPopNextBind(bFirst, bRest)  if (!bind) {  scheduler.batchIndex = frameIndex  return Future.pure(current.get())  }   try {  current = bind(current.get())  } catch (e) {  current = new IOPure(Try.failure(e))  }  } else {  const err = (current as Try<never>).failed().get()  const bind = _ioFindErrorHandler(bFirst, bRest)  if (!bind) {  scheduler.batchIndex = frameIndex  return Future.raise(err)  }   try {  current = bind(err)  } catch (e) {  current = new IOPure(Try.failure(e))  }  }   bFirst = null  const nextIndex = (frameIndex + 1) & modulus  // Should we force an asynchronous boundary?  if (nextIndex) {  frameIndex = nextIndex  } else {  return ioToFutureGoAsync(current, scheduler, bFirst, bRest, true)  }  }  else switch (current._tag) {  case 'pure':  current = (current as IOPure<any>).value  break   case 'always':  current = Try.of((current as IOAlways<any>).thunk)  break   case 'once':  current = (current as IOOnce<any>).runTry()  break   case 'flatMap':  const flatM: IOFlatMap<any, any> = current as any  if (bFirst) {  if (!bRest) bRest = []  bRest.push(bFirst)  }   bFirst = !flatM.g ? flatM.f : [flatM.f, flatM.g]  current = flatM.source  break   case 'async':  case 'memoize':  return ioToFutureGoAsync(current, scheduler, bFirst, bRest, false)  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioSafeCallback","{   let called = false  return (r: Try<A>) => {  if (!called) {  called = true  // Inserting a light async boundary, otherwise we can have  // stack overflow issues, but also ordering issues with  // StackedCancelable.push in IO.async!  ec.trampoline(() => {  conn.pop()  cb(r)  })  } else if (r.isFailure()) {  ec.reportFailure(r.failed().get())  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioStartMemoize","{   // Storing the current frameIndex because invoking this  // function effectively ends the current run-loop  ec.batchIndex = frameIndex  // The state that we'll use for subscribing listeners below  let state: Try<A> | Future<A>   // The first evaluation has to trigger the initial run-loop that  // will eventually set our completed state  if (fa.result) {  state = fa.result  } else {  // NOTE this isn't using the passed `IOContext`, or the bindings  // stack because it would be wrong. This has to be executed  // independently, within its own context.  const f = ioToFutureGoAsync(fa.source as any, ec, null, null, false)   if (f.value().isEmpty()) {  fa.result = f  state = f   f.onComplete(r => {  if (r.isSuccess() || !fa.onlySuccess) {  // Caching result for subsequent listeners  fa.result = r as any  // GC purposes  delete fa.source  } else {  // Reverting the state to the original IO reference, such  // that it can be retried again  fa.result = null  }  })  } else {  state = (f.value().get() as any) as Try<any>  // Not storing the state on memoizeOnSuccess if it's a failure  if (state.isSuccess() || !fa.onlySuccess)  fa.result = state as any  }  }   // We have the IOMemoize in an already completed state,  // so running with it  const io: IO<A> = state instanceof Try  ? new IOPure(state)  : IO.fromFuture(state)   ioGenericRunLoop(io, ec, context, cb, null, bFirstInit, bRestInit) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioSequence","{  return IO.of(() => iteratorOf(list))  .flatMap(cursor => ioSequenceLoop([], cursor)) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioSequenceLoop","{  while (true) {  const elem = cursor.next()  const isDone = elem.done   if (elem.value) {  const io: IO<A> = elem.value  return io.flatMap(a => {  acc.push(a)  if (isDone) return IO.pure(acc)  return ioSequenceLoop(acc, cursor)  })  } else {  /* istanbul ignore else */  if (isDone) return IO.pure(acc)  }  } }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/io.ts","ioListToFutureProcess","{  return IO.asyncUnsafe<B>((ctx, cb) => {  ctx.scheduler.trampoline(() => {  let streamErrors = true  try {  const futures: Future<A>[] = []  const array: IO<A>[] = execInternals.iterableToArray(list)  streamErrors = false   for (let i = 0; i < array.length; i++) {  const io = array[i]  const f = io.run(ctx.scheduler)  futures.push(f)  }   const all = f(futures, ctx.scheduler)  ctx.connection.push(all)  all.onComplete(ioSafeCallback(ctx.scheduler, ctx.connection, cb) as any)  } catch (e) {  /* istanbul ignore else */  if (streamErrors) cb(Failure(e))  else ctx.scheduler.reportFailure(e)  }  })  }) }"
"../test-repos/funfix_funfix/packages/funfix-effect/src/internals.ts","iteratorOf","{  if (!list) return emptyIteratorRef  if (Object.prototype.toString.call(list) !== '[object Array]')  return list[Symbol.iterator]()   const array = list as A[]  if (array.length === 0) return emptyIteratorRef   let cursor = 0  const next = () => {  const value = array[cursor++]  const done = cursor >= array.length  return { done, value }  }   return { next } }"
"../test-repos/funfix_funfix/packages/funfix/test/ts/import.test.ts","assertEquals","{  assert.ok(is(lh, rh), `${lh} != ${rh}`) }"
"../test-repos/gamestdio_colyseus/test/utils/mock.ts","createEmptyClient","{  return new Client() }"
"../test-repos/gamestdio_colyseus/test/utils/mock.ts","createDummyClient","{  return new Client(shortid.generate()) }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","getNextWorkerForSocket","{  let hash = getHash(ip.toBuffer(socket.remoteAddress || '127.0.0.1'));  return workers[hash % workers.length]; }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","spawnWorkers","{  let workers: Worker[] = [];   for (var i = 0, len = numWorkers; i < len; i++) {  workers.push(spawnWorker());  }   return workers; }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","spawnMatchMaking","{  let worker = child_process.fork(__dirname + '/../matchmaking/Process', [], { silent: false });   enableProcessCommunication(worker);   // allow worker to use memshared  memshared.registerProcess(worker);   return worker; }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","spawnWorker","{  let worker = cluster.fork();   debugCluster(`fork spawned with pid ${ worker.process.pid }`);   if (!memshared.store['workerIds']) {  memshared.store['workerIds'] = [];  }   // push worker id to shared workers list.  memshared.store['workerIds'].push(worker.process.pid);   // push worker to workers list  workers.push(worker);   enableProcessCommunication(worker);   // auto-spawn a new worker on failure  worker.on('exit', function (code, signal) {  if (signal !== 'SIGINT' && signal !== 'SIGTERM' && signal !== 'SIGUSR2') {  console.warn('worker', process.pid, 'died. Respawn.')   // remove workerId from shared store  spliceOne(memshared.store['workerIds'], memshared.store['workerIds'].indexOf(process.pid));   // remove worker from workers list.  spliceOne(workers, workers.indexOf(worker));   // spawn new worker as a replacement for this one  spawnWorker();   } else {  workersShutDown++;   if (workersShutDown === workers.length) {  onWorkersShutdown.resolve();  }  }  });   return worker; }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","enableProcessCommunication","{  worker.on('message', (message) => {  let workerProcess = Array.isArray(message) && memshared.getProcessById(message.shift());  if (workerProcess) {  workerProcess.send(message);  }  }); }"
"../test-repos/gamestdio_colyseus/src/cluster/Master.ts","getHash","{  let hash = seed;  for (var i = 0; i < ip.length; i++) {  var num = ip[i];   hash += num;  hash %= 2147483648;  hash += (hash << 10);  hash %= 2147483648;  hash ^= hash >> 6;  }   hash += hash << 3;  hash %= 2147483648;  hash ^= hash >> 11;  hash += hash << 15;  hash %= 2147483648;   return hash >>> 0; }"
"../test-repos/gamestdio_colyseus/src/cluster/Worker.ts","setUserId","{  let url = (<any>client.upgradeReq).url;   client.id = url.query['colyseusid'] || generateId();   if (!url.query['colyseusid']) {  send(client, [ Protocol.USER_ID, client.id ]);  } }"
"../test-repos/gamestdio_colyseus/src/cluster/Worker.ts","handleUpgrade","{  let code = message[0];  let upgradeReq: http.ServerRequest = message[1];  let head: any = message[2];   let url: any = parseURL(message[3], true);  (<any>upgradeReq).url = url;  (<any>upgradeReq).roomId = url.pathname.substr(1);   // assign client socket to request  upgradeReq.connection = socket;   // handle 'upgrade' of the WebSocket connection in the worker node  server.emit('upgrade', upgradeReq, socket, head);   socket.resume(); }"
"../test-repos/gamestdio_colyseus/src/cluster/Worker.ts","setupWorker","{  let wss = new (WebSocketServer as any)({ server: server });   wss.on('connection', (client: Client, req?: http.IncomingMessage) => {  // compatibility with ws@3.x.x / uws  if (req) {  client.upgradeReq = req;  }   setUserId(client);   let roomId = (<any>client.upgradeReq).roomId;  matchMaker.bindClient(client, roomId);  });   process.on('message', (message, socket) => {  let roomNameOrId = message[1];  let joinOptions = message[2];  let allowCreateRoom = (message[0] === Protocol.CREATE_ROOM);   if (message[0] === Protocol.PASS_HTTP_SOCKET) {  server.emit('connection', socket);   // re-create request for incoming socket  let request: any = new (<any>http).ClientRequest({ port: server.address().port });  request.headers = message[1].headers;  request.method = message[1].method;  request.url = message[1].url;  request.connection = socket;  request._readableState = socket._readableState;   // TODO / FIXME:  //  // should we flush something here?  // '_flush' method has been lost after redirecting the socket  //  request._flush = function() {};  request._dump = function() {};   // emit request to server  socket.parser.onIncoming(request);  socket.resume();   // This is way too hacky.  request.emit('data', message[1].body);  request.emit('end');   return;   } else if (message[0] === Protocol.PASS_WEBSOCKET) {  handleUpgrade(server as http.Server, socket, message);  return;   } else if (message[0] === Protocol.REQUEST_JOIN_ROOM) {  let roomNameOrId = message[1];  let clientOptions = message[2];   let room, roomId, score = 1;   if (isValidId(roomNameOrId)) {  room = matchMaker.joinById(roomNameOrId, clientOptions);   } else {  let result = matchMaker.getAvailableRoomByScore(roomNameOrId, clientOptions);  room = result.room  score = result.score;  }   roomId = room && room.roomId;   // send response back to match-making process.  getMatchMakingProcess(matchMakingPid => {  debugMatchMaking('worker '%s' is responding to REQUEST_JOIN_ROOM. (roomId: %s, score: %d)', process.pid, roomId, score);  process.send([matchMakingPid, joinOptions.clientId, process.pid, roomId, score]);  });   } else if (allowCreateRoom || message[0] === Protocol.JOIN_ROOM) {  matchMaker.onJoinRoomRequest(roomNameOrId, joinOptions, allowCreateRoom, (err: string, room: Room<any>) => {  let joinRoomResponse = (err)  ? [ Protocol.JOIN_ERROR, roomNameOrId, err ]  : [ Protocol.JOIN_ROOM, room.roomId, joinOptions.requestId ];   // send response back to match-making process.  getMatchMakingProcess(matchMakingPid => {  process.send([matchMakingPid, joinOptions.clientId, joinRoomResponse]);  });  });   }   });   return server; }"
"../test-repos/gamestdio_colyseus/src/cluster/Worker.ts","getMatchMakingProcess","{  memshared.get('matchmaking_process', (err, matchMakingPid) => {  callback(matchMakingPid);  }); }"
"../test-repos/gamestdio_colyseus/src/Utils.ts","registerGracefulShutdown","{  let calledOnce = false;  ['SIGINT', 'SIGTERM', 'SIGUSR2'].forEach(signal => {  process.once(signal, () => callback(signal));  }); }"
"../test-repos/gamestdio_colyseus/src/Utils.ts","spliceOne","{  // manually splice availableRooms array  // http://jsperf.com/manual-splice  if (index === -1 || index >= arr.length) {  return false;  }   for (var i = index, len = arr.length - 1; i < len; i++) {  arr[i] = arr[i + 1];  }   arr.length = len;   return true; }"
"../test-repos/gamestdio_colyseus/src/Utils.ts","merge","{  for (let i = 0, len = objs.length; i < len; i++) {  let b = objs[i];  for (let key in b) {  if (b.hasOwnProperty(key)) {  a[key] = b[key]  }  }  }  return a; }"
"../test-repos/gamestdio_colyseus/src/Utils.ts","logError","{  if (err) {  console.log(err)  } }"
"../test-repos/gamestdio_colyseus/src/matchmaking/Process.ts","onConnect","{  // compatibility with ws@3.x.x / uws  if (req) {  client.upgradeReq = req;  }   // since ws@3.3.3 it's required to listen to 'error' to prevent server crash  // https://github.com/websockets/ws/issues/1256  client.on('error', (e) => {/*console.error('[ERROR]', e);*/ });   setUserId(client);   client.on('message', (message) => {  if (!(message = decode(message))) {  return;  }   if (message[0] !== Protocol.JOIN_ROOM) {  console.error('MatchMaking couldn't process message:', message);  return;  }   let roomName = message[1];  let joinOptions = message[2];   joinOptions.clientId = client.id;   if (isValidId(roomName)) {  // join room by id  memshared.get(roomName, (err, workerId) =>  broadcastJoinRoomRequest([workerId], client, roomName, joinOptions));   } else {  // join room by name   // is room handler avaialble?  memshared.sismember('handlers', roomName, (err, isHandlerAvailable) => {  if (!isHandlerAvailable) {  send(client, [Protocol.JOIN_ERROR, roomName, `Error: no available handler for '${ roomName }'`]);  return;  }   // request to join an existing sessions for requested handler  memshared.smembers(roomName, (err, availableWorkerIds) => {  //  // TODO:  // remove a room from match-making cache when it reaches maxClients.  //   if (availableWorkerIds.length > 0) {  broadcastJoinRoomRequest(availableWorkerIds, client, roomName, joinOptions);   } else {  // retrieve active worker ids  requestCreateRoom(client, roomName, joinOptions);  }  });   });   }   }); }"
"../test-repos/gamestdio_colyseus/src/matchmaking/Process.ts","broadcastJoinRoomRequest","{  let responsesReceived = [];   callbacks[ client.id ] = (workerId, roomId, score) => {  responsesReceived.push({  roomId: roomId,  score: score,  workerId: workerId  });   debugMatchMaking('JOIN_ROOM, receiving responses (%d/%d)', responsesReceived.length, availableWorkerIds.length);   if (responsesReceived.length === availableWorkerIds.length) {  // sort responses by score  responsesReceived.sort((a, b) => b.score - a.score);   let { workerId, roomId, score } = responsesReceived[0];   if (score === 0) {  debugMatchMaking('JOIN_ROOM, best score: %d, (options: %j)', score, joinOptions);   // highest score is 0, let's request to create a room instead of joining.  requestCreateRoom(client, roomName, joinOptions);   } else {  debugMatchMaking('JOIN_ROOM, best score: %d, (options: %j)', score, joinOptions);   // send join room request to worker id with best score  joinRoomRequest(workerId, client, roomId, joinOptions);  }  }  }   availableWorkerIds.forEach(availableWorkerId => {  // Send JOIN_ROOM command to selected worker process.  process.send([ availableWorkerId, Protocol.REQUEST_JOIN_ROOM, roomName, joinOptions ]);  }); }"
"../test-repos/gamestdio_colyseus/src/matchmaking/Process.ts","joinRoomRequest","{  // forward data received from worker process to the client  callbacks[ client.id ] = (data) => send(client, data);   // Send JOIN_ROOM command to selected worker process.  process.send([ workerId, Protocol.JOIN_ROOM, roomName, joinOptions ]); }"
"../test-repos/gamestdio_colyseus/src/matchmaking/Process.ts","requestCreateRoom","{  // forward data received from worker process to the client  callbacks[ client.id ] = (data) => send(client, data);   memshared.lrange('workerIds', 0, -1, (err, workerIds) => {  memshared.mget(workerIds, (err, spawnedRoomCounts) => {  spawnedRoomCounts = spawnedRoomCounts.filter(count => count);   let selectedWorkerId = (spawnedRoomCounts.length > 0)  ? workerIds[ spawnedRoomCounts.indexOf(Math.min(...spawnedRoomCounts)) ]  : workerIds[0];   debugMatchMaking('requesting CREATE_ROOM');   // Send CREATE_ROOM command to selected worker process.  process.send([ selectedWorkerId, Protocol.CREATE_ROOM, roomName, joinOptions ]);  });  }); }"
"../test-repos/gamestdio_colyseus/src/Protocol.ts","decode","{  try {  message = msgpack.decode(Buffer.from(message));   } catch (e) {  console.error('Couldn't decode message:', message, e.stack);  return;  }   return message; }"
"../test-repos/gamestdio_colyseus/src/Protocol.ts","send","{  client.send(msgpack.encode(message), { binary: true }); }"
"../test-repos/gamestdio_colyseus/src/index.ts","generateId","{ return shortid.generate(); }"
"../test-repos/gamestdio_colyseus/src/index.ts","isValidId","{ return shortid.isValid(id); }"
"../test-repos/garbles_flag/src/set-flags-action.ts","setFlagsAction","{  return {  payload: flags,  type: SET_FLAGS,  }; }"
"../test-repos/google_ts-style/test/fixtures.ts","setupFixtures","{  await makeDir(dir);  const keys = Object.keys(fixtures);  for (const key of keys) {  const filePath = path.join(dir, key);  if (typeof fixtures[key] === 'string') {  const contents = fixtures[key] as string;  await writeFilep(filePath, contents);  } else {  const fixture = fixtures[key] as Fixtures;  await setupFixtures(filePath, fixture);  }  } }"
"../test-repos/google_ts-style/test/fixtures.ts","withFixtures","{  const keep = !!process.env.GTS_KEEP_TEMPDIRS;  const dir = tmp.dirSync({keep, unsafeCleanup: true});   await setupFixtures(dir.name, fixtures);   const origDir = process.cwd();  process.chdir(dir.name);   const result = await fn(dir.name);   process.chdir(origDir);  if (!keep) {  dir.removeCallback();  }   return result; }"
"../test-repos/google_ts-style/test/test-kitchen.ts","isExecError","{  return (err as ExecError).code !== undefined; }"
"../test-repos/google_ts-style/test/test-util.ts","fakeReadFilep","{  t.is(configPath, path.join(FAKE_DIRECTORY, 'tsconfig.json'));  t.is(encoding, 'utf8');  return Promise.resolve(JSON.stringify(FAKE_CONFIG));  }"
"../test-repos/google_ts-style/src/lint.ts","lint","{  const tslintConfigPath = path.join(options.gtsRootDir, 'tslint.json');   const program = createProgram(options);  const configuration =  Configuration.findConfiguration(tslintConfigPath, '').results;  const linter = new Linter({fix, formatter: 'codeFrame'}, program);  const srcFiles = files.length > 0 ? files : Linter.getFileNames(program);  srcFiles.forEach(file => {  const sourceFile = program.getSourceFile(file);  if (sourceFile) {  const fileContents = sourceFile.getFullText();  linter.lint(file, fileContents, configuration);  }  });  const result = linter.getResult();  if (result.errorCount || result.warningCount) {  options.logger.log(result.output);  return false;  }  return true; }"
"../test-repos/google_ts-style/src/lint.ts","createProgram","{  const tsconfigPath = path.join(options.targetRootDir, 'tsconfig.json');  return Linter.createProgram(tsconfigPath); }"
"../test-repos/google_ts-style/src/init.ts","query","{  if (options.yes) {  return true;  } else if (options.no) {  return false;  }   if (message) {  options.logger.log(message);  }   const answers = await inquirer.prompt(  {type: 'confirm', name: 'query', message: question, default: defaultVal});  return answers.query; }"
"../test-repos/google_ts-style/src/init.ts","addScripts","{  let edits = false;  const scripts: Bag<string> = {  check: `gts check`,  clean: 'gts clean',  compile: `tsc -p .`,  fix: `gts fix`,  prepare: `npm run compile`,  pretest: `npm run compile`,  posttest: `npm run check`  };   if (!packageJson.scripts) {  packageJson.scripts = {};  }   for (const script of Object.keys(scripts)) {  let install = true;  const existing = packageJson.scripts[script];  const target = scripts[script];   if (existing !== target) {  if (existing) {  const message =  `package.json already has a script for ${chalk.bold(script)}:\n` +  `-${chalk.red(existing)}\n+${chalk.green(target)}`;  install = await query(message, 'Replace', false, options);  }   if (install) {  packageJson.scripts[script] = scripts[script];  edits = true;  }  }  }  return edits; }"
"../test-repos/google_ts-style/src/init.ts","addDependencies","{  let edits = false;  const deps: Bag<string> = {'gts': `^${pkg.version}`, 'typescript': '~2.6.1'};   if (!packageJson.devDependencies) {  packageJson.devDependencies = {};  }   for (const dep of Object.keys(deps)) {  let install = true;  const existing = packageJson.devDependencies[dep];  const target = deps[dep];   if (existing !== target) {  if (existing) {  const message = `Already have devDependency for ${chalk.bold(dep)}:\n` +  `-${chalk.red(existing)}\n+${chalk.green(target)}`;  install = await query(message, 'Overwrite', false, options);  }   if (install) {  packageJson.devDependencies[dep] = deps[dep];  edits = true;  }  }  }   return edits; }"
"../test-repos/google_ts-style/src/init.ts","formatJson","{  // TODO: preserve the indent from the input file.  const json = JSON.stringify(object, null, ' ');  return `${json}\n`; }"
"../test-repos/google_ts-style/src/init.ts","writePackageJson","{  options.logger.log('Writing package.json...');  if (!options.dryRun) {  await write('./package.json', formatJson(packageJson));  }  const preview = {  scripts: packageJson.scripts,  devDependencies: packageJson.devDependencies  };  options.logger.dir(preview); }"
"../test-repos/google_ts-style/src/init.ts","generateTsConfig","{  let existing;  try {  existing = await read('./tsconfig.json', 'utf8');  } catch (err) {  if (err.code === 'ENOENT') {  /* not found, create it. */  } else {  throw new Error(`Unknown error reading tsconfig.json: ${err.message}`);  }  }   const tsconfig = formatJson({  extends: './node_modules/gts/tsconfig-google.json',  compilerOptions: {rootDir: '.', outDir: 'build'},  include: ['src/*.ts', 'src/**/*.ts', 'test/*.ts', 'test/**/*.ts'],  exclude: ['node_modules']  });   let writeTsConfig = true;  if (existing && existing === tsconfig) {  options.logger.log('No edits needed in tsconfig.json.');  return;  } else if (existing) {  writeTsConfig = await query(  `${chalk.bold('tsconfig.json')} already exists`, 'Overwrite', false,  options);  }   if (writeTsConfig) {  options.logger.log('Writing tsconfig.json...');  if (!options.dryRun) {  await write('./tsconfig.json', tsconfig);  }  options.logger.dir(JSON.parse(tsconfig));  } }"
"../test-repos/google_ts-style/src/init.ts","init","{  let packageJson;  try {  packageJson = await readJson('./package.json');  } catch (err) {  if (err.code !== 'ENOENT') {  throw new Error(`Unable to open package.json file: ${err.message}`);  }  const generate = await query(  `${chalk.bold('package.json')} does not exist.`, `Generate`, true,  options);   if (!generate) {  options.logger.log('Please run from a directory with your package.json.');  return false;  }   try {  // TODO(ofrobots): add proper error handling.  cp.spawnSync('npm', ['init', '-y']);  packageJson = await readJson('./package.json');  } catch (err2) {  throw err2;  }  }   const addedDeps = await addDependencies(packageJson, options);  const addedScripts = await addScripts(packageJson, options);  if (addedDeps || addedScripts) {  await writePackageJson(packageJson, options);  } else {  options.logger.log('No edits needed in package.json.');  }  await generateTsConfig(options);   // Run `npm install` after initial setup so `npm run check` works right away.  if (!options.dryRun) {  cp.spawnSync('npm', ['install'], {stdio: 'inherit'});  }   return true; }"
"../test-repos/google_ts-style/src/cli.ts","usage","{  if (msg) {  logger.error(msg);  }  cli.showHelp(1); }"
"../test-repos/google_ts-style/src/cli.ts","run","{  const options: Options = {  dryRun: cli.flags.dryRun || false,  // Paths are relative to the transpiled output files.  gtsRootDir: path.resolve(__dirname, '../..'),  targetRootDir: process.cwd(),  yes: cli.flags.yes || cli.flags.y || false,  no: cli.flags.no || cli.flags.n || false,  logger  };  // Linting/formatting depend on typescript. We don't want to load the  // typescript module during init, since it might not exist.  // See: https://github.com/google/ts-style/issues/48  if (verb === 'init') {  return await init(options);  }   const lint: VerbFilesFunction = require('./lint').lint;  const format: VerbFilesFunction = require('./format').format;  switch (verb) {  case 'check':  const passLint = await lint(options, files);  const passFormat = await format(options, files);  return passLint && passFormat;  case 'fix':  return (  await lint(options, files, true) &&  await format(options, files, true));  case 'clean':  return await clean(options);  default:  usage(`Unknown verb: ${verb}`);  return false;  } }"
"../test-repos/google_ts-style/src/format.ts","format","{  const program = createProgram(options);  // Obtain a list of source files to format.  // We use program.getRootFileNames to get only the files that match the  // include patterns specified in the given tsconfig.json file (as specified  // through options). This is necessary because we only want to format files  // over which the developer has control (i.e. not auto-generated or  // third-party source files).  const srcFiles = files.length > 0 ?  files :  program.getRootFileNames().filter(f => !f.endsWith('.d.ts'));   if (fix) {  return await fixFormat(srcFiles);  } else {  const result = await checkFormat(srcFiles);  if (!result) {  options.logger.log(  'clang-format reported errors... run `gts fix` to address.');  }  return result;  } }"
"../test-repos/google_ts-style/src/format.ts","fixFormat","{  return new Promise<boolean>((resolve, reject) => {  const args = baseArgs.concat(['-i'], srcFiles);  clangFormat.spawnClangFormat(args, (err?: Error) => {  if (err) {  reject(err);  } else {  resolve(true);  }  }, 'inherit');  }); }"
"../test-repos/google_ts-style/src/format.ts","checkFormat","{  return new Promise<boolean>((resolve, reject) => {  let output = '';  const args = baseArgs.concat(['-output-replacements-xml'], srcFiles);  const out = clangFormat  .spawnClangFormat(  args,  (err?: Error) => {  if (err) {  reject(err);  }  },  ['ignore', 'pipe', process.stderr])  .stdout;  out.setEncoding('utf8');  out.on('data', (data: Buffer) => {  output += data;  });  out.on('end', () => {  resolve(output.indexOf('<replacement ') === -1 ? true : false);  });  }); }"
"../test-repos/google_ts-style/src/util.ts","readJsonp","{  return JSON.parse(await readFilep(jsonPath)); }"
"../test-repos/google_ts-style/src/util.ts","nop","{  /* empty */ }"
"../test-repos/google_ts-style/src/util.ts","getTSConfig","{  const tsconfigPath = path.join(rootDir, 'tsconfig.json');  customReadFilep = customReadFilep || readFilep;  const json = await customReadFilep(tsconfigPath, 'utf8');  const contents = JSON.parse(json);  return contents; }"
"../test-repos/google_ts-style/src/clean.ts","clean","{  const tsconfig = (await getTSConfig(options.targetRootDir)) as TSConfig;  if (tsconfig.compilerOptions && tsconfig.compilerOptions.outDir) {  const outDir = tsconfig.compilerOptions.outDir;  if (outDir === '.') {  options.logger.error(  `${chalk.red('ERROR:')} ${chalk.gray('compilerOptions.outDir')} ` +  `cannot use the value '.'. That would delete all of our sources.`);  return false;  }  const message = `${chalk.red('Removing')} ${outDir} ...`;  options.logger.log(message);  await rimrafp(outDir);  return true;  } else {  options.logger.error(  `${chalk.red('ERROR:')} The ${chalk.gray('clean')} command` +  ` requires ${chalk.gray('compilerOptions.outDir')} to be defined in ` +  `tsconfig.json.`);  return false;  } }"
"../test-repos/howtographql_howtographql/src/utils/getStackName.ts","getStackName","{  if (localMap[group]) {  return localMap[group]  }   const stack = data.find(s => s.key === group)   if (stack) {  return stack.title  }   return null }"
"../test-repos/howtographql_howtographql/src/utils/getAuthorByGroup.ts","getAuthorByGroup","{  const stack = data.find(s => s.key === group)  if (stack) {  return authors[stack.authorName]  }   return authors['Nikolas Burk'] }"
"../test-repos/howtographql_howtographql/src/utils/getTotalDuration.ts","getTotalDuration","{  if (!steps) {  return 0  }  return steps.reduce((acc, curr) => acc + (curr.duration || 0), 0) }"
"../test-repos/howtographql_howtographql/src/utils/tutorials.ts","getFrontendTutorials","{  return data.filter(t => t.type === 'frontend' && !t.comingSoon).map(stack => {  const tutorialSteps = steps[stack.key]  return {  ...tutorialSteps[0],  title: stack.title,  }  }) }"
"../test-repos/howtographql_howtographql/src/utils/tutorials.ts","getBackendTutorials","{  return data.filter(t => t.type === 'backend' && !t.comingSoon).map(stack => {  const tutorialSteps = steps[stack.key]  return {  ...tutorialSteps[0],  title: stack.title,  }  }) }"
"../test-repos/howtographql_howtographql/src/utils/graphql.ts","extractSteps","{  const tutorials = mds.edges  .map(edge => edge.node)  .filter(n => n.frontmatter.title.length > 0)  .map(chapter => ({  description: chapter.frontmatter.description,  duration: chapter.frontmatter.duration,  link: chapter.fields.slug,  title: chapter.frontmatter.title,  }))   const grouped = groupBy(tutorials, md => extractGroup(md.link))   return Object.keys(grouped).reduce((acc, curr) => {  const steps = grouped[curr]  return {  ...acc,  [curr]: sortBy(steps, step => {  const splittedLink = step.link.split('/')  let leadingNumber = '0'  if (splittedLink.length > 2) {  leadingNumber = splittedLink[2].split('-')[0]  }  return parseInt(leadingNumber, 10)  }),  }  }, {}) }"
"../test-repos/howtographql_howtographql/src/utils/graphql.ts","extractGroup","{  const splittedSlug = slug.split('/')  if (splittedSlug.length > 1) {  return splittedSlug[1]  }  if (slug.includes('/choose')) {  return 'choose'  }  return '' }"
"../test-repos/howtographql_howtographql/src/reducers/data.ts","dataReducer","{  switch (action.type) {  case 'set person data':  return {  ...state,  personData: action.payload,  }  case 'set post data':  return {  ...state,  postData: action.payload,  }  }   return state }"
"../test-repos/howtographql_howtographql/src/reducers/ui.ts","uiReducer","{  switch (action.type) {  case 'set search visible':  return {  ...state,  overlayVisible: action.payload,  searchVisible: action.payload,  }  case 'hide overlay':  return {  overlayVisible: false,  overviewVideoVisible: false,  searchVisible: false,  }  case 'set overview video visible':  return {  ...state,  overlayVisible: action.payload,  overviewVideoVisible: action.payload,  }  }   return state }"
"../test-repos/howtographql_howtographql/src/reducers/quiz.ts","quizReducer","{  switch (action.type) {  case 'remember skipped':  return {  ...state,  rememberSkipped: action.payload,  }   case 'answer correctly':  return updateReaction(state, action.path, { answeredCorrectly: true })   case 'add answer':  const currentReaction = action.path  ? state.quizReactions[action.path] || defaultReaction  : defaultReaction  return updateReaction(state, action.path, {  answerIndeces: (currentReaction.answerIndeces || [])  .concat(action.payload),  })   case 'skip':  return updateReaction(state, action.path, { skipped: true })   case 'set reaction':  return updateReaction(state, action.path, action.payload)  }  return state }"
"../test-repos/howtographql_howtographql/src/reducers/quiz.ts","updateReaction","{  if (!path) {  throw new Error('path is missing')  // return state  }  const oldReaction = state.quizReactions[path] || defaultReaction  return {  ...state,  quizReactions: {  ...state.quizReactions,  [path]: {  ...oldReaction,  ...newReaction,  },  },  } }"
"../test-repos/incrediblesound_story-graph/src/world/components/utility.ts","removeActor","{  let index: number | null = null;  for (let i = 0; i < world.actors.length; i++) {  if (world.actors[i].id === id) {  index = i;  break;  }  }  if (index !== null) {  world.actors.splice(index, 1);  world.size--;  } }"
"../test-repos/incrediblesound_story-graph/src/world/components/utility.ts","getLocalSet","{  return world.actors.filter(actor => actor.location === location.name); }"
"../test-repos/incrediblesound_story-graph/src/world/components/utility.ts","getActor","{  if (reference === undefined) throw new Error('Undefined value in template.');   if (typeof reference === 'number') {  return world.getActorById(reference);  }   // this is for adding query patterns to a story, probably unnecessary  // } else if (piece.where !== undefined) {  // const property = piece.where[0];  // const value = piece.where[1];  // for (let i = 0; i < world.size; i++) {  // if (world.actors[i][property] === value) {  // return world.actors[i];  // }  // }  // }  return false; }"
"../test-repos/incrediblesound_story-graph/src/world/components/utility.ts","fetchElement","{  if (typeof element === 'number') {  const actor = getActor(world, element)  if (actor) {  return actor.name  }  } else if (typeof element === 'string') {  return element  }  return '' }"
"../test-repos/incrediblesound_story-graph/src/world/components/events.ts","populateTemplate","{  if (!eventTemplate || !eventTemplate.length) return false;   return eventTemplate.map(value => {  if (value === SOURCE) {  return actorOne.id;  } else if (value === TARGET && actorTwo) {  return actorTwo.id;  } else {  return value;  }  }); }"
"../test-repos/incrediblesound_story-graph/src/world/components/events.ts","renderTemplate","{  const result = template.map(piece => utility.fetchElement(world, piece));  const body = result.join(' ');  if (!body.length) {  return '';  }   return addPeriod(capitalizeFirst(body)) }"
"../test-repos/incrediblesound_story-graph/src/world/components/events.ts","addConsequentActor","{  const consequentActor = new Actor(rule.consequentActor, world, actorOne, actorTwo);  consequentActor.parentId = rule.id;  world.addActor(consequentActor); }"
"../test-repos/incrediblesound_story-graph/src/world/components/events.ts","applyConsequent","{  if (!typeExpression.length || typeExpression[0] === undefined) return false;  const typeExpressionArray = Array.isArray(typeExpression[0]) ? typeExpression : [typeExpression];  let result = '';  typeExpressionArray.forEach((expr: StoryEvent) => {  switch (expr[1]) {  case VANISH: { // [ id, VANISH ]  const actor = expr[0];  utility.removeActor(world, actor);  break;  }  case MOVE_OUT:  case MOVE_IN: { // [ id, MOVE_IN, 'location' ]  const actor = world.getActorById(expr[0]);  if (actor) {  actor.location = expr[2];  }  break;  }  default: { // [ id, SOME_EVENT, id ]  const source = utility.getActor(world, expr[0]);  const target = utility.getActor(world, expr[2]);  const rules = matchRulesFor(world, source, target, expr[1]);  if (rules && rules.length) {  /* eslint-disable no-use-before-define */  const rule = selectAtRandom(rules);  result = processEvent(world, rule, source, target);  }  }  }  });  return result; }"
"../test-repos/incrediblesound_story-graph/src/world/components/events.ts","processEvent","{  const causeTemplate = populateTemplate(rule.cause.template, actorOne, actorTwo);  let consequentTemplate = []  let tertiaryTemplate = false  if (rule.consequent) {  consequentTemplate = populateTemplate(rule.consequent.template, actorOne, actorTwo);  tertiaryTemplate = populateTemplate(rule.consequent.type, actorOne, actorTwo);  }  const causeText = causeTemplate ? renderTemplate(world, causeTemplate) : ''  const consequentText = consequentTemplate ? renderTemplate(world, consequentTemplate) : ''  const tertiary = tertiaryTemplate ? applyConsequent(world, tertiaryTemplate) : '';   if (rule.consequentActor) {  addConsequentActor(world, rule, actorOne, actorTwo);  }  if (rule.mutations) {  rule.mutations(actorOne, actorTwo)  }  const result = causeText + consequentText + tertiary;  return result; }"
"../test-repos/incrediblesound_story-graph/src/world/components/lib/getLocalRules.ts","includes","{  return arr.indexOf(item) !== -1 }"
"../test-repos/incrediblesound_story-graph/src/world/components/story.ts","twoActors","{  const actorOne: Actor = actor || world.actors[Math.floor(Math.random() * world.actors.length)];  let localActors: Actor[];  if (actorOne.location) {  localActors = world.actors.filter(actor => sameLocation(actor, actorOne) && !sameName(actor, actorOne))  } else {  localActors = world.actors.filter(actor => !sameName(actor, actorOne));  }  if (!localActors.length) {  return [ actorOne ];  }  const actorTwo: Actor = localActors[Math.floor(Math.random() * localActors.length)];  return [ actorOne, actorTwo ]; }"
"../test-repos/incrediblesound_story-graph/src/world/components/story.ts","checkMatch","{  let match;  const sourceMatch = ruleMatchesActor(rule, source, 'source')  const targetMatch = ruleMatchesActor(rule, target, 'target');   if (!rule.isDirectional && target !== undefined) {   const flippedSourceMatch = ruleMatchesActor(rule, target, 'source');  const flippedTargetMatch = ruleMatchesActor(rule, source, 'target');   match = (sourceMatch && targetMatch) || (flippedTargetMatch && flippedSourceMatch);   } else { match = (sourceMatch && targetMatch); }   /* this code assumes that actors cannot interact with rule that they are a member of.  I think this may be incorrect so I am commenting it out for now   const sourceInTarget = !!target && target.members && target.hasMember(source.id);  const targetInSource = !!target && source.members && source.hasMember(target.id);  */   if (action !== undefined) {  return match && rule.getActionType() === action  /* && !(sourceInTarget || targetInSource); */  }   return match /* && !(sourceInTarget || targetInSource); */ }"
"../test-repos/incrediblesound_story-graph/src/world/components/story.ts","matchRulesFor","{  const matchedRules: Rule[] = [];   const localRules = getLocalRules(world, actorOne);   for (let i = 0; i < localRules.length; i++) {  const currentRule = localRules[i];  const isMatch = checkMatch(currentRule, actorOne, actorTwo, action);   if (isMatch) {  matchedRules.push(currentRule);  }  }   if (!matchedRules.length) {  return false;  }   return matchedRules; }"
"../test-repos/incrediblesound_story-graph/src/world/components/story.ts","randomMatch","{   const transitions = world.rules.filter(rule => checkTransitionMatch(rule, actorOne));  const interactions = matchRulesFor(world, actorOne, actorTwo) || []  let rules = interactions.concat(transitions)  if (exclude !== null) {  rules = rules.filter(r => r.id !== exclude)  }   return rules.length ? rules : false }"
"../test-repos/incrediblesound_story-graph/src/world/components/time.ts","advanceTime","{  if (world.timedEvents[world.timeIndex] !== undefined) {  world.renderEvent([ world.timedEvents[world.timeIndex] ]);  } else {  world.randomEvent();  }  world.actors.forEach((actor, idx) => {  if (idx >= world.size) return;  const age = world.timeIndex - actor.entryTime;  if (age > actor.lifeTime) {  removeActor(world, actor.id);  }  // } else if (actor.callback !== null) {  // world.processTimeTrigger(world, actor.callback(world.timeIndex));  // }  });  world.timeIndex++; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/highlighting.ts","configureRustErrors","{  Prism.languages.rust_errors = { // eslint-disable-line camelcase  'warning': /warning:.*\n/,  'error': {  pattern: /error(\[E\d+\])?:.*\n/,  inside: {  'error-explanation': /\[E\d+\]/,  },  },  'error-location': /-->.*\n/,  'stack-trace-location': /at \/playground.*\n/,  };   Prism.hooks.add('wrap', env => {  if (env.type === 'error-explanation') {  const errorMatch = /E\d+/.exec(env.content);  const [errorCode] = errorMatch;  env.tag = 'a';  env.attributes.href = `https://doc.rust-lang.org/error-index.html#${errorCode}`;  }  if (env.type === 'error-location') {  const errorMatch = /(\d+):(\d+)/.exec(env.content);  const [_, line, col] = errorMatch;  env.tag = 'a';  env.attributes.href = '#';  env.attributes['data-line'] = line;  env.attributes['data-col'] = col;  }  if (env.type === 'stack-trace-location') {  const errorMatch = /main.rs:(\d+)/.exec(env.content);  const [_, line] = errorMatch;  env.tag = 'a';  env.attributes.href = '#';  env.attributes['data-line'] = line;  env.attributes['data-col'] = '1';  }  });   Prism.hooks.add('after-highlight', env => {  const links = env.element.querySelectorAll('.error-location, .stack-trace-location');  Array.from(links).forEach((link: HTMLAnchorElement) => {  const { line, col } = link.dataset;  link.onclick = e => {  e.preventDefault();  gotoPosition(line, col);  };  });  }); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/gist.ts","load","{  return fetch(`${baseUrlStr}/${id}`)  .then(response => response.json())  .then(convertGistResponse); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/gist.ts","save","{  return fetch(baseUrlStr, {  method: 'post',  body: JSON.stringify(gistBody(code)),  })  .then(response => response.json())  .then(({ id, html_url: url }) => ({ id, url })); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/local_storage.ts","serialize","{  return JSON.stringify({  version: CURRENT_VERSION,  configuration: {  editor: state.configuration.editor,  keybinding: state.configuration.keybinding,  theme: state.configuration.theme,  orientation: state.configuration.orientation,  assemblyFlavor: state.configuration.assemblyFlavor,  demangleAssembly: state.configuration.demangleAssembly,  processAssembly: state.configuration.processAssembly,  },  code: state.code,  }); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/local_storage.ts","deserialize","{  if (!savedState) { return undefined; }  const parsedState = JSON.parse(savedState);  if (parsedState.version !== CURRENT_VERSION) { return undefined; }   return {  configuration: {  ...defaultConfiguration,  editor: parsedState.configuration.editor || defaultConfiguration.editor,  keybinding: parsedState.configuration.keybinding || defaultConfiguration.keybinding,  theme: parsedState.configuration.theme || defaultConfiguration.theme,  orientation: parsedState.configuration.orientation || defaultConfiguration.orientation,  assemblyFlavor: parsedState.configuration.assemblyFlavor || defaultConfiguration.assemblyFlavor,  demangleAssembly: parsedState.configuration.demangleAssembly || defaultConfiguration.demangleAssembly,  processAssembly: parsedState.configuration.processAssembly || defaultConfiguration.processAssembly,  },  code: parsedState.code,  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","toggleConfiguration","{  return { type: ActionType.ToggleConfiguration }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","navigateToIndex","{  return { type: ActionType.SetPage, page: 'index' }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","navigateToHelp","{  return { type: ActionType.SetPage, page: 'help' }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeEditor","{  return { type: ActionType.ChangeEditor, editor }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeKeybinding","{  return { type: ActionType.ChangeKeybinding, keybinding }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeTheme","{  return { type: ActionType.ChangeTheme, theme }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeOrientation","{  return { type: ActionType.ChangeOrientation, orientation }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeAssemblyFlavor","{  return { type: ActionType.ChangeAssemblyFlavor, assemblyFlavor }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeDemangleAssembly","{  return { type: ActionType.ChangeDemangleAssembly, demangleAssembly }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeProcessAssembly","{  return { type: ActionType.ChangeProcessAssembly, processAssembly }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeChannel","{  return { type: ActionType.ChangeChannel, channel }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeMode","{  return { type: ActionType.ChangeMode, mode }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","changeFocus","{  return { type: ActionType.ChangeFocus, focus }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestExecute","{  return { type: ActionType.ExecuteRequest }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveExecuteSuccess","{  return { type: ActionType.ExecuteSucceeded, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveExecuteFailure","{  return { type: ActionType.ExecuteFailed, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","jsonGet","{  const urlStr = url.format(urlObj);   return fetchJson(urlStr, {  method: 'get',  }); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","jsonPost","{  const urlStr = url.format(urlObj);   return fetchJson(urlStr, {  method: 'post',  body: JSON.stringify(body),  }); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","fetchJson","{  const { headers = {} } = args;  headers['Content-Type'] = 'application/json';   return fetch(url, { ...args, headers })  .catch(error => error)  .then(response => {  if (response.ok) {  return response.json();  } else {  return response.json()  .catch(e => Promise.reject({ error: e.toString() }))  .then(j => Promise.reject(j));  }  }); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performExecute","{  // TODO: Check a cache  return function(dispatch, getState) {  dispatch(requestExecute());   const state = getState();  const { code, configuration: { channel, mode } } = state;  const crateType = getCrateType(state);  const tests = runAsTest(state);   const body = { channel, mode, crateType, tests, code };   return jsonPost(routes.execute, body)  .then(json => dispatch(receiveExecuteSuccess(json)))  .catch(json => dispatch(receiveExecuteFailure(json)));  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performCompile","{  // TODO: Check a cache  return function(dispatch, getState) {  dispatch(request());   const state = getState();  const { code, configuration: {  channel,  mode,  assemblyFlavor,  demangleAssembly,  processAssembly,  } } = state;  const crateType = getCrateType(state);  const tests = runAsTest(state);  const body = {  channel,  mode,  crateType,  tests,  code,  target,  assemblyFlavor,  demangleAssembly,  processAssembly,  };   return jsonPost(routes.compile, body)  .then(json => dispatch(success(json)))  .catch(json => dispatch(failure(json)));  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestCompileAssembly","{  return { type: ActionType.CompileAssemblyRequest }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileAssemblySuccess","{  return { type: ActionType.CompileAssemblySucceeded, code, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileAssemblyFailure","{  return { type: ActionType.CompileAssemblyFailed, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestCompileLlvmIr","{  return { type: ActionType.CompileLlvmIrRequest }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileLlvmIrSuccess","{  return { type: ActionType.CompileLlvmIrSucceeded, code, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileLlvmIrFailure","{  return { type: ActionType.CompileLlvmIrFailed, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestCompileMir","{  return { type: ActionType.CompileMirRequest }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileMirSuccess","{  return { type: ActionType.CompileMirSucceeded, code, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileMirFailure","{  return { type: ActionType.CompileMirFailed, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestCompileWasm","{  return { type: ActionType.CompileWasmRequest }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileWasmSuccess","{  return { type: ActionType.CompileWasmSucceeded, code, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCompileWasmFailure","{  return { type: ActionType.CompileWasmFailed, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","editCode","{  return { type: EDIT_CODE, code }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","gotoPosition","{  return { type: GOTO_POSITION, line: +line, column: +column }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestFormat","{  return { type: REQUEST_FORMAT }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveFormatSuccess","{  return { type: FORMAT_SUCCEEDED, code }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveFormatFailure","{  return { type: FORMAT_FAILED, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performFormat","{  // TODO: Check a cache  return function(dispatch, getState) {  dispatch(requestFormat());   const { code } = getState();  const body = { code };   return jsonPost(routes.format, body)  .then(json => dispatch(receiveFormatSuccess(json)))  .catch(json => dispatch(receiveFormatFailure(json)));  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestClippy","{  return { type: REQUEST_CLIPPY }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveClippySuccess","{  return { type: CLIPPY_SUCCEEDED, stdout, stderr }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveClippyFailure","{  return { type: CLIPPY_FAILED, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performClippy","{  // TODO: Check a cache  return function(dispatch, getState) {  dispatch(requestClippy());   const { code } = getState();  const body = { code };   return jsonPost(routes.clippy, body)  .then(json => dispatch(receiveClippySuccess(json)))  .catch(json => dispatch(receiveClippyFailure(json)));  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestGistLoad","{  return { type: REQUEST_GIST_LOAD }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveGistLoadSuccess","{  return { type: GIST_LOAD_SUCCEEDED, id, url, code }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveGistLoadFailure","{ // eslint-disable-line no-unused-vars  return { type: GIST_LOAD_FAILED }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performGistLoad","{  return function(dispatch, _getState) {  dispatch(requestGistLoad());   loadGist(id)  .then(gist => dispatch(receiveGistLoadSuccess({ ...gist })));  // TODO: Failure case  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestGistSave","{  return { type: REQUEST_GIST_SAVE }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveGistSaveSuccess","{  return { type: GIST_SAVE_SUCCEEDED, id, url, channel }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveGistSaveFailure","{ // eslint-disable-line no-unused-vars  return { type: GIST_SAVE_FAILED, error }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performGistSave","{  return function(dispatch, getState): ThunkAction {  dispatch(requestGistSave());   const { code, configuration: { channel } } = getState();   return saveGist(code)  .then(json => dispatch(receiveGistSaveSuccess({ ...json, channel })));  // TODO: Failure case  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestCratesLoad","{  return { type: REQUEST_CRATES_LOAD }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveCratesLoadSuccess","{  return { type: CRATES_LOAD_SUCCEEDED, crates }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performCratesLoad","{  return function(dispatch) {  dispatch(requestCratesLoad());   return jsonGet(routes.meta.crates)  .then(json => dispatch(receiveCratesLoadSuccess(json)));  // TODO: Failure case  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","requestVersionsLoad","{  return { type: REQUEST_VERSIONS_LOAD }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","receiveVersionsLoadSuccess","{  return { type: VERSIONS_LOAD_SUCCEEDED, stable, beta, nightly }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","performVersionsLoad","{  return function(dispatch) {  dispatch(requestVersionsLoad());   const stable = jsonGet(routes.meta.version.stable);  const beta = jsonGet(routes.meta.version.beta);  const nightly = jsonGet(routes.meta.version.nightly);   const all = Promise.all([stable, beta, nightly]);   return all  .then(([stable, beta, nightly]) => dispatch(receiveVersionsLoadSuccess({  stable,  beta,  nightly,  })));  // TODO: Failure case  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","parseChannel","{  switch (s) {  case 'stable':  return Channel.Stable;  case 'beta':  return Channel.Beta;  case 'nightly':  return Channel.Nightly;  default:  return null;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","parseMode","{  switch (s) {  case 'debug':  return Mode.Debug;  case 'release':  return Mode.Release;  default:  return null;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","indexPageLoad","{  return function(dispatch) {  dispatch(navigateToIndex());   if (code) {  dispatch(editCode(code));  } else if (gist) {  dispatch(performGistLoad(gist));  }   if (version) {  const channel = parseChannel(version);  if (channel) { dispatch(changeChannel(channel)); }  }   if (modeString) {  const mode = parseMode(modeString);  if (mode) { dispatch(changeMode(mode)); }  }  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","helpPageLoad","{  return navigateToHelp(); }"
"../test-repos/integer32llc_rust-playground/ui/frontend/actions.ts","showExample","{  return function(dispatch) {  dispatch(navigateToIndex());  dispatch(editCode(code));  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/uss-router/index.ts","createRouter","{  let doingUpdateFromBrowser = false; // Avoid immediately PUSHing the state again  let interestingPrevState;   // Watch changes to the Redux state  store.subscribe(() => {  if (doingUpdateFromBrowser) { return; }   const nextState = store.getState();  const interestingNextState = stateSelector(nextState);   if (!isEqual(interestingNextState, interestingPrevState)) {  const nextLocation = stateToLocation(nextState);   history.push(nextLocation);   interestingPrevState = interestingNextState;  }  });   const dispatchBrowserLocationChange = nextLocation => {  const action = locationToAction(nextLocation);  if (action) {  doingUpdateFromBrowser = true;  store.dispatch(action);  doingUpdateFromBrowser = false;  }  };   // Watch changes to the browser state  history.listen((nextLocation, historyAction) => {  if (historyAction === 'POP') {  dispatchBrowserLocationChange(nextLocation);  }  });   // Load initial browser state  dispatchBrowserLocationChange(history.location);   // Now that we've set up any initial state, we keep it so we can  // tell when the location needs to change.  interestingPrevState = stateSelector(store.getState());   return {  provisionalLocation: action => {  const state = store.getState();  const tempStore = createStore(reducer, state);  const a = action();  tempStore.dispatch(a);  const maybeState = tempStore.getState();  return stateToLocation(maybeState);  },  }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/versions.ts","crates","{  switch (action.type) {  case actions.VERSIONS_LOAD_SUCCEEDED: {  const { stable, beta, nightly } = action;  return { stable, beta, nightly };  }  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/position.ts","position","{  switch (action.type) {  case actions.GOTO_POSITION: {  const { line, column } = action;  return { ...state, line, column };  }  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/meta.ts","meta","{  switch (action.type) {  case actions.ActionType.ChangeFocus:  return { ...state, focus: action.focus };   case actions.REQUEST_CLIPPY:  return { ...state, focus: 'clippy' };   case actions.ActionType.CompileLlvmIrRequest:  return { ...state, focus: 'llvm-ir' };   case actions.ActionType.CompileMirRequest:  return { ...state, focus: 'mir' };   case actions.ActionType.CompileWasmRequest:  return { ...state, focus: 'wasm' };   case actions.ActionType.CompileAssemblyRequest:  return { ...state, focus: 'asm' };   case actions.ActionType.ExecuteRequest:  return { ...state, focus: 'execute' };   case actions.REQUEST_FORMAT:  return { ...state, focus: 'format' };  case actions.FORMAT_SUCCEEDED:  case actions.FORMAT_FAILED:  return { ...state, focus: null };   case actions.REQUEST_GIST_LOAD:  case actions.REQUEST_GIST_SAVE:  return { ...state, focus: 'gist' };   default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/llvmIr.ts","llvmIr","{  switch (action.type) {  case ActionType.CompileLlvmIrRequest:  return start(DEFAULT, state);  case ActionType.CompileLlvmIrSucceeded: {  const { code = '', stdout = '', stderr = '' } = action;  return finish(state, { code, stdout, stderr });  }  case ActionType.CompileLlvmIrFailed:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/gist.ts","gist","{  switch (action.type) {  case actions.REQUEST_GIST_LOAD:  case actions.REQUEST_GIST_SAVE:  return start(DEFAULT, state);   case actions.GIST_LOAD_SUCCEEDED:  case actions.GIST_SAVE_SUCCEEDED: {  const { id, url, channel } = action;  return finish(state, { id, url, channel });  }   case actions.GIST_LOAD_FAILED:  case actions.GIST_SAVE_FAILED:  return finish(state, { error: 'Some kind of error' });   default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/mir.ts","mir","{  switch (action.type) {  case ActionType.CompileMirRequest:  return start(DEFAULT, state);  case ActionType.CompileMirSucceeded: {  const { code = '', stdout = '', stderr = '' } = action;  return finish(state, { code, stdout, stderr });  }  case ActionType.CompileMirFailed:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/assembly.ts","assembly","{  switch (action.type) {  case ActionType.CompileAssemblyRequest:  return start(DEFAULT, state);  case ActionType.CompileAssemblySucceeded: {  const { code = '', stdout = '', stderr = '' } = action;  return finish(state, { code, stdout, stderr });  }  case ActionType.CompileAssemblyFailed:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/wasm.ts","wasm","{  switch (action.type) {  case ActionType.CompileWasmRequest:  return start(DEFAULT, state);  case ActionType.CompileWasmSucceeded: {  const { code = '', stdout = '', stderr = '' } = action;  return finish(state, { code, stdout, stderr });  }  case ActionType.CompileWasmFailed:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/format.ts","format","{  switch (action.type) {  case actions.REQUEST_FORMAT:  return start(DEFAULT, state);  case actions.FORMAT_SUCCEEDED:  case actions.FORMAT_FAILED:  return finish(state);  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/execute.ts","execute","{  switch (action.type) {  case ActionType.ExecuteRequest:  return start(DEFAULT, state);  case ActionType.ExecuteSucceeded: {  const { stdout = '', stderr = '' } = action;  return finish(state, { stdout, stderr });  }  case ActionType.ExecuteFailed:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/clippy.ts","clippy","{  switch (action.type) {  case actions.REQUEST_CLIPPY:  return start(DEFAULT, state);  case actions.CLIPPY_SUCCEEDED: {  const { stdout = '', stderr = '' } = action;  return finish(state, { stdout, stderr });  }  case actions.CLIPPY_FAILED:  return finish(state, { error: action.error });  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/sharedStateManagement.ts","start","{  const { requestsInProgress } = state;  return { ...zeroState, requestsInProgress: requestsInProgress + 1 }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/output/sharedStateManagement.ts","finish","{  const { requestsInProgress } = state;  return { ...state, ...newState, requestsInProgress: requestsInProgress - 1 }; }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/crates.ts","crates","{  switch (action.type) {  case actions.CRATES_LOAD_SUCCEEDED:  return sortBy(action.crates, c => c.name);  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/page.ts","page","{  switch (action.type) {  case ActionType.SetPage:  return action.page;  default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/code.ts","code","{  switch (action.type) {  case actions.REQUEST_GIST_LOAD:  return '';  case actions.GIST_LOAD_SUCCEEDED:  return action.code;   case actions.EDIT_CODE:  return action.code;   case actions.FORMAT_SUCCEEDED:  return action.code;   default:  return state;  } }"
"../test-repos/integer32llc_rust-playground/ui/frontend/reducers/configuration.ts","configuration","{  switch (action.type) {  case ActionType.ToggleConfiguration:  return { ...state, shown: !state.shown };  case ActionType.ChangeEditor:  return { ...state, editor: action.editor };  case ActionType.ChangeKeybinding:  return { ...state, keybinding: action.keybinding };  case ActionType.ChangeTheme:  return { ...state, theme: action.theme };  case ActionType.ChangeOrientation:  return { ...state, orientation: action.orientation };  case ActionType.ChangeAssemblyFlavor:  return { ...state, assemblyFlavor: action.assemblyFlavor };  case ActionType.ChangeDemangleAssembly:  return { ...state, demangleAssembly: action.demangleAssembly };  case ActionType.ChangeProcessAssembly:  return { ...state, processAssembly: action.processAssembly };  case ActionType.ChangeChannel:  return { ...state, channel: action.channel };  case ActionType.ChangeMode:  return { ...state, mode: action.mode };  default:  return state;  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/test/Junctions.test.ts","root","{  let pageTemplate = createPageTemplate({  title: 'Test',  params: ['redirectTo'],  component: null,  })   return createJunctionTemplate({  children: {  '/test': pageTemplate,  },  component: null,  })  }"
"../test-repos/jamesknelson_junctions/packages/junctions/examples/Blog.ts","ArticleComponent","{  let { page } = props  return null }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/JunctionTemplate.ts","createJunctionTemplate","{  let helpers = { split: split }  let options = typeof getOptions === 'function' ? getOptions(helpers) : getOptions   if (!options) {  throw new Error(`createJunction() was supplied a function that doesn't return any value!`)  }  if (!options.children) {  if (process.env.NODE_ENV !== 'production') {  console.warn(`createJunction() was called without a 'children' option, but a junction without children doesn't make any sense!`)  }  options.children = {} as any  }   // Wildcards in compiled patterns are null (\0) characters, so they'll  // always be sorted to the top. As such, by sorting the patterns, the  // most specific (i.e. without wildcard) will always be at the bottom.  let compiledPatterns =  Object.keys(options.children)  .map(pattern => compilePattern(pattern, options.children[pattern]))  .sort((x, y) => compareStrings(x.relativeKey, y.relativeKey))   if (process.env.NODE_ENV !== 'production') {  let {  children,  meta,  params,  component,  ...other  } = options   if (!('component' in options)) {  console.warn(`createJunction() was called without a 'component' option, where you'll usually need to provide one. If you're sure you don't need a component, pass a value of 'null'.`)  }   let unknownKeys = Object.keys(other)  if (unknownKeys.length) {  console.warn(`createJunction() received unknown options ${unknownKeys.map(x => `'${x}'`).join(', ')}.`)  }   if (compiledPatterns.length === 0) {  console.warn(`createJunction() was called with an empty object {} for 'children'. This doesn't make any sense.`)  }   // Check to make sure that none of the junction supplied as patterns  // may intefere with each other.  let len = compiledPatterns.length  if (compiledPatterns.length >= 2) {  let previousPattern = compiledPatterns[len - 1]  for (let i = len - 2; i >= 0; i--) {  let pattern = compiledPatterns[i]   // If previous pattern matches this one, and doesn't completely  // replace it, and either item is a junction, then there could  // be a conflict.  // TODO: this warning will have false positives when a wildcard  // is on a page and the junction is on a more specific element.  let replacedKey = pattern.relativeKey.replace(previousPattern.relativeRegExp, '')  if (replacedKey !== pattern.relativeKey && replacedKey.length > 0) {  if ((previousPattern.template.type === 'Template' && previousPattern.template.templateType === 'Junction') ||  (pattern.template.type === 'Template' && pattern.template.templateType === 'Junction'))  console.warn(`createJunction() received Junctions for patterns '${previousPattern.relativePattern}' and '${pattern.relativePattern}', but this may lead to multiple junctions sharing the same URL.`)  }   previousPattern = pattern  }  }   // Check for missing mountables on patterns  for (let i = 0; i < len; i++) {  if (!compiledPatterns[i].template) {  let pattern = compiledPatterns[i].relativePattern  console.warn(`createJunction() received '${typeof compiledPatterns[i].template}' for pattern '${pattern}'!`) }  }   // Check that a junction hasn't been supplied at '/', as the junction  // could interfere with this junction.  let indexPattern = compiledPatterns.find(pattern => pattern.relativeKey === '/')  if (indexPattern) {  // Note that if we receive a split, we can't check the type, as we  // won't know it until the split is loaded. But the same rules  // still apply!  if (indexPattern.template.type === 'Template' && indexPattern.template.templateType === 'Junction') {  console.warn(`createJunction() received a Junction at the '/' pattern, but '/' must be a Page or a Redirect!`)  }  }  }   return class extends JunctionMatcher<JunctionTemplate<Meta, Component, Children>> {  static children = options.children  static meta = options.meta as Meta  static component = options.component as Component  static params = options.params || []  static compiledPatterns = compiledPatterns  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/JunctionTemplate.ts","split","{  return {  type: 'AsyncObjectContainer',  status: undefined,  getter: getter,  value: <any>undefined  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/JunctionTemplate.ts","compareStrings","{ return (a<b?-1:(a>b?1:0)); }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/PageTemplate.ts","createPageTemplate","{  let getter: (routerConfig: RouterConfig) => Content | Promise<Content>  if (options.getContent) {  let getContent = options.getContent  getter = (routerConfig: RouterConfig) =>  getContent(createContentHelpers(routerConfig))  }  else {  getter = (() => {}) as any  }   if (process.env.NODE_ENV !== 'production') {  let {  params,  title,  component,  meta,  getContent,  ...other  } = options   if (!('component' in options)) {  console.warn(`createPage() was called without a 'component' option, where you'll usually need to provide one. If you're sure you don't need a component, pass a value of 'null'.`)  }   let unknownKeys = Object.keys(other)  if (unknownKeys.length) {  console.warn(`createPage() received unknown options ${unknownKeys.map(x => `'${x}'`).join(', ')}.`)  }   if (title === undefined) {  console.warn(`createPage() must be supplied a 'title' option. If you don't want to give your page a title, pass 'null' as the title.`)  }  }   let contentContainer: PageContentContainer<Content> = {  type: 'AsyncObjectContainer',  status: undefined,  getter,  value: <any>undefined  }  return class extends PageMatcher<Meta, Component, Content> {  static title = options.title  static component = options.component as Component  static meta = options.meta as Meta  static params = options.params || []  static contentContainer = contentContainer  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/BrowserNavigation.ts","announce","{  let announcer = document.getElementById(announcerId)  manner = manner || 'polite'   if (announcer) {  announcer.setAttribute('aria-live', 'off')  announcer.setAttribute('aria-live', manner)  announcer.innerHTML = message  clearTimeout(announcerTimeout);  announcerTimeout = setTimeout(() => {  if (announcer) announcer.innerHTML = ''  announcerTimeout = null  }, 500)  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/BrowserNavigation.ts","createAnnouncerDiv","{  if (announcerDiv) {  return announcerDiv  }   announcerDiv = document.createElement('div') announcerDiv.id = announcerId  announcerDiv.setAttribute('aria-live', 'polite')   let style = announcerDiv.style  style.position = 'absolute'  style.left = '-10000px'  style.top = 'auto'  style.width = '1px'  style.height = '1px'  style.overflow = 'hidden'   document.body.appendChild(announcerDiv) }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","concatLocations","{  let result = typeof firstLocation === 'string'  ? { pathname: firstLocation } as Location  : firstLocation   for (let i = 0; i < locations.length; i++) {  let location = locations[i]  if (typeof location === 'string') {  location = parseLocationString(location)  }  result = {  ...result,  pathname: joinPaths(result.pathname, location.pathname),  search: joinQueryStrings(result.search, location.search, '?'),  hash: joinQueryStrings(result.hash, location.hash, '#'),  state: result.state || location.state ? Object.assign({}, result.state, location.state) : undefined,  }  }  return result }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","parseLocationString","{  let matches = parsePattern.exec(locationString)  if (!matches) {  throw new Error('Tried to parse a non-URI object.')  }  return {  pathname: matches[2],  search: matches[6],  hash: matches[7],  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","joinPaths","{  if (!b) {  return a  }  if (a[a.length-1] === '/') {  a = a.substr(0, a.length - 1)  }  if (b[0] === '/') {  b = b.substr(1)  }  return a + '/' + b }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","joinQueryStrings","{  if (!left || left[0] !== leadingCharacter) {  return right  }  if (!right || right[0] !== leadingCharacter) {  return left  }  return leadingCharacter+left.slice(1)+'&'+right.slice(1) }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","createHref","{  return location.pathname+(location.search || '')+(location.hash || '') }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","parseQuery","{  if (!queryString || queryString[0] != leadingCharacter) {  return {}  }   let query = {}  let queryParts = queryString.slice(1).split('&')  for (let i = 0, len = queryParts.length; i < len; i++) {  const x = queryParts[i].split('=')  query[x[0]] = x[1] ? decodeURIComponent(x[1]) : ''  }  return query }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Location.ts","stringifyQuery","{  let keys = Object.keys(query)  if (keys.length === 0) {  return ''  }  let parts: string[] = []  for (let i = 0, len = keys.length; i < len; i++) {  let key = keys[i]  let value = String(query[key])  parts.push(value === '' ? key : key+'='+encodeURIComponent(value))  }  return leadingCharacter + parts.join('&')  }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/RouterConfig.ts","createRouterConfig","{  return {  rootJunctionTemplate: options.rootJunctionTemplate,  rootMountedPattern: createRootMountedPattern(options.rootJunctionTemplate, options.rootPath),  onEvent: options.onEvent || (() => {})  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","createRootMountedPattern","{  let rootPattern: CompiledPattern =  relativePath  ? compilePattern(relativePath, template)  : {  relativePattern: relativePath || '',  relativeKey: '',  relativeRegExp: new RegExp(''),  template  }  if (rootPattern.relativePathParams && rootPattern.relativePathParams.length > 0) {  throw new Error('Your root path may not contain parameters')  }   return {  ...rootPattern,  params: [],  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","compilePattern","{  let processedPattern = pattern  if (processedPattern.length > 1 && processedPattern.substr(-1) === '/') {  if (process.env.NODE_ENV !== 'production') {  console.warn(`The pattern '${pattern}' ends with the character '/', so it has been automatically removed. To avoid this warning, don't add a final '/' to Junction patterns.`)  }  processedPattern = processedPattern.substr(0, processedPattern.length - 1)  }  if (processedPattern[0] !== '/') {  if (process.env.NODE_ENV !== 'production') {  console.warn(`The pattern '${pattern}' does not start with the character '/', so it has been automatically added. To avoid this warning, make sure to add the leading '/' to all Junction patterns.`)  }  processedPattern = '/'+processedPattern  }  if (/\/{2,}/.test(processedPattern)) {  if (process.env.NODE_ENV !== 'production') {  console.warn(`The pattern '${pattern} has adjacent '/' characters, which have been combined into single '/' characters. To avoid this warning, don't use adjacent '/' characters within patterns.`)  }  processedPattern = processedPattern.replace(/\/{2,}/g, '/')  }  if (!/^([A-Za-z0-9\$\-_\.+!*'\(\),\/]|\/:)+$/.test(processedPattern)) {  if (process.env.NODE_ENV !== 'production') {  console.warn(`The pattern '${pattern}' uses non-URL safe characters. The URL-safe characters are: A-Z a-z 0-9 $ - _ . + ! * ' ( ) ,`)  }  }  if (processedPattern.length === 0) {  throw new Error(`You cannot use an empty string '' as a Junction pattern!`)  }  let parts = processedPattern.split('/').slice(1)  let pathParams: string[] = []  let keyParts: string[] = []  let regExpParts = ['^']  for (let i = 0; i < parts.length; i++) {  let part = parts[i]  if (part.length > 1 && part[0] === ':') {  pathParams.push(part.slice(1))  keyParts.push(KEY_WILDCARD)  regExpParts.push('([^/]+)')  }  else {  keyParts.push(part)  regExpParts.push(escapeRegExp(part))  }  }  return {  relativePattern: processedPattern,  relativeKey: keyParts.join('/'),  relativePathParams: pathParams.length ? pathParams : undefined,  relativeRegExp: new RegExp(regExpParts.join('/')),  template: template,  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","createChildMountedPattern","{  if (process.env.NODE_ENV !== 'production') {  if (compiledPattern.relativePathParams) { let doubleParams = compiledPattern.relativePathParams.filter(param => parentPattern.params.indexOf(param) !== -1)  if (doubleParams.length) {  console.error(`The pattern '${compiledPattern.relativePattern}' uses the param names ${doubleParams.map(x => `'${x}'`).join(', ')}, which have already been used by a parent junction.`)  }  }  }   return {  params: parentPattern.params.concat(compiledPattern.relativePathParams || []),  ...compiledPattern,  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","addParamsToMountedPattern","{  let relativeSearchParams = params || []  // Ensure that any params in the mount's path are also specified by the  // mounted junction's 'params' config.  if (pattern.relativePathParams) {  for (let i = pattern.relativePathParams.length - 1; i >= 0; i--) {  let pathParam = pattern.relativePathParams[i]  let index = relativeSearchParams.indexOf(pathParam)  if (index === -1) {  if (process.env.NODE_ENV !== 'production') {  console.warn(`The path parameter ':${pathParam}' was not specified in its associated junctions' 'params' configuration option. To avoid this warning, always specify your junctions' 'params' object.`)  }  }  else {  relativeSearchParams.splice(index, 1)  }  } }   // If there are no search params, the mount won't chang  if (relativeSearchParams.length === 0) {  return pattern  }  // Ensure that none of our search param names are already used by parent  // junctions.  if (process.env.NODE_ENV !== 'production') {  let doubleParams = relativeSearchParams.filter(param => pattern.params.indexOf(param) !== -1)  if (doubleParams.length) {  console.error(`The junction mounted at '${pattern.relativePattern}' uses the param names ${doubleParams.map(x => `'${x}'`).join(', ')}, which have already been used by a parent junction.`)  }  }  return {  ...pattern,  relativeSearchParams: relativeSearchParams.length ? relativeSearchParams : undefined,  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","matchMountedPatternAgainstLocation","{  let match = pattern.relativeRegExp.exec(location.pathname)  let params = {}   if (!match) {  return  }   // Set path params using RegExp match  if (pattern.relativePathParams) {  for (let i = 0; i < pattern.relativePathParams.length; i++) {  let paramName = pattern.relativePathParams[i]  params[paramName] = match[i+1]  }  }   let matchedQueryParts = {}  let remainingQueryParts = parseQuery(location.search)  if (pattern.relativeSearchParams) {  for (let i = 0; i < pattern.relativeSearchParams.length; i++) {  let paramName = pattern.relativeSearchParams[i]  if (remainingQueryParts[paramName] !== undefined) {  params[paramName] = remainingQueryParts[paramName]  matchedQueryParts[paramName] = remainingQueryParts[paramName]  delete remainingQueryParts[paramName]  }  }  }   let matchedLocation = {  pathname: match[0],  search: stringifyQuery(matchedQueryParts),  }  let remainingLocation = {  pathname: location.pathname.slice(match[0].length),  search: stringifyQuery(remainingQueryParts),  hash: location.hash,  state: location.state,  }   return {  params: params,  matchedLocation: matchedLocation,  remainingLocation: remainingLocation.pathname !== '' || remainingLocation.search !== '' ? remainingLocation : undefined  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/Patterns.ts","escapeRegExp","{  return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/RedirectTemplate.ts","createRedirectTemplate","{  let toLocation =  typeof to === 'string'  ? { pathname: to }  : to   return class extends RedirectMatcher {  static to = toLocation  static component = <never>undefined  static params = []  static meta = meta  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","createContentHelpers","{  function getPages<Pathnames extends { [name: string]: string }>(pathnames: Pathnames): Promise<{ [K in keyof Pathnames]: Page }>;  function getPages(pathname: string): Promise<Page>;  function getPages<Pathnames extends { [name: string]: string } | string>(pathnames: Pathnames): any {  if (typeof pathnames === 'string') {  return getPageNode({ pathname: pathnames }).then(page =>  page ? Promise.resolve(page) : Promise.reject(undefined)  )  }  else {  let keys = Object.keys(pathnames)  let promises: Promise<Page | undefined>[] = []  for (let i = 0; i < keys.length; i++) {  let key = keys[i]  promises.push(getPageNode({ pathname: pathnames[key] }))  }  return Promise.all(promises).then(values => {  let result = {} as { [K in keyof Pathnames]: Page }  for (let i = 0; i < keys.length; i++) {  let value = values[i]  if (value === undefined) {  return Promise.reject(undefined)  }  result[keys[i]] = value  }  return Promise.resolve(result)  })  }  }   /**  * Return a promise to a RouteSemgent that corresponds to the given  * pathname, or reject the promise if a corresponding segment can't be  * found.  */  function getRouteSegment(pathname: string): Promise<RouteSegment> {  let deferred = new Deferred<RouteSegment>()  let searchLocation = {  // Add a trailing slash, in case the pathname corresponds directly  // to a junction with no '/' child -- otherwise no match will be  // found.  pathname: pathname.substr(-1) === '/' ? pathname : pathname + '/'  }  processFinalNodeWithoutContent(searchLocation, (route?: Route) => {  if (route) {  let lastSegment = route[route.length - 1]  if (lastSegment.location.pathname === pathname) {  deferred.resolve(lastSegment)  }  else if (lastSegment.location.pathname === pathname+'/') {  // If the user requested a segment without a trailing  // slash, but we found one *with* a trailing slash, then  // we've found a child of a requested junction.  let lastJunction = route[route.length - 2]  if (lastJunction) {  deferred.resolve(lastJunction)  }  }  }  deferred.reject(undefined)  })  return deferred.promise  }   async function getPageMap(junction: Junction, predicate: JunctionMapPredicate = defaultPredicate): Promise<PageMap> {  let map = {} as PageMap  let template = junction.template as JunctionTemplate  let children = Object.entries(template.children) as [string, Template | AsyncTemplate][]  let possiblePromises = [] as Promise<RouteSegment | undefined>[]  let queue = [junction]  while (queue.length) {  let junction = queue.shift() as Junction  for (let [pattern, template] of children) {  let path = junction.location.pathname + pattern  let segment = await getRouteSegment(path)  if (segment.type !== 'redirect' && predicate(segment)) {  if (segment.type === 'junction') {  queue.push(junction)  }  else {  map[path] = segment  }  }  }  }  return map  }   function getPageNode(location: Location): Promise<Page | undefined> {  let deferred = new Deferred<Page | undefined>()  processFinalNodeWithoutContent(location, (route?: JunctionRoute) => {  let lastSegment = route && route[route.length - 1]  if (!lastSegment || lastSegment.type === 'junction') {  deferred.resolve(undefined)  }  else if (lastSegment.type === 'page') {  return deferred.resolve(lastSegment)  }  else {  getPageNode(lastSegment.to).then(deferred.resolve)  }  })  return deferred.promise  }   function processFinalNodeWithoutContent(location: Location, callback: (route?: JunctionRoute) => void) {  let match = matchMountedPatternAgainstLocation(routerConfig.rootMountedPattern, location)  if (!match) {  callback()  }  else {  let deferred = new Deferred<Page | undefined>()   const handleRouteChange = () => {  if (!rootMatcher.isBusy()) {  callback(rootMatcher.getRoute())  rootMatcher.willUnmount()  }  }   let rootMatcher = new routerConfig.rootJunctionTemplate({  parentLocationPart: { pathname: '' },  matchableLocationPart: location,  mountedPattern: routerConfig.rootMountedPattern,  onChange: handleRouteChange,  routerConfig: routerConfig,  shouldFetchContent: false,  })   handleRouteChange()  }  }   return {  getPages,  getRouteSegment,  getPageMap,  } }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getPages","no body"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getPages","no body"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getPages","{  if (typeof pathnames === 'string') {  return getPageNode({ pathname: pathnames }).then(page =>  page ? Promise.resolve(page) : Promise.reject(undefined)  )  }  else {  let keys = Object.keys(pathnames)  let promises: Promise<Page | undefined>[] = []  for (let i = 0; i < keys.length; i++) {  let key = keys[i]  promises.push(getPageNode({ pathname: pathnames[key] }))  }  return Promise.all(promises).then(values => {  let result = {} as { [K in keyof Pathnames]: Page }  for (let i = 0; i < keys.length; i++) {  let value = values[i]  if (value === undefined) {  return Promise.reject(undefined)  }  result[keys[i]] = value  }  return Promise.resolve(result)  })  }  }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getRouteSegment","{  let deferred = new Deferred<RouteSegment>()  let searchLocation = {  // Add a trailing slash, in case the pathname corresponds directly  // to a junction with no '/' child -- otherwise no match will be  // found.  pathname: pathname.substr(-1) === '/' ? pathname : pathname + '/'  }  processFinalNodeWithoutContent(searchLocation, (route?: Route) => {  if (route) {  let lastSegment = route[route.length - 1]  if (lastSegment.location.pathname === pathname) {  deferred.resolve(lastSegment)  }  else if (lastSegment.location.pathname === pathname+'/') {  // If the user requested a segment without a trailing  // slash, but we found one *with* a trailing slash, then  // we've found a child of a requested junction.  let lastJunction = route[route.length - 2]  if (lastJunction) {  deferred.resolve(lastJunction)  }  }  }  deferred.reject(undefined)  })  return deferred.promise  }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getPageMap","{  let map = {} as PageMap  let template = junction.template as JunctionTemplate  let children = Object.entries(template.children) as [string, Template | AsyncTemplate][]  let possiblePromises = [] as Promise<RouteSegment | undefined>[]  let queue = [junction]  while (queue.length) {  let junction = queue.shift() as Junction  for (let [pattern, template] of children) {  let path = junction.location.pathname + pattern  let segment = await getRouteSegment(path)  if (segment.type !== 'redirect' && predicate(segment)) {  if (segment.type === 'junction') {  queue.push(junction)  }  else {  map[path] = segment  }  }  }  }  return map  }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","getPageNode","{  let deferred = new Deferred<Page | undefined>()  processFinalNodeWithoutContent(location, (route?: JunctionRoute) => {  let lastSegment = route && route[route.length - 1]  if (!lastSegment || lastSegment.type === 'junction') {  deferred.resolve(undefined)  }  else if (lastSegment.type === 'page') {  return deferred.resolve(lastSegment)  }  else {  getPageNode(lastSegment.to).then(deferred.resolve)  }  })  return deferred.promise  }"
"../test-repos/jamesknelson_junctions/packages/junctions/src/ContentHelpers.ts","processFinalNodeWithoutContent","{  let match = matchMountedPatternAgainstLocation(routerConfig.rootMountedPattern, location)  if (!match) {  callback()  }  else {  let deferred = new Deferred<Page | undefined>()   const handleRouteChange = () => {  if (!rootMatcher.isBusy()) {  callback(rootMatcher.getRoute())  rootMatcher.willUnmount()  }  }   let rootMatcher = new routerConfig.rootJunctionTemplate({  parentLocationPart: { pathname: '' },  matchableLocationPart: location,  mountedPattern: routerConfig.rootMountedPattern,  onChange: handleRouteChange,  routerConfig: routerConfig,  shouldFetchContent: false,  })   handleRouteChange()  }  }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/longest-common-subsequence/longest-common-subsequence.ts","lcsLengths","{  const lengthA = seqA.length;  const lengthB = seqB.length;   const lengths: number[][] = new Array(lengthA + 1);  fill(lengths, () => new Array(lengthB + 1));   range(0, lengthA).forEach(i => (lengths[i][0] = 0));  range(0, lengthB).forEach(i => (lengths[0][i] = 0));   range(0, lengthA - 1).forEach(indexA => {  range(0, lengthB - 1).forEach(indexB => {  const charA = seqA[indexA];  const charB = seqB[indexB];   if (charA === charB) {  lengths[indexA + 1][indexB + 1] = lengths[indexA][indexB] + 1;  } else {  const subSeqALength = lengths[indexA][indexB + 1];  const subSeqBLength = lengths[indexA + 1][indexB];  lengths[indexA + 1][indexB + 1] = Math.max(subSeqALength, subSeqBLength);  }  });  });   return lengths; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/longest-common-subsequence/longest-common-subsequence.ts","walkLCS","{  if (indexA === 0 || indexB === 0) return '';   if (seqA[indexA - 1] === seqB[indexB - 1]) {  const subLCS = walkLCS(lengths, seqA, seqB, indexA - 1, indexB - 1);  return subLCS + seqA[indexA - 1];  } else if (lengths[indexA - 1][indexB] >= lengths[indexA][indexB - 1]) {  return walkLCS(lengths, seqA, seqB, indexA - 1, indexB);  } else {  return walkLCS(lengths, seqA, seqB, indexA, indexB - 1);  } }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/longest-common-subsequence/longest-common-subsequence.ts","findLCS","{  const lengths = lcsLengths(seqA, seqB);  const lcs = walkLCS(lengths, seqA, seqB, seqA.length, seqB.length);   return lcs; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/priority-queue/priority-queue.ts","maximum","{  return head(queue); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/priority-queue/priority-queue.ts","extractMax","{  const max = maximum(queue);   setHead(queue, last(queue));  queue.pop();  maxHeapify(queue, 0, queue.length);   return max; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/priority-queue/priority-queue.ts","isParentInvalid","{  return queue[parent(index)] < queue[index]; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/priority-queue/priority-queue.ts","increasePriority","{  queue[index] += increase;   // Ensure the queue is still a valid max-heap from the index to the root  let validHeapIndex = index;  while (isParentInvalid(queue, validHeapIndex) && validHeapIndex !== 0) {  swap(queue, validHeapIndex, parent(validHeapIndex));  validHeapIndex = parent(validHeapIndex);  }   return queue; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/priority-queue/priority-queue.ts","insert","{  queue.push(0);  increasePriority(queue, queue.length - 1, value);   return queue; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/huffman/huffman.ts","huffman","{  /**  * Create a min priority queue with min-heap. An almost identical implementation  * can be found in 'algorithms/misc/priority-queue' but for max priority.  */  const queue = new MinHeap((a: Frequency, b: Frequency) => a.frequency - b.frequency);  frequences.forEach(freq => queue.insert(freq));   range(0, frequences.length - 2).forEach(() => {  const left: Frequency = queue.removeHead();  const right: Frequency = queue.removeHead();  const merged = {  frequency: left.frequency + right.frequency,  left,  right,  };   queue.insert(merged);  });   return queue.removeHead(); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/inversions-count/inversions-count.ts","merge","{  const left = input.slice(start, mid);  const right = input.slice(mid, end);   left[left.length] = -Infinity as any;  right[right.length] = -Infinity as any;   let inversionCount = 0;   range(start, end - 1).forEach(index => {  if (head(left) > head(right)) {  inversionCount += right.length - 1; // Do not include Infinity in the count  input[index] = left.shift();  } else {  input[index] = right.shift();  }  });   return inversionCount; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/inversions-count/inversions-count.ts","countInversions","{  if (end - start <= 1) return 0;   const mid = Math.floor((start + end) / 2);  const leftCount = countInversions(input, start, mid);  const rightCount = countInversions(input, mid, end);   return leftCount + rightCount + merge(input, start, mid, end); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/maximum-subarray/maximum-subarray.ts","maxCrossSubarray","{  let leftIndex = -1;  let leftMaxSum = -Infinity;  let sum = 0;   reverseRange(mid, start).forEach(index => {  sum += input[index];  if (sum > leftMaxSum) {  leftMaxSum = sum;  leftIndex = index;  }  });   let rightIndex = -1;  let rightMaxSum = -Infinity;  sum = 0;  range(mid + 1, end).forEach(index => {  sum += input[index];  if (sum > rightMaxSum) {  rightMaxSum = sum;  rightIndex = index;  }  });   return {  start: leftIndex,  end: rightIndex,  sum: leftMaxSum + rightMaxSum,  }; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/maximum-subarray/maximum-subarray.ts","maxSubarray","{  if (end - start === 0) return { start, end, sum: input[start] };   const mid = Math.floor((start + end) / 2);  const leftMax = maxSubarray(input, start, mid);  const rightMax = maxSubarray(input, mid + 1, end);  const crossMax = maxCrossSubarray(input, start, mid, end);   if (leftMax.sum >= rightMax.sum && leftMax.sum >= crossMax.sum) {  return leftMax;  } else if (rightMax.sum >= leftMax.sum && rightMax.sum >= crossMax.sum) {  return rightMax;  } else {  return crossMax;  } }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/activity-selection/activity-selection.ts","activitySelector","{  // The first activity always gets selected  const selected = [activities[0]];  let lastActivity: Activity = activities[0];   /**  * Always select the first activity which starts right after the last one. It's  * also the one which finishes before any other since the input list is ordered * by finish time.  * * Proof of optimality can be found here:  * @url https://en.wikipedia.org/wiki/Activity_selection_problem#Proof_of_optimality  */  range(1, activities.length - 1).forEach(index => {  const currentActivity = activities[index];   if (currentActivity.start >= lastActivity.finish) {  selected.push(currentActivity);  lastActivity = currentActivity;  }  });   return selected; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/change-making/change-making.ts","changeMaking","{  // Memoization array used to store best results for problems up to `amount` dimension  const results: number[] = new Array(amount + 1);  results.fill(-Infinity);   // Zero coins are needed for amount 0  results[0] = 0;  // Only one coin is needed if the amount is equal to one of the coins  coins.forEach(coin => (results[coin] = 1));   return minCoins(coins, results, amount); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/change-making/change-making.ts","minCoins","{  if (results[amount] >= 0) return results[amount];   let result: number = Infinity;   coins.filter(coin => coin <= amount).forEach(coin => {  result = Math.min(result, 1 + minCoins(coins, results, amount - coin));  });   results[amount] = result;   return result; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/rod-cutting/rod-cutting.ts","topDownCutRod","{  const bestPrices: number[] = new Array(length + 1);  bestPrices.fill(-Infinity);   const bestFirstCuts: number[] = new Array(length + 1);   return topDownCutRodAux(prices, length, bestPrices, bestFirstCuts); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/rod-cutting/rod-cutting.ts","topDownCutRodAux","{  if (bestPrices[length] >= 0) return { bestPrices, bestFirstCuts };   let maxCutPrice = -Infinity;  let bestFirstCut: number = -1;   if (length === 0) maxCutPrice = 0;  else {  range(1, length).forEach(firstCut => {  const remainingRod = topDownCutRodAux(prices, length - firstCut, bestPrices, bestFirstCuts);  const cutPrice = prices[firstCut] + remainingRod.bestPrices[length - firstCut];   if (cutPrice > maxCutPrice) {  maxCutPrice = cutPrice;  bestFirstCut = firstCut;  }  });  }   bestPrices[length] = maxCutPrice;  bestFirstCuts[length] = bestFirstCut;   return {  bestPrices,  bestFirstCuts,  }; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/rod-cutting/rod-cutting.ts","bottomUpCutRod","{  const bestPrices: number[] = new Array(length + 1);  const bestFirstCuts: number[] = new Array(length + 1);   bestPrices.fill(-Infinity);  // The price of rod of length 0 is 0  bestPrices[0] = 0;   range(1, length).forEach(subLength => {  let maxCutPrice = -Infinity;   range(1, subLength).forEach(firstCut => {  const cutPrice = prices[firstCut] + bestPrices[subLength - firstCut];  if (cutPrice > maxCutPrice) {  maxCutPrice = cutPrice;   bestPrices[subLength] = maxCutPrice;  bestFirstCuts[subLength] = firstCut;  }  });  });   return {  bestPrices,  bestFirstCuts,  }; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/misc/rod-cutting/rod-cutting.ts","cutRod","{  const { bestFirstCuts } =  strategy === 'bottomUp' ? bottomUpCutRod(prices, length) : topDownCutRod(prices, length);   let remainingRod = length;  const bestCuts: number[] = [];   while (remainingRod) {  bestCuts.push(bestFirstCuts[remainingRod]);  remainingRod -= bestFirstCuts[remainingRod];  }   return bestCuts; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/selection-sort/selection-sort.ts","selectionSort","{  // The last iteration can be avoided because it will already be the greatest value  range(0, input.length - 2).forEach(pivotIndex => {  let min = input[pivotIndex];  let minIndex = pivotIndex;   for (let i = pivotIndex + 1; i < input.length; i++) {  if (input[i] < min) {  min = input[i];  minIndex = i;  }  }   swap(input, minIndex, pivotIndex);  });   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/counting-sort/counting-sort.ts","countingSort","{  const result = [];  const counter = new Array(max + 1);  counter.fill(0);   input.forEach(value => (counter[value] += 1));   range(1, max).forEach(index => increaseOfPrevious(counter, index));   forEachRight(input, value => {  counter[value] -= 1;   const position = counter[value];  result[position] = value;  });   return result; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/quick-sort/quick-sort.ts","partition","{  if (randomized) swap(input, random(left, right), right);   const pivot = input[right];   let minEdge = left - 1;   range(left, right - 1).forEach(current => {  if (input[current] <= pivot) {  minEdge += 1;  swap(input, minEdge, current);  }  });   swap(input, minEdge + 1, right);   return minEdge + 1; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/quick-sort/quick-sort.ts","quickSort","{  if (start >= end) return input;   const mid = partition(input, start, end, randomized);  quickSort(input, start, mid - 1);  quickSort(input, mid + 1, end);   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/merge-sort/merge-sort.ts","merge","{  // Make a copy of the two subarrays  const left = input.slice(start, mid);  const right = input.slice(mid, end);   left[left.length] = Infinity as any;  right[right.length] = Infinity as any;   range(start, end - 1).forEach(index => {  if (head(left) <= head(right)) input[index] = left.shift();  else input[index] = right.shift();  });   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/merge-sort/merge-sort.ts","mergeSort","{  if (end - start <= 1) return [];   const mid = Math.floor((start + end) / 2);   mergeSort(input, start, mid);  mergeSort(input, mid, end);   return merge(input, start, mid, end); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/insertion-sort/insertion-sort.ts","insertionSort","{  input.forEach((pivot, pivotIndex) => {  let compareIndex = pivotIndex - 1;   while (compareIndex > -1 && input[compareIndex] > pivot) {  moveRight(input, compareIndex);  compareIndex -= 1;  }   input[compareIndex + 1] = pivot;  });   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/merge-and-insertion-sort/merge-and-insertion-sort.ts","mergeAndInsertionSort","{  if (end - start <= 1) return [];   if (end - start <= threshold) return insertionSort(input);   // Continue classic merge-sort otherwise  const mid = Math.floor((start + end) / 2);   mergeAndInsertionSort(input, start, mid);  mergeAndInsertionSort(input, mid, end);   return merge(input, start, mid, end); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","parent","{  return Math.floor((index - 1) / 2); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","left","{  return 2 * index + 1; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","right","{  return 2 * (index + 1); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","isInHeap","{  return index < heapSize; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","maxHeapify","{  const leftChild = left(index);  const rightChild = right(index);  let maxIndex = index;   if (isInHeap(leftChild, heapSize) && input[leftChild] > input[index]) {  maxIndex = leftChild;  }   if (isInHeap(rightChild, heapSize) && input[rightChild] > input[maxIndex]) {  maxIndex = rightChild;  }   if (maxIndex !== index) {  swap(input, index, maxIndex);  // Repeat max-heap check for the subtree  maxHeapify(input, maxIndex, heapSize);  }   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","buildMaxHeap","{  // All nodes from (input.length / 2) + 1 are leaves  const firstLeaf = Math.floor((input.length - 1) / 2);   reverseRange(firstLeaf).forEach(index => {  maxHeapify(input, index, input.length);  });   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/sort/heap-sort/heap-sort.ts","heapSort","{  buildMaxHeap(input);   reverseRange(input.length - 1).forEach(heapEnd => {  swap(input, 0, heapEnd);  maxHeapify(input, 0, heapEnd);  });   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","fill","{  for (let i = 0; i < array.length; i++) array[i] = valueFn(i);   return array; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","increaseOfPrevious","{  array[index] += array[index - 1]; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","moveRight","{  input[index + 1] = input[index]; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","range","{  return baseRange(from, to + 1); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","reverseRange","{  return baseRangeRight(to, from + 1); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","toSerializableTree","{  if (!root) return;   toSerializableTree(root.left, nodeConverter);  Object.assign(root, nodeConverter(root));  toSerializableTree(root.right, nodeConverter);   return root; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","setHead","{  input[0] = value;  return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/utils.ts","swap","{  const temp = input[from];  input[from] = input[to];  input[to] = temp;   return input; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.spec.ts","createBST","{  return createNode(  15,  createNode(  6,  createNode(3, createNode(2), createNode(4)),  createNode(7, null, createNode(13, createNode(9)))  ),  createNode(18, createNode(17), createNode(20))  ); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","createNode","{  const node = {  key,  left,  right,  parent: null,  };   if (left) left.parent = node;  if (right) right.parent = node;   return node; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","inOrderWalk","{  if (!node) return;   inOrderWalk(node.left);  console.log(node);  inOrderWalk(node.right); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","search","{  if (!node) return null;   if (node.key === key) return node;  else if (node.key < key) return search(node.right, key);  else return search(node.left, key); }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","minimum","{  let leftMost: Node = node;  while (leftMost !== null && leftMost.left !== null) {  leftMost = leftMost.left;  }   return leftMost; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","maximum","{  let rightMost: Node = node;  while (rightMost !== null && rightMost.right !== null) {  rightMost = rightMost.right;  }   return rightMost; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","successor","{  if (node.right !== null) return minimum(node.right);   let parent = node.parent;  let current = node;  while (parent !== null && parent.right === current) {  current = parent;  parent = parent.parent;  }   return parent; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","predecessor","{  if (node.left !== null) return node.left;   let parent = node.parent;  let current = node;  while (parent !== null && parent.left === current) {  current = parent;  parent = parent.parent;  }   return parent; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","insert","{  let parent: Node = null;  let current = tree.root;   while (current !== null) {  parent = current;   if (leaf.key >= current.key) {  current = current.right;  } else {  current = current.left;  }  }   if (parent === null) tree.root = leaf;  else if (leaf.key >= parent.key) parent.right = leaf;  else parent.left = leaf;   leaf.parent = parent; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","transplant","{  if (oldNode.parent === null) tree.root = newNode;  else if (oldNode.parent.left === oldNode) oldNode.parent.left = newNode;  else oldNode.parent.right = newNode;   if (newNode !== null) newNode.parent = oldNode.parent; }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search-tree/binary-search-tree.ts","remove","{  if (removed.left === null) transplant(tree, removed, removed.right);  else if (removed.right === null) transplant(tree, removed, removed.left);  else {  const minRight = minimum(removed.right);   if (minRight.parent !== removed) {  transplant(tree, minRight, minRight.right);  // Attach the removed node right subtree to minRight  minRight.right = removed.right;  minRight.right.parent = minRight;  }   transplant(tree, removed, minRight);  // Attach the removed node left subtree to minRight  minRight.left = removed.left;  minRight.left.parent = minRight;  } }"
"../test-repos/jiayihu_pretty-algorithms/algorithms/search/binary-search/binary-search.ts","binarySearch","{  if (start > end || value < input[start] || value > input[end]) return null;   const mid = Math.floor((end + start) / 2);  if (input[mid] === value) return mid;  else if (input[mid] < value) return binarySearch(input, value, mid + 1, end);  else return binarySearch(input, value, start, mid - 1); }"
"../test-repos/liangzeng_cqrs/src/lib/eventAlias.ts","getAlias","{  if (event instanceof Event) {  return [  `${event.actorType}.${event.actorId}.${event.type}.${event.method}.${event.sagaId}`,  `${event.actorType}.${event.actorId}.${event.type}.${event.method}.`,  `${event.actorType}.${event.actorId}.${event.type}..`,  `${event.actorType}.${event.actorId}...`,  `${event.actorType}..${event.type}..`,  `..${event.type}..`,  `${event.actorType}....`,  '....'   ]  } else {  return `${event.actorType || ''}.${event.actorId || ''}.${event.type || ''}.${event.method || ''}.${event.sagaId || ''}`;  } }"
"../test-repos/liangzeng_cqrs/src/lib/reborn.ts","reborm","{  const actor = ActorClass.parse(snap.data);  actor[loadEvents](events);  return actor; }"
"../test-repos/liangzeng_cqrs/src/lib/Domain.ts","run","{  const islock = actor[isLock](key);   if (islock) {  setTimeout(run, 2000);  } else {  const iservice = new Service(actor, that.eventbus,  (type, id, sagaId, key) => that[getActorProxy](type, id, sagaId, key),  (type, data) => that.nativeCreateActor(type, data),  prop, sagaId,roleName,role);   const service = new Proxy(function service(type, data) {  if (arguments.length === 0) {  type = prop;  data = null;  } else if (arguments.length === 1) {  data = type;  type = prop;  }  return iservice.apply(type, data)  }, {  get(target, prop) {  return iservice[prop].bind(iservice);  }  })  cxt = { service, $: service };   cxt.__proto__ = proxy;  let result  try {  result = target.call(cxt, ...args);  } catch (err) {   that.eventbus.rollback(sagaId || iservice.sagaId).then(r => reject(err));  return;  }  if (result instanceof Promise) {  result.then(result => {  resolve(result)  }).catch(err => {  that.eventbus.rollback(sagaId || iservice.sagaId).then(r => reject(err));  })  } else {  resolve(result);  }  }  }"
"../test-repos/liangzeng_cqrs/src/lib/Service.ts","tryLock","{  var isLock = await actor.lock({ key: that.key, timeout: that.timeout });  if (isLock) resolve();  else {  setTimeout(tryLock, 300);  }  }"
"../test-repos/localvoid_kivi/tests/vdom.spec.ts","injectVNode","{  vNodeInstantiate(node, undefined);  parent.insertBefore(node.ref!, nextRef as Node);  vNodeRender(node, undefined); }"
"../test-repos/localvoid_kivi/tests/vdom.spec.ts","gen","{  if (typeof item === 'number') {  return keys ? createVText(item.toString()).key(item.toString()) : createVText(item.toString());  } else if (Array.isArray(item)) {  let result: VNode[] = [];  for (let i = 0; i < item.length; i++) {  result.push(gen(item[i], keys) as VNode);  }  return result;  } else {  let e = createVElement('div').key(item.key);  if (keys) {  e.trackByKeyChildren(gen(item.children, keys) as VNode[]);  } else {  e.children(gen(item.children, keys) as VNode[]);  }  return e;  } }"
"../test-repos/localvoid_kivi/tests/vdom.spec.ts","checkInnerHtmlEquals","{  const a = createVElement('div');  const b = createVElement('div');  const c = createVElement('div');   if (keys) {  a.trackByKeyChildren(ax);  b.trackByKeyChildren(bx);  c.trackByKeyChildren(cx);  } else {  a.children(ax).disableChildrenShapeError();  b.children(bx).disableChildrenShapeError();  c.children(cx).disableChildrenShapeError();  }   const aDiv = document.createElement('div');  const bDiv = document.createElement('div');  injectVNode(aDiv, a, undefined);  injectVNode(bDiv, b, undefined);   syncVNodes(a, c, undefined);   expect(aDiv.innerHTML).to.equal(bDiv.innerHTML); }"
"../test-repos/localvoid_kivi/tests/vdom.spec.ts","getLifecycleState","{  return n.cref!.state; }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","injectVNode","{  vNodeInstantiate(node, undefined);  parent.insertBefore(node.ref!, nextRef!);  vNodeRender(node, undefined); }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","gen","{  if (typeof item === 'number') {  return keys ? createVText(item.toString()).key(item.toString()) : createVText(item.toString());  } else if (Array.isArray(item)) {  let result: VNode[] = [];  for (let i = 0; i < item.length; i++) {  result.push(gen(item[i], keys) as VNode);  }  return result;  } else {  let e = createVElement('div').key(item.key);  if (keys) {  e.trackByKeyChildren(gen(item.children, keys) as VNode[]);  } else {  e.children(gen(item.children, keys) as VNode[]);  }  return e;  } }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","checkInnerHtmlEquals","{  const a = createVElement('div');  const b = createVElement('div');  const c = createVElement('div');   if (keys) {  a.trackByKeyChildren(ax);  b.trackByKeyChildren(bx);  c.trackByKeyChildren(cx);  } else {  a.children(ax).disableChildrenShapeError();  b.children(bx).disableChildrenShapeError();  c.children(cx).disableChildrenShapeError();  }   const aDiv = document.createElement('div');  const bDiv = document.createElement('div');  injectVNode(aDiv, a, undefined);  injectVNode(bDiv, b, undefined);   syncVNodes(a, c, undefined);   if (aDiv.innerHTML !== bDiv.innerHTML) {  throw Error(`html doesn't match: ${aDiv.innerHTML} => ${bDiv.innerHTML}`);  } }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","getRandomInt","{  return Math.floor(Math.random() * (max - min)) + min; }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","generateRandomSeq","{  const result = [] as number[];  const length2 = length << 1;  const used = new Set();   for (let i = 0; i < length; i++) {  let id = getRandomInt(0, length2);  while (used.has(id)) {  id = getRandomInt(0, length2);  }  used.add(id);  result.push(id);  }   return result; }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","createTestCase","{  checkInnerHtmlEquals(gen(a, true) as VNode[],  gen(b, true) as VNode[],  gen(b, true) as VNode[],  true); }"
"../test-repos/localvoid_kivi/tests/random/children_reconciliation.ts","runTests","{  for (let i = 0; i < 1000; i++) {  const aLength = getRandomInt(0, 32);  const bLength = getRandomInt(0, 32);  const a = generateRandomSeq(aLength);  const b = generateRandomSeq(bLength);  createTestCase(a, b);  }  document.body.innerText = (++j).toString();  scheduleMacrotask(runTests);  }"
"../test-repos/localvoid_kivi/lib/component.ts","updateComponent","{  if (newProps !== undefined && (component.flags & ComponentFlags.ImmutableProps) === 0) {  const oldProps = component.props;  const newPropsReceived = component.descriptor._newPropsReceived;  if (newPropsReceived !== null) {  newPropsReceived(component, oldProps, newProps);  } else {  component.markDirty();  }  component.props = newProps;  }   if ((component.flags & (ComponentFlags.Dirty | ComponentFlags.Attached)) ===  (ComponentFlags.Dirty | ComponentFlags.Attached)) {  component.descriptor._update!(component, component.props, component.state);  component.mtime = clock();  component.flags &= ~(ComponentFlags.Dirty | ComponentFlags.InUpdateQueue);  } }"
"../test-repos/localvoid_kivi/lib/component.ts","componentAttached","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((component.flags & ComponentFlags.Attached) !== 0) {  throw new Error('Failed to attach Component: component is already attached.');  }  }  component.flags |= ComponentFlags.Attached;  if ('<@KIVI_COMPONENT_RECYCLING@>' as string === 'COMPONENT_RECYCLING_ENABLED') {  component.flags &= ~ComponentFlags.Recycled;  }   const attached = component.descriptor._attached;  if (attached !== null) {  attached(component, component.props, component.state);  } }"
"../test-repos/localvoid_kivi/lib/component.ts","componentDetached","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((component.flags & ComponentFlags.Attached) === 0) {  throw new Error('Failed to detach Component: component is already detached.');  }  }  component.flags &= ~(ComponentFlags.Attached | ComponentFlags.UpdateEachFrame);  componentCancelSubscriptions(component);  componentCancelTransientSubscriptions(component);  const detached = component.descriptor._detached;  if (detached !== null) {  detached(component, component.props, component.state);  } }"
"../test-repos/localvoid_kivi/lib/component.ts","componentCancelSubscriptions","{  let subscription = component._subscriptions;  while (subscription !== null) {  subscription._cancel();  subscription = subscription._componentNext;  }  component._subscriptions = null; }"
"../test-repos/localvoid_kivi/lib/component.ts","componentCancelTransientSubscriptions","{  let subscription = component._transientSubscriptions;  while (subscription !== null) {  subscription._cancel();  subscription = subscription._componentNext;  }  component._transientSubscriptions = null; }"
"../test-repos/localvoid_kivi/lib/component.ts","injectComponent","{  const c = descriptor.createComponent(undefined, props);  if (sync) {  container.appendChild(c.element as Node);  componentAttached(c);  updateComponent(c);  } else {  nextFrame().write(function () {  container.appendChild(c.element as Node);  componentAttached(c);  updateComponent(c);  });  }  return c; }"
"../test-repos/localvoid_kivi/lib/component.ts","mountComponent","{  const c = descriptor.mountComponent(element, undefined, props);  if (sync) {  startMounting();  componentAttached(c);  updateComponent(c);  finishMounting();  } else {  nextFrame().write(function () {  startMounting();  componentAttached(c);  updateComponent(c);  finishMounting();  });  }  return c; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","clock","{  return scheduler.clock; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","requestMicrotaskExecution","{  if ((scheduler.flags & SchedulerFlags.MicrotaskPending) === 0) {  scheduler.flags |= SchedulerFlags.MicrotaskPending;  scheduler.microtaskToggle ^= 1;  scheduler.microtaskNode.nodeValue = scheduler.microtaskToggle ? '1' : '0';  } }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","requestMacrotaskExecution","{  if ((scheduler.flags & SchedulerFlags.MacrotaskPending) === 0) {  scheduler.flags |= SchedulerFlags.MacrotaskPending;  window.postMessage(scheduler.macrotaskMessage, '*');  } }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","requestNextFrame","{  if ((scheduler.flags & SchedulerFlags.FrametaskPending) === 0) {  scheduler.flags |= SchedulerFlags.FrametaskPending;  requestAnimationFrame(handleNextFrame);  } }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","handleWindowMessage","{  if (e.source === window && e.data === scheduler.macrotaskMessage) {  runMacrotasks();  } }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","handleNextFrame","{  const updateComponents = scheduler.updateComponents;  let tasks: SchedulerTask[];  let i: number;  let j: number;   scheduler.flags &= ~SchedulerFlags.FrametaskPending;   scheduler.time = Date.now();   const frame = scheduler.nextFrame;  scheduler.nextFrame = scheduler.currentFrame;  scheduler.currentFrame = frame;   scheduler.currentFrame._rwUnlock();  scheduler.nextFrame._rwUnlock();   // Mark all update components as dirty. But don't update until all write tasks are finished. It is possible that we  // won't need to update component if it is removed.  for (i = 0; i < updateComponents.length; i++) {  updateComponents[i].flags |= ComponentFlags.Dirty;  }   // Perform read/write batching. Start with executing read DOM tasks, then update components, execute write DOM tasks  // and repeat until all read and write tasks are executed.  do {  while ((frame._flags & FrameTasksGroupFlags.Read) !== 0) {  frame._flags &= ~FrameTasksGroupFlags.Read;  tasks = frame._readTasks!;  frame._readTasks = null;   for (i = 0; i < tasks.length; i++) {  tasks[i]();  }  }   while ((frame._flags & (FrameTasksGroupFlags.Component | FrameTasksGroupFlags.Write)) !== 0) {  if ((frame._flags & FrameTasksGroupFlags.Component) !== 0) {  frame._flags &= ~FrameTasksGroupFlags.Component;  const componentGroups = frame._componentTasks;   for (i = 0; i < componentGroups.length; i++) {  const componentGroup = componentGroups[i];  if (componentGroup !== null) {  componentGroups[i] = null;  for (j = 0; j < componentGroup.length; j++) {  updateComponent(componentGroup[j]);  }  }  }  }   if ((frame._flags & FrameTasksGroupFlags.Write) !== 0) {  frame._flags &= ~FrameTasksGroupFlags.Write;  tasks = frame._writeTasks!;  frame._writeTasks = null;  for (i = 0; i < tasks.length; i++) {  tasks[i]();  }  }  }   // Update components registered for updating on each frame.  // Remove components that doesn't have UPDATE_EACH_FRAME flag.  i = 0;  j = updateComponents.length;   while (i < j) {  const component = updateComponents[i++];  if ((component.flags & ComponentFlags.UpdateEachFrame) === 0) {  component.flags &= ~ComponentFlags.InUpdateEachFrameQueue;  if (i === j) {  updateComponents.pop();  } else {  updateComponents[--i] = updateComponents.pop() !;  }  } else {  updateComponent(component);  }  }  } while ((frame._flags & (FrameTasksGroupFlags.Component |  FrameTasksGroupFlags.Write |  FrameTasksGroupFlags.Read)) !== 0);   // Lock current from adding read and write tasks in debug mode.  scheduler.currentFrame._rwLock();   // Perform tasks that should be executed when all DOM ops are finished.  while ((frame._flags & FrameTasksGroupFlags.After) !== 0) {  frame._flags &= ~FrameTasksGroupFlags.After;   tasks = frame._afterTasks!;  frame._afterTasks = null;  for (i = 0; i < tasks.length; i++) {  tasks[i]();  }  }   // Set focus on an element.  if (frame._focus !== null) {  if (frame._focus.constructor === VNode) {  ((frame._focus as VNode).ref as HTMLElement).focus();  } else {  (frame._focus as HTMLElement).focus();  }  frame._focus = null;  }   if (updateComponents.length > 0) {  requestNextFrame();  }   scheduler.clock++; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","runMicrotasks","{  scheduler.time = Date.now();   while (scheduler.microtasks.length > 0) {  const tasks = scheduler.microtasks;  scheduler.microtasks = [];  for (let i = 0; i < tasks.length; i++) {  tasks[i]();  }  scheduler.clock++;  }   scheduler.flags &= ~SchedulerFlags.MicrotaskPending; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","runMacrotasks","{  scheduler.flags &= ~SchedulerFlags.MacrotaskPending;  scheduler.time = Date.now();   let tasks = scheduler.macrotasks;  scheduler.macrotasks = [];  for (let i = 0; i < tasks.length; i++) {  tasks[i]();  }   scheduler.clock++; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","scheduleMicrotask","{  requestMicrotaskExecution();  scheduler.microtasks.push(task); }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","scheduleMacrotask","{  requestMacrotaskExecution();  scheduler.macrotasks.push(task); }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","currentFrame","{  return scheduler.currentFrame; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","nextFrame","{  requestNextFrame();  return scheduler.nextFrame; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","startUpdateComponentEachFrame","{  requestNextFrame();  scheduler.updateComponents.push(component); }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","isMounting","{  return ((scheduler.flags & SchedulerFlags.EnabledMounting) !== 0); }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","startMounting","{  scheduler.flags |= SchedulerFlags.EnabledMounting; }"
"../test-repos/localvoid_kivi/lib/scheduler.ts","finishMounting","{  scheduler.flags &= ~SchedulerFlags.EnabledMounting; }"
"../test-repos/localvoid_kivi/lib/debug.ts","printError","{  console.error(message);  try {  throw new Error(message);  } catch (_) {  /* tslint:disable:no-empty */  /* tslint:enable:no-empty */  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeAttach","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((vnode._debugFlags & VNodeDebugFlags.Attached) !== 0) {  throw new Error('Failed to attach VNode: VNode is already attached.');  }  vnode._debugFlags |= VNodeDebugFlags.Attached;  vnode._debugFlags &= ~VNodeDebugFlags.Detached;  }  if ((vnode._flags & VNodeFlags.Component) === 0) {  const children = vnode._children;  if (children !== null && typeof children !== 'string') {  for (let i = 0; i < (children as VNode[]).length; i++) {  vNodeAttach((children as VNode[])[i]);  }  }  } else {  (vnode.cref as Component<any, any>).attach();  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeAttached","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((vnode._debugFlags & VNodeDebugFlags.Attached) !== 0) {  throw new Error('Failed to attach VNode: VNode is already attached.');  }  vnode._debugFlags |= VNodeDebugFlags.Attached;  vnode._debugFlags &= ~VNodeDebugFlags.Detached;  }  if ((vnode._flags & VNodeFlags.Component) !== 0) {  (vnode.cref as Component<any, any>).attach();  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeDetach","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((vnode._debugFlags & VNodeDebugFlags.Detached) !== 0) {  throw new Error('Failed to detach VNode: VNode is already detached.');  }  vnode._debugFlags |= VNodeDebugFlags.Detached;  vnode._debugFlags &= ~VNodeDebugFlags.Attached;  }  if ((vnode._flags & VNodeFlags.Component) === 0) {  const children = vnode._children;  if (children !== null && typeof children !== 'string') {  for (let i = 0; i < (children as VNode[]).length; i++) {  vNodeDetach((children as VNode[])[i]);  }  }  } else {  (vnode.cref as Component<any, any>).detach();  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeDispose","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((vnode._debugFlags & VNodeDebugFlags.Disposed) !== 0) {  throw new Error('Failed to dispose VNode: VNode is already disposed.');  }  if ((vnode._debugFlags & (VNodeDebugFlags.Rendered | VNodeDebugFlags.Mounted)) === 0) {  throw new Error('Failed to dispose VNode: VNode should be rendered or mounted before disposing.');  }  vnode._debugFlags |= VNodeDebugFlags.Disposed;  }  if ((vnode._flags & VNodeFlags.KeepAlive) === 0) {  if ((vnode._flags & VNodeFlags.Component) !== 0) {  (vnode.cref as Component<any, any>).dispose();  } else if (vnode._children !== null) {  const children = vnode._children;  if (typeof children !== 'string') {  for (let i = 0; i < (children as VNode[]).length; i++) {  vNodeDispose((children as VNode[])[i]);  }  }  }  } else {  vNodeDetach(vnode);  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeInstantiate","{  const flags = vnode._flags;   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (vnode.ref !== null) {  throw new Error('Failed to create VNode: VNode already has a reference to the DOM node.');  }  }   if ((flags & VNodeFlags.Text) !== 0) {  vnode.ref = document.createTextNode(vnode._props);  } else if ((flags & VNodeFlags.Element) !== 0) {  if ((flags & VNodeFlags.ElementDescriptor) === 0) {  if ((flags & VNodeFlags.Svg) === 0) {  vnode.ref = document.createElement(vnode._tag as string) as Node;  } else {  vnode.ref = document.createElementNS(SvgNamespace, vnode._tag as string) as Node;  }  } else {  vnode.ref = (vnode._tag as ElementDescriptor<any>).createElement() as Node;  }  } else if ((flags & VNodeFlags.KeepAlive) === 0) {  const c = (vnode._tag as ComponentDescriptor<any, any>).createComponent(owner, vnode._props);  vnode.ref = c.element as Node;  vnode.cref = c;  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeRender","{  let i: number;   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (vnode.ref === null) {  throw new Error('Failed to render VNode: VNode should be created before render.');  }  if ((vnode._flags & VNodeFlags.Root) !== 0 && owner === undefined) {  throw new Error('Failed to render VNode: VNode component root should have an owner.');  }  if ((vnode._debugFlags & VNodeDebugFlags.Rendered) !== 0) {  throw new Error('Failed to render VNode: VNode cannot be rendered twice.');  }  if ((vnode._debugFlags & VNodeDebugFlags.Mounted) !== 0) {  throw new Error('Failed to render VNode: VNode cannot be rendered after mount.');  }  vnode._debugFlags |= VNodeDebugFlags.Mounted;  }   let il: number;  let key: any;  let keys: any[];  const flags = vnode._flags;   let ref: Element;   if ((flags & (VNodeFlags.Element | VNodeFlags.Root)) !== 0) {  ref = vnode.ref as Element;  if ((flags & VNodeFlags.ElementDescriptorUpdateHandler) === 0) {  const props = vnode._props;  if (props !== null) {  keys = Object.keys(props);  for (i = 0, il = keys.length; i < il; i++) {  key = keys[i];  (ref as any)[key] = props[key];  }  }   if (vnode._attrs !== null) {  keys = Object.keys(vnode._attrs);  for (i = 0, il = keys.length; i < il; i++) {  key = keys[i];  setAttr(ref, key, (vnode._attrs as any)[key]);  }  }   if (vnode._style !== null) {  if ((flags & VNodeFlags.Svg) === 0) {  (ref as HTMLElement).style.cssText = vnode._style;  } else {  ref.setAttribute('style', vnode._style);  }  }   if (vnode._className !== null) {  if ((flags & VNodeFlags.Svg) === 0) {  (ref as HTMLElement).className = vnode._className;  } else {  ref.setAttribute('class', vnode._className);  }  }  } else {  if ((flags & VNodeFlags.Root) === 0) {  (vnode._tag as ElementDescriptor<any>)._update!(ref, undefined, vnode._props);  } else {  (owner!.descriptor._tag as ElementDescriptor<any>)._update!(ref, undefined, vnode._props);  }  }   const children = vnode._children;  if (children !== null) {  if ((flags & VNodeFlags.UnsafeHTML) === 0) {  if ((flags & VNodeFlags.InputElement) === 0) {  if ((flags & VNodeFlags.ArrayChildren) === 0) {  if (typeof children === 'string') {  ref.textContent = children;  } else {  vNodeInsertChild(vnode, children as VNode, null, owner);  }  } else {  for (i = 0, il = (children as VNode[]).length; i < il; i++) {  vNodeInsertChild(vnode, (children as VNode[])[i], null, owner);  }  }  } else {  if ((vnode._flags & VNodeFlags.TextInputElement) !== 0) {  (vnode.ref as HTMLInputElement).value = vnode._children as string;  } else { // ((vnode.flags & VNodeFlags.CheckedInputElement) !== 0)  (vnode.ref as HTMLInputElement).checked = vnode._children as boolean;  }  }  } else {  ref.innerHTML = children as string;  }  }  } else if ((flags & VNodeFlags.Component) !== 0) {  updateComponent(vnode.cref as Component<any, any>);  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeMount","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (vnode.ref !== null) {  throw new Error('Failed to mount VNode: VNode cannot be mounted if it already has a reference to DOM Node.');  }  if ((vnode._flags & VNodeFlags.Root) !== 0 && owner === undefined) {  throw new Error('Failed to render VNode: VNode component root should have an owner.');  }  if ((vnode._debugFlags & VNodeDebugFlags.Rendered) !== 0) {  throw new Error('Failed to mount VNode: VNode cannot be mounted after render.');  }  if ((vnode._debugFlags & VNodeDebugFlags.Mounted) !== 0) {  throw new Error('Failed to mount VNode: VNode cannot be mounted twice.');  }  vnode._debugFlags |= VNodeDebugFlags.Mounted;  }   const flags = vnode._flags;  const children = vnode._children;  let keys: string[];  let key: string;  let i: number;   vnode.ref = node;   if ((flags & VNodeFlags.Component) !== 0) {  const cref = vnode.cref = (vnode._tag as ComponentDescriptor<any, any>)  .mountComponent(node as Element, owner, vnode._props);  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  const dflags = cref.descriptor._flags;  if (node.nodeType !== 1) {  throw new Error('Failed to mount VNode: invalid node type, components can be mounted on element nodes only.');  }  const eTagName = ((node as Element).tagName).toLowerCase();  let cTagName: string;  if ((dflags & ComponentDescriptorFlags.ElementDescriptor) !== 0) {  cTagName = (cref.descriptor._tag as ElementDescriptor<any>)._tagName.toLowerCase();  if (cTagName !== eTagName) {  throw new Error(`Failed to mount VNode: invalid tagName, component expects tagName '${cTagName}', but` +  ` found '${eTagName}'.`);  }  } else if ((dflags & ComponentDescriptorFlags.Canvas2D) !== 0) {  if (eTagName !== 'canvas') {  throw new Error(`Failed to mount VNode: invalid tagName, component expects tagName 'canvas', but` +  ` found '${eTagName}'.`);  }  } else {  cTagName = (cref.descriptor._tag as string).toLowerCase();  if (cTagName !== eTagName) {  throw new Error(`Failed to mount VNode: invalid tagName, component expects tagName '${cTagName}', but` +  ` found '${eTagName}'.`);  }  }  }  updateComponent(cref);  } else {  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((vnode._flags & (VNodeFlags.Element | VNodeFlags.Root)) !== 0) {  if (node.nodeType !== 1) {  throw new Error('Failed to mount VNode: invalid node type, VNode expects Element node.');  }   if (vnode._className !== null) {  const eClassName = (node as Element).getAttribute('class');  if (vnode._className !== eClassName) {  throw new Error(`Failed to mount VNode: invalid className, VNode expects className` +  ` '${vnode._className}', but found '${eClassName}'.`);  }  }  if (vnode._style !== null) {  const eStyle = (node as Element).getAttribute('style');  if (vnode._style !== eStyle) {  throw new Error(`Failed to mount VNode: invalid style, VNode expects style` +  ` '${vnode._style}', but found '${eStyle}'.`);  }  }  } else {  if (node.nodeType !== 3) {  throw new Error('Failed to mount VNode: invalid node type, VNode expects Text node.');  }  const text = node.nodeValue;  if (vnode._props !== text) {  throw new Error(`Failed to mount VNode: invalid text, VNode expects text '${vnode._props}', but found` +  ` '${text}'.`);  }  }  }   if ((flags & (VNodeFlags.Element | VNodeFlags.Root)) !== 0) {  // Assign properties on mount, because they don't exist in html markup.  if ((flags & VNodeFlags.ElementDescriptor) !== 0) {  const eDescriptor = vnode._tag as ElementDescriptor<any>;  if (eDescriptor._props !== null) {  keys = Object.keys(eDescriptor._props);  for (i = 0; i < keys.length; i++) {  key = keys[i];  (node as any)[key] = eDescriptor._props[key];  }  }  }   if (vnode._props !== null) {  keys = Object.keys(vnode._props);  for (i = 0; i < keys.length; i++) {  key = keys[i];  (node as any)[key] = vnode._props[key];  }  }   if (children !== null) {  if ((flags & VNodeFlags.ArrayChildren) === 0) {  if (typeof children !== 'string') {  let child = node.firstChild;   // Adjacent text nodes should be separated by Comment node '<!---->', so we can properly mount them.  let commentNode: Node;  while (child.nodeType === 8) {  commentNode = child;  child = child.nextSibling;  node.removeChild(commentNode);  }   vNodeMount(children as VNode, child, owner);  }  } else if ((children as VNode[]).length > 0) {  let child = node.firstChild;   // Adjacent text nodes should be separated by Comment node '<!---->', so we can properly mount them.  let commentNode: Node;  while (child.nodeType === 8) {  commentNode = child;  child = child.nextSibling;  node.removeChild(commentNode);  }  for (i = 0; i < (children as VNode[]).length; i++) {  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (!child) {  throw new Error('Failed to mount VNode: cannot find matching node.');  }  }  vNodeMount((children as VNode[])[i], child, owner);  child = child.nextSibling;  while (child !== null && child.nodeType === 8) {  commentNode = child;  child = child.nextSibling;  node.removeChild(commentNode);  }  }  }  }  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeInsertChild","{  const container = parent.ref as Element;  if (node.ref === null) {  vNodeInstantiate(node, owner);  vNodeAttached(node);  vNodeRender(node, owner);  container.insertBefore(node.ref!, nextRef!);  } else {  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((node._flags & VNodeFlags.KeepAlive) === 0) {  throw new Error('Failed to replace node: VNode instance already has been used to create DOM node.');  }  }  container.insertBefore(node.ref, nextRef!);  vNodeAttach(node);  updateComponent(node.cref as Component<any, any>,  (node._flags & VNodeFlags.BindOnce) === 0 ? node._props : null);  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeReplaceChild","{  const container = parent.ref as Element;  if (newNode.ref === null) {  vNodeInstantiate(newNode, owner);  vNodeAttached(newNode);  vNodeRender(newNode, owner);  container.replaceChild(newNode.ref!, refNode.ref!);  } else {  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((newNode._flags & VNodeFlags.KeepAlive) === 0) {  throw new Error('Failed to replace node: VNode instance already has been used to create DOM node.');  }  }  container.replaceChild(newNode.ref, refNode.ref!);  vNodeAttach(newNode);  updateComponent(newNode.cref as Component<any, any>,  (newNode._flags & VNodeFlags.BindOnce) === 0 ? newNode._props : null);  }  vNodeDispose(refNode); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeMoveChild","{  (parent.ref as Element).insertBefore(node.ref!, nextRef!); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeRemoveChild","{  (parent.ref as Element).removeChild(node.ref!);  vNodeDispose(node); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","vNodeRemoveAllChildren","{  parent.ref!.textContent = '';  for (let i = 0; i < nodes.length; i++) {  vNodeDispose(nodes[i]);  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","syncVNodes","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((a._debugFlags & (VNodeDebugFlags.Rendered | VNodeDebugFlags.Mounted)) === 0) {  throw new Error('Failed to sync VNode: VNode should be rendered or mounted before sync.');  }  b._debugFlags |= a._debugFlags &  (VNodeDebugFlags.Rendered | VNodeDebugFlags.Mounted |  VNodeDebugFlags.Attached | VNodeDebugFlags.Detached);  }   const ref = a.ref as Element;  const flags = a._flags;   let component: Component<any, any>;  let className: string;   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (a._flags !== b._flags) {  throw new Error(`Failed to sync VNode: flags does not match (old: ${a._flags}, new: ${b._flags}).`);  }  if (a._tag !== b._tag) {  throw new Error(`Failed to sync VNode: tags does not match (old: ${a._tag}, new: ${b._tag}).`);  }  if (a._key !== b._key) {  throw new Error(`Failed to sync VNode: keys does not match (old: ${a._key}, new: ${b._key}).`);  }  if (b.ref !== null && a.ref !== b.ref) {  throw new Error('Failed to sync VNode: reusing VNodes isn't allowed unless it has the same ref.');  }  }   b.ref = a.ref;   if ((flags & VNodeFlags.Text) !== 0) {  if (a._props !== b._props) {  a.ref!.nodeValue = b._props as string;  }  } else if ((flags & (VNodeFlags.Element | VNodeFlags.Root)) !== 0) {  if ((flags & VNodeFlags.ElementDescriptorUpdateHandler) === 0) {  if (a._props !== b._props) {  syncStaticShapeProps(ref, a._props, b._props);  }  if (a._attrs !== b._attrs) {  if ((a._flags & VNodeFlags.DynamicShapeAttrs) === 0) {  syncStaticShapeAttrs(ref, a._attrs, b._attrs);  } else {  syncDynamicShapeAttrs(ref, a._attrs, b._attrs);  }  }  if (a._style !== b._style) {  const style = (b._style === null) ? '' : b._style;  if ((flags & VNodeFlags.Svg) === 0) {  (ref as HTMLElement).style.cssText = style;  } else {  ref.setAttribute('style', style);  }  }   if (a._className !== b._className) {  className = (b._className === null) ? '' : b._className;  if ((flags & VNodeFlags.Svg) === 0) {  (ref as HTMLElement).className = className;  } else {  ref.setAttribute('class', className);  }  }   } else if (a._props !== b._props) {  if ((flags & VNodeFlags.Root) === 0) {  (a._tag as ElementDescriptor<any>)._update!(ref, a._props, b._props);  } else {  (owner!.descriptor._tag as ElementDescriptor<any>)._update!(ref, a._props, b._props);  }  }   if ((a._flags & VNodeFlags.InputElement) === 0) {  if (a._children !== b._children) {  if ((a._flags & VNodeFlags.UnsafeHTML) === 0) {  _syncChildren(  a,  a._children as VNode[] | string,  b._children as VNode[] | string,  owner);  } else {  ref.innerHTML = b._children as string;  }  }  } else {  if ((flags & VNodeFlags.TextInputElement) !== 0) {  if ((ref as HTMLInputElement).value !== b._children) {  (ref as HTMLInputElement).value = b._children as string;  }  } else { // ((flags & VNodeFlags.CheckedInputElement) !== 0)  if ((ref as HTMLInputElement).checked !== b._children) {  (ref as HTMLInputElement).checked = b._children as boolean;  }  }  }  } else { // if ((flags & VNodeFlags.Component) !== 0)  component = b.cref = a.cref as Component<any, any>;   if (((flags & VNodeFlags.ImmutableProps) === 0) || a._props !== b._props) {  updateComponent(component, (flags & VNodeFlags.BindOnce) === 0 ? b._props : undefined);  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","_canSyncVNodes","{  return (a._flags === b._flags &&  a._tag === b._tag); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","_syncChildren","{  let i = 0;   if ((parent._flags & VNodeFlags.ArrayChildren) === 0) {  if (a === null) {  if (typeof b === 'string') {  parent.ref!.textContent = b as string;  } else {  vNodeInsertChild(parent, b as VNode, null, owner);  }  } else if (b === null) {  if (typeof a === 'string') {  parent.ref!.textContent = '';  } else {  vNodeRemoveChild(parent, a as VNode);  }  } else {  if (typeof a === 'string') {  if (typeof b === 'string') {  const c = parent.ref!.firstChild;  if (c) {  c.nodeValue = b as string;  } else {  parent.ref!.textContent = b as string;  }  } else {  parent.ref!.textContent = '';  vNodeInsertChild(parent, b as VNode, null, owner);  }  } else {  if (typeof b === 'string') {  parent.ref!.textContent = b;  vNodeDispose(a as VNode);  } else {  a = a as VNode;  b = b as VNode;  if (_canSyncVNodes(a, b) && a._key === b._key) {  syncVNodes(a, b, owner);  } else {  vNodeReplaceChild(parent, b, a, owner);  }  }  }  }  } else {  a = a as VNode[];  b = b as VNode[];   if (a !== null && a.length !== 0) {  if (b === null || b.length === 0) {  // b is empty, remove all children from a.  vNodeRemoveAllChildren(parent, a as VNode[]);  } else {  if (a.length === 1 && b.length === 1) {  // Fast path when a and b have only one child.  const aNode = a[0] as VNode;  const bNode = b[0] as VNode;   if (_canSyncVNodes(aNode, bNode) && aNode._key === bNode._key) {  syncVNodes(aNode, bNode, owner);  } else {  vNodeReplaceChild(parent, bNode, aNode, owner);  }  } else {  // a and b have more than 1 child.  if ((parent._flags & VNodeFlags.TrackByKeyChildren) === 0) {  _syncChildrenNaive(parent, a as VNode[], b as VNode[], owner);  } else {  _syncChildrenTrackByKeys(parent, a as VNode[], b as VNode[], owner);  }  }  }  } else if (b !== null) {  // a is empty, insert all children from b.  for (i = 0; i < b.length; i++) {  vNodeInsertChild(parent, b[i] as VNode, null, owner);  }  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","_syncChildrenNaive","{  let aStart = 0;  let bStart = 0;  let aEnd = a.length - 1;  let bEnd = b.length - 1;  let aNode: VNode;  let bNode: VNode;  let nextPos: number;  let next: Node | null;   // Sync similar nodes at the beginning.  while (aStart <= aEnd && bStart <= bEnd) {  aNode = a[aStart];  bNode = b[bStart];   if (!_canSyncVNodes(aNode, bNode) || aNode._key !== bNode._key) {  break;  }   aStart++;  bStart++;   syncVNodes(aNode, bNode, owner);  }   // Sync similar nodes at the end.  while (aStart <= aEnd && bStart <= bEnd) {  aNode = a[aEnd];  bNode = b[bEnd];   if (!_canSyncVNodes(aNode, bNode) || aNode._key !== bNode._key) {  break;  }   aEnd--;  bEnd--;   syncVNodes(aNode, bNode, owner);  }   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if ((aStart <= aEnd || bStart <= bEnd) &&  ((parent._debugFlags & VNodeDebugFlags.DisabledChildrenShapeError) === 0)) {  printError(  'VNode sync children: children shape is changing, you should enable tracking by key with ' +  'VNode method trackByKeyChildren(children).\n' +  'If you certain that children shape changes won't cause any problems with losing ' +  'state, you can remove this error message with VNode method disableChildrenShapeError().');  }  }   // Iterate over the remaining nodes and if they have the same type, then sync, otherwise just  // remove the old node and insert the new one.  while (aStart <= aEnd && bStart <= bEnd) {  aNode = a[aStart++];  bNode = b[bStart++];  if (_canSyncVNodes(aNode, bNode) && aNode._key === bNode._key) {  syncVNodes(aNode, bNode, owner);  } else {  vNodeReplaceChild(parent, bNode, aNode, owner);  }  }   if (aStart <= aEnd) {  // All nodes from a are synced, remove the rest.  do {  vNodeRemoveChild(parent, a[aStart++]);  } while (aStart <= aEnd);  } else if (bStart <= bEnd) {  // All nodes from b are synced, insert the rest.  nextPos = bEnd + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  do {  vNodeInsertChild(parent, b[bStart++], next, owner);  } while (bStart <= bEnd);  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","_syncChildrenTrackByKeys","{  let aStart = 0;  let bStart = 0;  let aEnd = a.length - 1;  let bEnd = b.length - 1;  let aStartNode = a[aStart];  let bStartNode = b[bStart];  let aEndNode = a[aEnd];  let bEndNode = b[bEnd];  let i: number;  let j: number | undefined;  let nextPos: number;  let next: Node | null;  let aNode: VNode | null;  let bNode: VNode;  let node: VNode;   // Step 1  outer: while (true) {  // Sync nodes with the same key at the beginning.  while (aStartNode._key === bStartNode._key) {  if (_canSyncVNodes(aStartNode, bStartNode)) {  syncVNodes(aStartNode, bStartNode, owner);  } else {  vNodeReplaceChild(parent, bStartNode, aStartNode, owner);  }  aStart++;  bStart++;  if (aStart > aEnd || bStart > bEnd) {  break outer;  }  aStartNode = a[aStart];  bStartNode = b[bStart];  }   // Sync nodes with the same key at the end.  while (aEndNode._key === bEndNode._key) {  if (_canSyncVNodes(aEndNode, bEndNode)) {  syncVNodes(aEndNode, bEndNode, owner);  } else {  vNodeReplaceChild(parent, bEndNode, aEndNode, owner);  }  aEnd--;  bEnd--;  if (aStart > aEnd || bStart > bEnd) {  break outer;  }  aEndNode = a[aEnd];  bEndNode = b[bEnd];  }   // Move and sync nodes from right to left.  if (aEndNode._key === bStartNode._key) {  if (_canSyncVNodes(aEndNode, bStartNode)) {  syncVNodes(aEndNode, bStartNode, owner);  } else {  vNodeReplaceChild(parent, bStartNode, aEndNode, owner);  }  vNodeMoveChild(parent, bStartNode, aStartNode.ref);  aEnd--;  bStart++;  if (aStart > aEnd || bStart > bEnd) {  break;  }  aEndNode = a[aEnd];  bStartNode = b[bStart];  // In a real-world scenarios there is a higher chance that next node after the move will be the same, so we  // immediately jump to the start of this prefix/suffix algo.  continue;  }   // Move and sync nodes from left to right.  if (aStartNode._key === bEndNode._key) {  if (_canSyncVNodes(aStartNode, bEndNode)) {  syncVNodes(aStartNode, bEndNode, owner);  } else {  vNodeReplaceChild(parent, bEndNode, aStartNode, owner);  }  nextPos = bEnd + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  vNodeMoveChild(parent, bEndNode, next);  aStart++;  bEnd--;  if (aStart > aEnd || bStart > bEnd) {  break;  }  aStartNode = a[aStart];  bEndNode = b[bEnd];  continue;  }   break;  }   if (aStart > aEnd) {  // All nodes from a are synced, insert the rest from b.  nextPos = bEnd + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  while (bStart <= bEnd) {  vNodeInsertChild(parent, b[bStart++], next, owner);  }  } else if (bStart > bEnd) {  // All nodes from b are synced, remove the rest from a.  while (aStart <= aEnd) {  vNodeRemoveChild(parent, a[aStart++]);  }  // Step 2  } else {  let aLength = aEnd - aStart + 1;  let bLength = bEnd - bStart + 1;  const aNullable = a as Array<VNode | null>; // will be removed by js optimizing compilers.  // Mark all nodes as inserted.  const sources = new Array<number>(bLength).fill(-1);   let moved = false;  let pos = 0;  let synced = 0;   // When children lists are small, we are using naive O(N) algorithm to find if child is removed.  if ((bLength <= 4) || ((aLength * bLength) <= 16)) {  for (i = aStart; i <= aEnd; i++) {  aNode = a[i];  if (synced < bLength) {  for (j = bStart; j <= bEnd; j++) {  bNode = b[j];  if (aNode._key === bNode._key) {  sources[j - bStart] = i;   if (pos > j) {  moved = true;  } else {  pos = j;  }  if (_canSyncVNodes(aNode, bNode)) {  syncVNodes(aNode, bNode, owner);  } else {  vNodeReplaceChild(parent, bNode, aNode, owner);  }  synced++;  aNullable[i] = null;  break;  }  }  }  }  } else {  const keyIndex = new Map<any, number>();   for (i = bStart; i <= bEnd; i++) {  node = b[i];  keyIndex.set(node._key, i);  }   for (i = aStart; i <= aEnd; i++) {  aNode = a[i];   if (synced < bLength) {  j = keyIndex.get(aNode._key);   if (j !== undefined) {  bNode = b[j];  sources[j - bStart] = i;  if (pos > j) {  moved = true;  } else {  pos = j;  }  if (_canSyncVNodes(aNode, bNode)) {  syncVNodes(aNode, bNode, owner);  } else {  vNodeReplaceChild(parent, bNode, aNode, owner);  }  synced++;  aNullable[i] = null;  }  }  }  }   if (aLength === a.length && synced === 0) {  // Noone is synced, remove all children with one dom op.  vNodeRemoveAllChildren(parent, a);  while (bStart < bLength) {  vNodeInsertChild(parent, b[bStart++], null, owner);  }  } else {  i = aLength - synced;  while (i > 0) {  aNode = aNullable[aStart++];  if (aNode !== null) {  vNodeRemoveChild(parent, aNode);  i--;  }  }   // Step 3  if (moved) {  const seq = _lis(sources);  j = seq.length - 1;  for (i = bLength - 1; i >= 0; i--) {  if (sources[i] === -1) {  pos = i + bStart;  node = b[pos];  nextPos = pos + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  vNodeInsertChild(parent, node, next, owner);  } else {  if (j < 0 || i !== seq[j]) {  pos = i + bStart;  node = b[pos];  nextPos = pos + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  vNodeMoveChild(parent, node, next);  } else {  j--;  }  }  }  } else if (synced !== bLength) {  for (i = bLength - 1; i >= 0; i--) {  if (sources[i] === -1) {  pos = i + bStart;  node = b[pos];  nextPos = pos + 1;  next = nextPos < b.length ? b[nextPos].ref : null;  vNodeInsertChild(parent, node, next, owner);  }  }  }  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","_lis","{  const p = a.slice(0);  const result: number[] = [];  result.push(0);  let u: number;  let v: number;   for (let i = 0, il = a.length; i < il; i++) {  if (a[i] === -1) {  continue;  }   let j = result[result.length - 1];  if (a[j] < a[i]) {  p[i] = j;  result.push(i);  continue;  }   u = 0;  v = result.length - 1;   while (u < v) {  let c = ((u + v) / 2) | 0;  if (a[result[c]] < a[i]) {  u = c + 1;  } else {  v = c;  }  }   if (a[i] < a[result[u]]) {  if (u > 0) {  p[i] = result[u - 1];  }  result[u] = i;  }  }   u = result.length;  v = result[u - 1];   while (u-- > 0) {  result[u] = v;  v = p[v];  }   return result; }"
"../test-repos/localvoid_kivi/lib/vnode.ts","syncStaticShapeAttrs","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (a === null || b === null) {  throw new Error('Failed to update attrs with static shape: attrs object have dynamic shape.');  }  }   let keys = Object.keys(a);  let key: string;  let i: number;   for (i = 0; i < keys.length; i++) {  key = keys[i];  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (!b!.hasOwnProperty(key)) {  throw new Error('Failed to update attrs with static shape: attrs object have dynamic shape.');  }  }  const bValue = b![key];  if (a![key] !== bValue) {  setAttr(node, key, bValue);  }  }   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  keys = Object.keys(b);  for (i = 0; i < keys.length; i++) {  key = keys[i];  if (!a!.hasOwnProperty(key)) {  throw new Error('Failed to update attrs with static shape: attrs object have dynamic shape.');  }  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","syncDynamicShapeAttrs","{  let i: number;  let keys: string[];  let key: string;   if (a !== null) {  if (b === null) {  // b is empty, remove all attributes from a.  keys = Object.keys(a);  for (i = 0; i < keys.length; i++) {  node.removeAttribute(keys[i]);  }  } else {  // Remove and update attributes.  keys = Object.keys(a);  for (i = 0; i < keys.length; i++) {  key = keys[i];  if (b.hasOwnProperty(key)) {  const bValue = b[key];  if (a[key] !== bValue) {  setAttr(node, key, bValue);  }  } else {  node.removeAttribute(key);  }  }   // Insert new attributes.  keys = Object.keys(b);  for (i = 0; i < keys.length; i++) {  key = keys[i];  if (!a.hasOwnProperty(key)) {  setAttr(node, key, b[key]);  }  }  }  } else if (b !== null) {  // a is empty, insert all attributes from b.  keys = Object.keys(b);  for (i = 0; i < keys.length; i++) {  key = keys[i];  setAttr(node, key, b[key]);  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","syncStaticShapeProps","{  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (a === null || b === null) {  throw new Error('Failed to update props with static shape: props object have dynamic shape.');  }  }   let keys = Object.keys(a);  let key: string;  let i: number;   for (i = 0; i < keys.length; i++) {  key = keys[i];  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (!b.hasOwnProperty(key)) {  throw new Error('Failed to update props with static shape: props object have dynamic shape.');  }  }  const bValue = b[key];  if (a[key] !== bValue) {  (node as { [key: string]: any })[key] = bValue;  }  }   if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  keys = Object.keys(b);  for (i = 0; i < keys.length; i++) {  key = keys[i];  if (!a.hasOwnProperty(key)) {  throw new Error('Failed to update attrs with static shape: attrs object have dynamic shape.');  }  }  } }"
"../test-repos/localvoid_kivi/lib/vnode.ts","createVText","{  return new VNode(VNodeFlags.Text, null, content); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","createVElement","{  return new VNode(VNodeFlags.Element, tagName, null); }"
"../test-repos/localvoid_kivi/lib/vnode.ts","createVSvgElement","{  return new VNode(VNodeFlags.Element | VNodeFlags.Svg, tagName, null); }"
"../test-repos/localvoid_kivi/lib/utils.ts","normalizeVNodes","{  let copy = nodes.slice(0);  const flatten = [] as VNode[];  while (copy.length > 0) {  const item = copy.shift();  if (item !== null) {  if (item!.constructor === VNode) {  flatten.push(item as any);  } else {  copy = (item as any).concat(copy);  }  }  }  return flatten; }"
"../test-repos/localvoid_kivi/lib/misc.ts","setAttr","{  if (key.charCodeAt(0) !== 120) { // x  node.setAttribute(key, value);  } else {  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (key.length <= 3) {  throw new Error(`Failed to set attr: invalid attribute '${key}', attributes starting with letter 'x' should` +  ` have length 4 or more.`);  }  }   if (key.charCodeAt(1) === 109 && key.charCodeAt(2) === 108) { // ml  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (key.charCodeAt(3) !== 58) { // :  throw new Error(`Failed to set attr: invalid attribute '${key}', attributes with 'xml' prefix should be in` +  ` the form 'xml:attr'.`);  }  }  node.setAttributeNS(XmlNamespace, key, value);  } else if (key.charCodeAt(1) === 108 && key.charCodeAt(2) === 105) { // li  if ('<@KIVI_DEBUG@>' as string !== 'DEBUG_DISABLED') {  if (key.charCodeAt(3) !== 110 || key.charCodeAt(4) !== 107 || key.charCodeAt(5) !== 58) { // nk:  throw new Error(`Failed to set attr: invalid attribute '${key}', attributes with 'xli' prefix should be in` +  ` the form 'xlink:attr'.`);  }  }  node.setAttributeNS(XlinkNamespace, key, value);  } else {  node.setAttribute(key, value);  }  } }"
"../test-repos/localvoid_kivi/lib/misc.ts","matchesWithAncestors","{  while (element !== sentinel) {  if (element.matches(selector)) {  return element;  }  element = element.parentNode as Element;  }   return null; }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","getHeaders","{  switch (platform) {  case 'Android':  return {  'Connection': 'Keep-Alive',  'User-Agent': 'Mozilla/5.0 BiliDroid/5.22.0 (bbcallen@gmail.com)'  }  case 'WebView':  return {  'Accept': 'application/json, text/javascript, */*',  'Accept-Language': 'zh-CN',  'Connection': 'keep-alive',  'Cookie': 'l=v',  'Origin': liveOrigin,  'User-Agent': 'Mozilla/5.0 (Linux; Android 7.1.1; E6883 Build/32.4.A.1.54; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/64.0.3282.119 Mobile Safari/537.36 BiliApp/5220000',  'X-Requested-With': 'tv.danmaku.bili'  }  default:  return {  'Accept': 'application/json, text/javascript, */*',  'Accept-Language': 'zh-CN',  'Connection': 'keep-alive',  'Cookie': 'l=v',  'DNT': '1',  'Origin': liveOrigin,  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36'  }  } }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","testIP","{  const test: Promise<undefined>[] = []  apiIPs.forEach(ip => {  const headers = getHeaders('PC')  const options = {  uri: apiLiveOrigin,  proxy: `http://${ip}/`,  tunnel: false,  method: 'GET',  timeout: 2000,  headers  }  test.push(new Promise<undefined>(resolve => {  request(options, (error, response) => {  if (error === null && response.statusCode === 200) api.IPs.add(ip)  return resolve(undefined)  })  }))  })  await Promise.all(test)  const num = api.IPs.size  Log('可用ip数量为', num)  return num }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","getShortRoomID","{  return shortRoomID.get(roomID) || roomID }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","getLongRoomID","{  return longRoomID.get(roomID) || roomID }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","XHR","{  return new Promise<response<T> | undefined>(resolve => {  options.gzip = true  // 添加用户代理  if (typeof options.uri === 'string' && options.uri.startsWith(apiLiveOrigin)) {  const ip = api.ip  if (ip !== '') {  options.proxy = `http://${ip}/`  options.tunnel = false  }  }  // 添加头信息  const headers = getHeaders(platform)  options.headers = options.headers === undefined ? headers : Object.assign(headers, options.headers)  if (options.method === 'POST')  options.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'  // 返回异步request  request(options, (error, response, body) => {  if (error === null) return resolve({ response, body })  else {  const ip = error.address  if (ip !== undefined && api.IPs.has(ip)) api.IPs.delete(ip)  ErrorLog(options.uri, error)  return resolve(undefined)  }  })  }) }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","Options","{  return new Promise(async resolve => {  // 根据npm start参数不同设置不同路径  const dirname = __dirname + (process.env.npm_package_scripts_start === 'node build/app.js' ? '/../../..' : '/../..')  // 检查是否有options目录  const hasDir = await FSexists(dirname + '/options/')  if (!hasDir) await FSmkdir(dirname + '/options/')  if (options === undefined) {  // 复制默认设置文件到用户设置文件  const hasFile = await FSexists(dirname + '/options/options.json')  if (!hasFile) await FScopyFile(dirname + '/bilive/options.default.json', dirname + '/options/options.json')  // 读取默认设置文件  const defaultOptionBuffer = await FSreadFile(dirname + '/bilive/options.default.json')  const defaultOption = await JSONparse<_options>(defaultOptionBuffer.toString())  // 读取用户设置文件  const userOptionBuffer = await FSreadFile(dirname + '/options/options.json')  const userOption = await JSONparse<_options>(userOptionBuffer.toString())  if (defaultOption === undefined || userOption === undefined) throw new TypeError('文件格式化失败')  defaultOption.server = Object.assign({}, defaultOption.server, userOption.server)  defaultOption.config = Object.assign({}, defaultOption.config, userOption.config)  for (const uid in userOption.user)  defaultOption.user[uid] = Object.assign({}, defaultOption.newUserData, userOption.user[uid])  defaultOption.roomList.forEach(([long, short]) => {  shortRoomID.set(long, short)  longRoomID.set(short, long)  })  return resolve(defaultOption)  }  else {  const blacklist = ['newUserData', 'info', 'apiIPs', 'roomList']  const error = await FSwriteFile(dirname + '/options/options.json'  , JSON.stringify(options, (key, value) => blacklist.includes(key) ? undefined : value, 2))  if (error !== undefined) ErrorLog(error)  resolve(options)  }  }) }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","setCookie","{  const jar = request.jar()  cookieString.split(';').forEach(cookie => {  jar.setCookie(`${cookie}; Domain=bilibili.com; Path=/`, 'https://bilibili.com')  })  return jar }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","getCookie","{  const cookies = jar.getCookies(url)  const cookieFind = cookies.find(cookie => cookie.key === key)  return cookieFind === undefined ? '' : cookieFind.value }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","JSONparse","{  return new Promise<T | undefined>(resolve => {  try {  const obj = JSON.parse(text, reviver)  return resolve(obj)  }  catch (error) {  ErrorLog('JSONparse', error)  return resolve(undefined)  }  }) }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","Hash","{  return crypto.createHash(algorithm).update(data).digest('hex') }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","Log","{  const log = util.format(`${new Date().toString().slice(4, 24)} :`, ...message)  if (logs.data.length > 500) logs.data.shift()  if (typeof logs.onLog === 'function') logs.onLog(log)  logs.data.push(log)  console.log(log) }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","ErrorLog","{  console.error(`${new Date().toString().slice(4, 24)} :`, ...message) }"
"../test-repos/lzghzr_bilive_client/bilive/lib/tools.ts","Sleep","{  return new Promise<'sleep'>(resolve => setTimeout(() => resolve('sleep'), ms)) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","move","{  self.x += dx  self.y += dy  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","setName","{  self.name = newName  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","afterCreate","{  unprotect(self)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","addBox","{  const box = Box.create({ name, x, y, id })  self.boxes.put(box)  return box  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","addArrow","{  self.arrows.push(Arrow.create({ id, from, to }))  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","setSelection","{  self.selection = selection  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","createBox","{  const box = addBox(id, name, x, y)  setSelection(box)  if (source) addArrow(arrowId, source.id, box.id)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/boxes-store.ts","createStore","{  return Store.create({  boxes: {  cc: { id: 'cc', name: 'Rotterdam', x: 100, y: 100 },  aa: { id: 'aa', name: 'Bratislava', x: 650, y: 300 }  },  arrows: [{ id: 'dd', from: 'cc', to: 'aa' }],  selection: 'aa'  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/node.ts","clearDone","{  self.rows.filter(row => row.done === true).forEach(destroy)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/node.ts","setArticle","{  self.article_id = article_id  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/node.ts","setCustomer","{  self.customer_id = customer_id  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/node.ts","addRow","{  self.rows.push(Row.create())  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","delay","{  return new Promise((resolve, reject) => {  setTimeout(() => {  if (shouldThrow) reject(value)  else resolve(value)  }, time)  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","testCoffeeTodo","{  useStrict(true)  const Todo = types  .model({  title: 'get coffee'  })  .actions(self => ({  startFetch: flow(generator(self))  }))  const events: any[] = []  const coffees: string[] = []  const t1 = Todo.create({})  unprotect(t1)  addMiddleware(t1, (c, next) => {  events.push(c)  return next(c)  })  reaction(() => t1.title, coffee => coffees.push(coffee))   function handleResult(res) {  t.is(res, resultValue)  t.deepEqual(coffees, producedCoffees)  const filtered = filterRelevantStuff(events)  t.snapshot(filtered, 'Wrong events, expected\n' + JSON.stringify(filtered, null, 2))  useStrict(false)  t.end()  }   t1.startFetch('black').then(  r => {  t.is(shouldError, false, 'Ended up in OK handler')  handleResult(r)  },  r => {  t.is(shouldError, true, 'Ended up in ERROR handler')  console.error(r)  handleResult(r)  }  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","handleResult","{  t.is(res, resultValue)  t.deepEqual(coffees, producedCoffees)  const filtered = filterRelevantStuff(events)  t.snapshot(filtered, 'Wrong events, expected\n' + JSON.stringify(filtered, null, 2))  useStrict(false)  t.end()  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","a","{  yield delay(10, 'x', false)  self.title = '7'  return 23  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","a","{  yield delay(10, 'x', false)  self.title = '7'  return 23  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","a","{  yield delay(10, 'x', false)  calls++  return 23  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","middleware","{  events.push([call.type, call.name])  return next(call)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/async.ts","filterRelevantStuff","{  return stuff.map(x => {  delete x.context  delete x.tree  return x  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/pointer.ts","Pointer","{  return types.model('PointerOf' + Model.name, {  value: types.maybe(types.reference(Model))  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/reference.ts","addBook","{  self.books.push(book)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/reference.ts","addFolder","{  const folder = Folder.create(data)  getRoot(self).putFolderHelper(folder)  self.children.push(Tree.create({ data: folder, children: [] }))  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/reference.ts","addObject","{  self.objects.put(item)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/reference.ts","addHover","{  self.hovers.push(item)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/reference.ts","removeHover","{  self.hovers.remove(item)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/circular2.ts","LateTodo2","{  return types.model({  done: types.boolean  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/circular2.ts","LateStore2","{  return types.model({  todo: types.late(LateTodo1)  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/protect.ts","setTitle","{  self.title = newTitle  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/protect.ts","createTestStore","{  return Store.create({  todos: [{ title: 'Get coffee' }, { title: 'Get biscuit' }]  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","method","{  const x: string = self.z + self.x + self.y  anotherMethod(x)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","anotherMethod","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setTitle","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","x","{  return Todo.create({ title: 'test' }) as any // as any to make sure the type is not inferred accidentally  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setTitle","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setTitle","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","doA","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","doB","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setTitle","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","getActualAmount","{  return self.todos.size  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setAmount","{  const x: number = self.todos.size + self.amount + self.getAmount()  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setTitle","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","setAmount","{  const x: number = self.todos.size + self.amount + self.getAmount()  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","drive","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","afterCreate","{  connection = Promise.resolve(true)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","log","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/type-system.ts","drive","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/map.ts","addTodo","{  self.todos.put(todo)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/map.ts","addTodo","{  self.todos.put(todo)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/map.ts","something","{  return self.myMap.delete('1020')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","toggle","{  self.done = !self.done  return self.done  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","setCustomer","{  self.customer = customer  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","noopSetCustomer","{  // noop  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","createTestStore","{  const store = OrderStore.create({  customers: [{ id: 1, name: 'Mattia' }],  orders: [  {  customer: null  }  ]  })  onAction(store, () => {})  return store }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","inc","{  self.x += 1  const res = getSnapshot(self as any).x  self.x += 1  return res  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/action.ts","incrementBy","{  self.x += delta  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/primitives.ts","set","{  self.one = one  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/primitives.ts","push","{  self.index.push(model)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/circular1.ts","LateStore1","{  return types.model({  todo: types.late(LateTodo2)  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/circular1.ts","LateTodo1","{  return types.model({  done: types.boolean  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/fixtures/fixture-data.ts","createTreasure","{  const data: any[] = []  let i = 0  do {  data.push({  trapped: i % 2 === 0,  gold: (count % 10 + 1) * 10  })  i++  } while (i < count)  return data }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/fixtures/fixture-data.ts","createHeros","{  const data: any[] = []  let i = 0  let even = true  let n1: string  let n2: string  let n3: string  do {  n1 = titles[i % titles.length]  n2 = givenNames[i % givenNames.length]  n3 = epicNames[i % epicNames.length]  data.push({  id: i,  name: `${n1} ${n2} the ${n3}`,  level: count % 100 + 1,  role: HeroRoles[i % HeroRoles.length],  description: `${wtf} ${wtf} ${wtf}`  })  even = !even  i++  } while (i < count)  return data }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/fixtures/fixture-data.ts","createMonsters","{  const data: any[] = []  let i = 0  let even = true  do {  const treasures = createTreasure(treasureCount)  const eatenHeroes = createHeros(heroCount)  data.push({  id: `omg-${i}-run!`,  freestyle: `${wtf} ${wtf} ${wtf}${wtf} ${wtf} ${wtf}`,  level: count % 100 + 1,  hp: i % 2 === 0 ? 1 : 5 * i,  maxHp: 5 * i,  warning: '!!!!!!',  createdAt: new Date(),  hasFangs: even,  hasClaws: even,  hasWings: !even,  hasGrowl: !even,  fearsFire: even,  fearsWater: !even,  fearsWarriors: even,  fearsClerics: !even,  fearsMages: even,  fearsThieves: !even,  stenchLevel: i % 5,  treasures,  eatenHeroes  })  even = !even  i++  } while (i < count)  return data }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","setTo","{  self.to = to  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","setWidth","{  self.props.set('width', value)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","setHeight","{  self.props.set('height', value)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","fn","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","increment","{  self.count += 1  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","increment","{  self.count += 1  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/object.ts","anotherDoubler","{  self.x *= 2  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/jsonpatch.ts","testPatches","{  const instance = type.create(snapshot)  const baseSnapshot = getSnapshot(instance)  const recorder = recordPatches(instance)  unprotect(instance)  fn(instance)  recorder.stop()  t.deepEqual(recorder.patches, expectedPatches, 'mismatch in patches')  const clone = type.create(snapshot)  recorder.replay(clone)  t.deepEqual(  getSnapshot(clone),  getSnapshot(instance),  'reapplying patches didn't result in same clone'  )  recorder.undo()  t.deepEqual(  getSnapshot(instance),  baseSnapshot,  'reverting the patches didn't result in the same snapshot'  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/env.ts","createEnvironment","{  return {  useUppercase: true  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/perf/report.ts","leftPad","{  return value.toString().length < length ? leftPad(char + value, length) : value }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/perf/scenarios.ts","smallScenario","{  const data = createTreasure(count) // ready?  const time = start()  const converted = data.map(d => Treasure.create(d)) // go  const elapsed = time()  const sanity = converted.length === count   return { count, elapsed, sanity } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/perf/scenarios.ts","mediumScenario","{  const data = createHeros(count) // ready?  const time = start()  const converted = data.map(d => Hero.create(d)) // go  const elapsed = time()  const sanity = converted.length === count   return { count, elapsed, sanity } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/perf/scenarios.ts","largeScenario","{  const data = createMonsters(count, smallChildren, mediumChildren) // ready?  const time = start()  const converted = data.map(d => Monster.create(d)) // go  const elapsed = time()  const sanity = converted.length === count   return { count, elapsed, sanity } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","createTestStore","{  const Todo = types  .model('Todo', {  title: ''  })  .actions(self => {  function afterCreate() {  listener('new todo: ' + self.title)  addDisposer(self, () => {  listener('custom disposer 1 for ' + self.title)  })  addDisposer(self, () => {  listener('custom disposer 2 for ' + self.title)  })  }  function beforeDestroy() {  listener('destroy todo: ' + self.title)  }  function afterAttach() {  listener('attach todo: ' + self.title)  }  function beforeDetach() {  listener('detach todo: ' + self.title)  }  return {  afterCreate,  beforeDestroy,  afterAttach,  beforeDetach  }  })  const Store = types  .model('Store', {  todos: types.array(Todo)  })  .actions(self => {  function afterCreate() {  unprotect(self)  listener('new store: ' + self.todos.length)  addDisposer(self, () => {  listener('custom disposer for store')  })  }  function beforeDestroy() {  listener('destroy store: ' + self.todos.length)  }  return {  afterCreate,  beforeDestroy  }  })  return {  store: Store.create({  todos: [{ title: 'Get coffee' }, { title: 'Get biscuit' }, { title: 'Give talk' }]  }),  Store,  Todo  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterCreate","{  listener('new todo: ' + self.title)  addDisposer(self, () => {  listener('custom disposer 1 for ' + self.title)  })  addDisposer(self, () => {  listener('custom disposer 2 for ' + self.title)  })  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDestroy","{  listener('destroy todo: ' + self.title)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterAttach","{  listener('attach todo: ' + self.title)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDetach","{  listener('detach todo: ' + self.title)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterCreate","{  unprotect(self)  listener('new store: ' + self.todos.length)  addDisposer(self, () => {  listener('custom disposer for store')  })  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDestroy","{  listener('destroy store: ' + self.todos.length)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","postProcessSnapshot","{  return { ...snapshot, id: '' + snapshot.id / 2 }  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","listener","{  events.push(message)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterCreate","{  listener('aftercreate1')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDestroy","{  listener('beforedestroy1')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterAttach","{  listener('afterattach1')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDetach","{  listener('beforedetach1')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterCreate","{  listener('aftercreate2')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDestroy","{  listener('beforedestroy2')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","afterAttach","{  listener('afterattach2')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/test/hooks.ts","beforeDetach","{  listener('beforedetach2')  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","union","{  const dispatcher = isType(dispatchOrType) ? null : dispatchOrType  const types = isType(dispatchOrType) ? otherTypes.concat(dispatchOrType) : otherTypes  const name = '(' + types.map(type => type.name).join(' | ') + ')'   // check all options  if (process.env.NODE_ENV !== 'production') {  types.forEach(type => {  if (!isType(type))  fail(  'expected all possible types to be a mobx-state-tree type, got ' +  type +  ' instead'  )  })  }  return new Union(name, types, dispatcher) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/union.ts","isUnionType","{  return (type.flags & TypeFlags.Union) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/identifier.ts","identifier","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/identifier.ts","identifier","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/identifier.ts","identifier","{  if (process.env.NODE_ENV !== 'production') {  if (!isType(baseType))  fail('expected a mobx-state-tree type as first argument, got ' + baseType + ' instead')  }  return new IdentifierType(baseType) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/identifier.ts","isIdentifierType","{  return isType(type) && (type.flags & TypeFlags.Identifier) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/reference.ts","reference","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/reference.ts","reference","{  // check that a type is given  if (process.env.NODE_ENV !== 'production') {  if (!isType(subType))  fail('expected a mobx-state-tree type as first argument, got ' + subType + ' instead')  if (arguments.length === 2 && typeof arguments[1] === 'string')  fail('References with base path are no longer supported. Please remove the base path.')  }  if (options) return new CustomReferenceType(subType, options)  else return new IdentifierReferenceType(subType) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/reference.ts","isReferenceType","{  return (type.flags & TypeFlags.Reference) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/frozen.ts","isFrozenType","{  return isType(type) && (type.flags & TypeFlags.Frozen) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/maybe.ts","maybe","{  if (process.env.NODE_ENV !== 'production') {  if (!isType(type))  fail('expected a mobx-state-tree type as first argument, got ' + type + ' instead')  if (type === frozen) {  fail(  'Unable to declare `types.maybe(types.frozen)`. Frozen already accepts `null`. Consider using `types.optional(types.frozen, null)` instead.'  )  }  }  return union(optionalNullType, type) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","refinement","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","refinement","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","refinement","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","refinement","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","refinement","{  const name = typeof args[0] === 'string' ? args.shift() : isType(args[0]) ? args[0].name : null  const type = args[0]  const predicate = args[1]  const message = args[2]  ? args[2]  : (v: any) => 'Value does not respect the refinement predicate'  // ensures all parameters are correct  if (process.env.NODE_ENV !== 'production') {  if (typeof name !== 'string')  fail('expected a string as first argument, got ' + name + ' instead')  if (!isType(type))  fail(  'expected a mobx-state-tree type as first or second argument, got ' +  type +  ' instead'  )  if (typeof predicate !== 'function')  fail('expected a function as third argument, got ' + predicate + ' instead')  if (typeof message !== 'function')  fail('expected a function as fourth argument, got ' + message + ' instead')  }  return new Refinement(name, type, predicate, message) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/refinement.ts","isRefinementType","{  return (type.flags & TypeFlags.Refinement) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/enumeration.ts","enumeration","{  const realOptions: string[] = typeof name === 'string' ? options! : name  // check all options  if (process.env.NODE_ENV !== 'production') {  realOptions.forEach(option => {  if (typeof option !== 'string')  fail('expected all options to be string, got ' + type + ' instead')  })  }  const type = union(...realOptions.map(option => literal('' + option)))  if (typeof name === 'string') type.name = name  return type }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/literal.ts","literal","{  // check that the given value is a primitive  if (process.env.NODE_ENV !== 'production') {  if (!isPrimitive(value)) fail(`Literal types can be built only on top of primitives`)  }  return new Literal<S>(value) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/literal.ts","isLiteralType","{  return isType(type) && (type.flags & TypeFlags.Literal) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","optional","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","optional","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","optional","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","optional","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","optional","{  if (process.env.NODE_ENV !== 'production') {  if (!isType(type))  fail('expected a mobx-state-tree type as first argument, got ' + type + ' instead')  const defaultValue =  typeof defaultValueOrFunction === 'function'  ? defaultValueOrFunction()  : defaultValueOrFunction  const defaultSnapshot = isStateTreeNode(defaultValue)  ? getStateTreeNode(defaultValue).snapshot  : defaultValue  typecheck(type, defaultSnapshot)  }  return new OptionalValue(type, defaultValueOrFunction) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/optional.ts","isOptionalType","{  return isType(type) && (type.flags & TypeFlags.Optional) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/late.ts","late","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/late.ts","late","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/late.ts","late","{  const name = typeof nameOrType === 'string' ? nameOrType : `late(${nameOrType.toString()})`  const type = typeof nameOrType === 'string' ? maybeType : nameOrType  // checks that the type is actually a late type  if (process.env.NODE_ENV !== 'production') {  if (!(typeof type === 'function' && type.length === 0))  fail(  'Invalid late type, expected a function with zero arguments that returns a type, got: ' +  type  )  }  return new Late<S, T>(name, type) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/utility-types/late.ts","isLateType","{  return isType(type) && (type.flags & TypeFlags.Late) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/primitives.ts","getPrimitiveFactoryFromValue","{  switch (typeof value) {  case 'string':  return string  case 'number':  return number  case 'boolean':  return boolean  case 'object':  if (value instanceof Date) return DatePrimitive  }  return fail('Cannot determine primitive type from value ' + value) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/primitives.ts","isPrimitiveType","{  return (  isType(type) &&  (type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.Boolean | TypeFlags.Date)) >  0  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","arrayToString","{  return `${getStateTreeNode(this)}(${this.length} items)` }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","array","{  if (process.env.NODE_ENV !== 'production') {  if (!isType(subtype))  fail('expected a mobx-state-tree type as first argument, got ' + subtype + ' instead')  }  return new ArrayType<S, T>(subtype.name + '[]', subtype) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","reconcileArrayChildren","{  let oldNode: INode,  newValue: any,  hasNewNode = false,  oldMatch: INode | undefined = undefined   for (let i = 0; ; i++) {  hasNewNode = i <= newValues.length - 1  oldNode = oldNodes[i]  newValue = hasNewNode ? newValues[i] : undefined   // for some reason, instead of newValue we got a node, fallback to the storedValue  // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681  if (isNode(newValue)) newValue = newValue.storedValue   // both are empty, end  if (!oldNode && !hasNewNode) {  break  // new one does not exists, old one dies  } else if (!hasNewNode) {  oldNode.die()  oldNodes.splice(i, 1)  i--  // there is no old node, create it  } else if (!oldNode) {  // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.  if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {  // this node is owned by this parent, but not in the reconcilable set, so it must be double  fail(  `Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent.path}/${newPaths[  i  ]}', but it lives already at '${getStateTreeNode(newValue).path}'`  )  }  oldNodes.splice(i, 0, valueAsNode(childType, parent, '' + newPaths[i], newValue))  // both are the same, reconcile  } else if (areSame(oldNode, newValue)) {  oldNodes[i] = valueAsNode(childType, parent, '' + newPaths[i], newValue, oldNode)  // nothing to do, try to reorder  } else {  oldMatch = undefined   // find a possible candidate to reuse  for (let j = i; j < oldNodes.length; j++) {  if (areSame(oldNodes[j], newValue)) {  oldMatch = oldNodes.splice(j, 1)[0]  break  }  }   oldNodes.splice(  i,  0,  valueAsNode(childType, parent, '' + newPaths[i], newValue, oldMatch)  )  }  }   return oldNodes }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","valueAsNode","{  // ensure the value is valid-ish  typecheck(childType, newValue)   // the new value has a MST node  if (isStateTreeNode(newValue)) {  const childNode = getStateTreeNode(newValue)  childNode.assertAlive()   // the node lives here  if (childNode.parent !== null && childNode.parent === parent) {  childNode.setParent(parent, subpath)  if (oldNode && oldNode !== childNode) oldNode.die()  return childNode  }  }  // there is old node and new one is a value/snapshot  if (oldNode) {  const childNode = childType.reconcile(oldNode, newValue)  childNode.setParent(parent, subpath)  return childNode  }  // nothing to do, create from scratch  const childNode = childType.instantiate(parent, subpath, parent._environment, newValue)  return childNode }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","areSame","{  // the new value has the same node  if (isStateTreeNode(newValue)) {  return getStateTreeNode(newValue) === oldNode  }  // the provided value is the snapshot of the old node  if (isMutable(newValue) && oldNode.snapshot === newValue) return true  // new value is a snapshot with the correct identifier  if (  oldNode instanceof ObjectNode &&  oldNode.identifier !== null &&  oldNode.identifierAttribute &&  isPlainObject(newValue) &&  newValue[oldNode.identifierAttribute] === oldNode.identifier  )  return true  return false }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/array.ts","isArrayType","{  return isType(type) && (type.flags & TypeFlags.Array) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","objectTypeToString","{  return getStateTreeNode(this).toString() }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","toPropertiesObject","{  // loop through properties and ensures that all items are types  return Object.keys(properties).reduce(  (properties, key) => {  // warn if user intended a HOOK  if (key in HOOK_NAMES)  return fail(  `Hook '${key}' was defined as property. Hooks should be defined as part of the actions`  )   // the user intended to use a view  const descriptor = Object.getOwnPropertyDescriptor(properties, key)!  if ('get' in descriptor) {  fail('Getters are not supported as properties. Please use views instead')  }  // undefined and null are not valid  const { value } = descriptor  if (value === null || undefined) {  fail(  'The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?'  )  // its a primitive, convert to its type  } else if (isPrimitive(value)) {  return Object.assign({}, properties, {  [key]: optional(getPrimitiveFactoryFromValue(value), value)  })  // its already a type  } else if (isType(value)) {  return properties  // its a function, maybe the user wanted a view?  } else if (typeof value === 'function') {  fail('Functions are not supported as properties, use views instead')  // no other complex values  } else if (typeof value === 'object') {  fail(  `In property '${key}': base models should not contain complex values: '${value}'`  )  // WTF did you pass in mate?  } else {  fail(`Unexpected value for property '${key}'`)  }  },  properties as any  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","model","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","model","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","model","{  const name = typeof args[0] === 'string' ? args.shift() : 'AnonymousModel'  const properties = args.shift() || {}  return new ModelType({ name, properties }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","compose","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","compose","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","compose","{  // TODO: just join the base type names if no name is provided  const typeName: string = typeof args[0] === 'string' ? args.shift() : 'AnonymousModel'  // check all parameters  if (process.env.NODE_ENV !== 'production') {  args.forEach(type => {  if (!isType(type)) fail('expected a mobx-state-tree type, got ' + type + ' instead')  })  }  return (args as ModelType<any, any>[])  .reduce((prev, cur) =>  prev.cloneAndEnhance({  name: prev.name + '_' + cur.name,  properties: cur.properties,  initializers: cur.initializers  })  )  .named(typeName) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/model.ts","isObjectType","{  return isType(type) && (type.flags & TypeFlags.Object) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/map.ts","mapToString","{  return `${getStateTreeNode(this as IStateTreeNode)}(${this.size} items)` }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/map.ts","put","{  if (!!!value) fail(`Map.put cannot be used to set empty values`)  let node: ObjectNode  if (isStateTreeNode(value)) {  node = getStateTreeNode(value)  } else if (isMutable(value)) {  const targetType = (getStateTreeNode(this as IStateTreeNode).type as MapType<any, any>)  .subType  node = getStateTreeNode(targetType.create(value))  } else {  return fail(`Map.put can only be used to store complex values`)  }  if (!node.identifierAttribute)  fail(  `Map.put can only be used to store complex values that have an identifier type attribute`  )  this.set(node.identifier!, node.value)  return this }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/map.ts","map","{  return new MapType<S, T>(`map<string, ${subtype.name}>`, subtype) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/types/complex-types/map.ts","isMapType","{  return isType(type) && (type.flags & TypeFlags.Map) > 0 }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","splitPatch","{  if (!('oldValue' in patch)) fail(`Patches without \`oldValue\` field cannot be inversed`)  return [stripPatch(patch), invertPatch(patch)] }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","stripPatch","{  // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec  // this removes the ability to undo the patch  switch (patch.op) {  case 'add':  return { op: 'add', path: patch.path, value: patch.value }  case 'remove':  return { op: 'remove', path: patch.path }  case 'replace':  return { op: 'replace', path: patch.path, value: patch.value }  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","invertPatch","{  switch (patch.op) {  case 'add':  return {  op: 'remove',  path: patch.path  }  case 'remove':  return {  op: 'add',  path: patch.path,  value: patch.oldValue  }  case 'replace':  return {  op: 'replace',  path: patch.path,  value: patch.oldValue  }  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","escapeJsonPath","{  return str.replace(/~/g, '~1').replace(/\//g, '~0') }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","unescapeJsonPath","{  return str.replace(/~0/g, '/').replace(/~1/g, '~') }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","joinJsonPath","{  // `/` refers to property with an empty name, while `` refers to root itself!  if (path.length === 0) return ''  return '/' + path.map(escapeJsonPath).join('/') }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/json-patch.ts","splitJsonPath","{  // `/` refers to property with an empty name, while `` refers to root itself!  const parts = path.split('/').map(unescapeJsonPath)   // path '/a/b/c' -> a b c  // path '../../b/c -> .. .. b c  return parts[0] === '' ? parts.slice(1) : parts }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","process","{  deprecated('process', '`process()` has been renamed to `flow()`. ' + DEPRECATION_MESSAGE)  return flow(asyncAction) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/process.ts","createProcessSpawner","{  deprecated(  'process',  '`createProcessSpawner()` has been renamed to `createFlowSpawner()`. ' + DEPRECATION_MESSAGE  )  return createFlowSpawner(name, generator) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getType","{  return getStateTreeNode(object).type }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getChildType","{  return getStateTreeNode(object).getChildType(child) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","onPatch","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof callback !== 'function')  fail('expected second argument to be a function, got ' + callback + ' instead')  }  return getStateTreeNode(target).onPatch(callback) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","onSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","onSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","onSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","onSnapshot","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof callback !== 'function')  fail('expected second argument to be a function, got ' + callback + ' instead')  }  return getStateTreeNode(target).onSnapshot(callback) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","applyPatch","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof patch !== 'object')  fail('expected second argument to be an object or array, got ' + patch + ' instead')  }  getStateTreeNode(target).applyPatches(asArray(patch)) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","recordPatches","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(subject))  fail(  'expected first argument to be a mobx-state-tree node, got ' + subject + ' instead'  )  }   let disposer: IDisposer | null = null  function resume() {  if (disposer) return  disposer = onPatch(subject, (patch, inversePatch) => {  recorder.rawPatches.push([patch, inversePatch])  })  }   let recorder = {  rawPatches: [] as [IJsonPatch, IJsonPatch][],  get patches() {  return this.rawPatches.map(([a]) => a)  },  get inversePatches() {  return this.rawPatches.map(([_, b]) => b)  },  stop() {  if (disposer) disposer()  disposer = null  },  resume,  replay(target?: IStateTreeNode) {  applyPatch(target || subject, recorder.patches)  },  undo(target?: IStateTreeNode) {  applyPatch(target || subject, recorder.inversePatches.slice().reverse())  }  }  resume()  return recorder }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","resume","{  if (disposer) return  disposer = onPatch(subject, (patch, inversePatch) => {  recorder.rawPatches.push([patch, inversePatch])  })  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","protect","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  const node = getStateTreeNode(target)  if (!node.isRoot) fail('`protect` can only be invoked on root nodes')  node.isProtectionEnabled = true }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","unprotect","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  const node = getStateTreeNode(target)  if (!node.isRoot) fail('`unprotect` can only be invoked on root nodes')  node.isProtectionEnabled = false }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","isProtected","{  return getStateTreeNode(target).isProtected }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","applySnapshot","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).applySnapshot(snapshot) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getSnapshot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getSnapshot","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).snapshot }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","hasParent","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof depth !== 'number')  fail('expected second argument to be a number, got ' + depth + ' instead')  if (depth < 0) fail(`Invalid depth: ${depth}, should be >= 1`)  }  let parent: INode | null = getStateTreeNode(target).parent  while (parent) {  if (--depth === 0) return true  parent = parent.parent  }  return false }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getParent","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getParent","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getParent","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof depth !== 'number')  fail('expected second argument to be a number, got ' + depth + ' instead')  if (depth < 0) fail(`Invalid depth: ${depth}, should be >= 1`)  }  let d = depth  let parent: INode | null = getStateTreeNode(target).parent  while (parent) {  if (--d === 0) return parent.storedValue  parent = parent.parent  }  return fail(`Failed to find the parent of ${getStateTreeNode(target)} at depth ${depth}`) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getRoot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getRoot","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getRoot","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).root.storedValue }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getPath","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).path }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getPathParts","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return splitJsonPath(getStateTreeNode(target).path) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","isRoot","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).isRoot }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","resolvePath","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof path !== 'string')  fail('expected second argument to be a number, got ' + path + ' instead')  }  const node = resolveNodeByPath(getStateTreeNode(target), path)  return node ? node.value : undefined }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","resolveIdentifier","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isType(type))  fail('expected first argument to be a mobx-state-tree type, got ' + type + ' instead')  if (!isStateTreeNode(target))  fail(  'expected second argument to be a mobx-state-tree node, got ' + target + ' instead'  )  if (!(typeof identifier === 'string' || typeof identifier === 'number'))  fail('expected third argument to be a string or number, got ' + identifier + ' instead')  }  const node = getStateTreeNode(target).root.identifierCache!.resolve(type, '' + identifier)  return node ? node.value : undefined }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","tryResolve","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof path !== 'string')  fail('expected second argument to be a string, got ' + path + ' instead')  }  const node = resolveNodeByPath(getStateTreeNode(target), path, false)  if (node === undefined) return undefined  return node ? node.value : undefined }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getRelativePath","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail(  'expected second argument to be a mobx-state-tree node, got ' + target + ' instead'  )   if (!isStateTreeNode(base))  fail('expected first argument to be a mobx-state-tree node, got ' + base + ' instead')  }  return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target)) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","clone","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(source))  fail('expected first argument to be a mobx-state-tree node, got ' + source + ' instead')  }  const node = getStateTreeNode(source)  return node.type.create(  node.snapshot,  keepEnvironment === true  ? node.root._environment  : keepEnvironment === false ? undefined : keepEnvironment  ) as T // it's an object or something else }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","detach","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  getStateTreeNode(target).detach()  return target }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","destroy","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  const node = getStateTreeNode(target)  if (node.isRoot) node.die()  else node.parent!.removeChild(node.subpath) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","isAlive","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  return getStateTreeNode(target).isAlive }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","addDisposer","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof disposer !== 'function')  fail('expected second argument to be a function, got ' + disposer + ' instead')  }  getStateTreeNode(target).addDisposer(disposer) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","getEnv","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  }  const node = getStateTreeNode(target)  const env = node.root._environment  if (!!!env) return EMPTY_OBJECT as T  return env }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/mst-operations.ts","walk","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof processor !== 'function')  fail('expected second argument to be a function, got ' + processor + ' instead')  }  const node = getStateTreeNode(target)  // tslint:disable-next-line:no_unused-variable  node.getChildren().forEach(child => {  if (isStateTreeNode(child.storedValue)) walk(child.storedValue, processor)  })  processor(node.storedValue) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","getNextActionId","{  return nextActionId++ }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","runWithActionContext","{  const node = getStateTreeNode(context.context)  const baseIsRunningAction = node._isRunningAction  const prevContext = currentActionContext  node.assertAlive()  node._isRunningAction = true  currentActionContext = context  try {  return runMiddleWares(node, context, fn)  } finally {  currentActionContext = prevContext  node._isRunningAction = baseIsRunningAction  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","getActionContext","{  if (!currentActionContext) return fail('Not running an action!')  return currentActionContext }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","createActionInvoker","{  return function() {  const id = getNextActionId()  return runWithActionContext(  {  type: 'action',  name,  id,  args: argsToArray(arguments),  context: target,  tree: getRoot(target),  rootId: currentActionContext ? currentActionContext.rootId : id,  parentId: currentActionContext ? currentActionContext.id : 0  },  fn  )  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","addMiddleware","{  const node = getStateTreeNode(target)  if (process.env.NODE_ENV !== 'production') {  if (!node.isProtectionEnabled)  console.warn(  'It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`'  )  }  return node.addMiddleWare(middleware) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","decorate","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","decorate","{  if (fn.$mst_middleware) fn.$mst_middleware.push(middleware)  else fn.$mst_middleware = [middleware]  return fn }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","collectMiddlewareHandlers","{  let handlers: IMiddlewareHandler[] = (fn as any).$mst_middleware || EMPTY_ARRAY  let n: ObjectNode | null = node  // Find all middlewares. Optimization: cache this?  while (n) {  if (n.middlewares) handlers = handlers.concat(n.middlewares)  n = n.parent  }  return handlers }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","runMiddleWares","{  const handlers = collectMiddlewareHandlers(node, baseCall, originalFn)  // Short circuit  if (!handlers.length) return mobxAction(originalFn).apply(null, baseCall.args)  let index = 0   function runNextMiddleware(call: IMiddlewareEvent): any {  const handler = handlers[index++]  if (handler) return handler(call, runNextMiddleware)  else return mobxAction(originalFn).apply(null, baseCall.args)  }  return runNextMiddleware(baseCall) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/action.ts","runNextMiddleware","{  const handler = handlers[index++]  if (handler) return handler(call, runNextMiddleware)  else return mobxAction(originalFn).apply(null, baseCall.args)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","flow","{  return createFlowSpawner(asyncAction.name, asyncAction) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","createFlowSpawner","{  const spawner = function flowSpawner(this: any) {  // Implementation based on https://github.com/tj/co/blob/master/index.js  const runId = getNextActionId()  const baseContext = getActionContext()  const args = arguments   function wrap(fn: any, type: IMiddlewareEventType, arg: any) {  fn.$mst_middleware = (spawner as any).$mst_middleware // pick up any middleware attached to the flow  runWithActionContext(  {  name,  type,  id: runId,  args: [arg],  tree: baseContext.tree,  context: baseContext.context,  parentId: baseContext.id,  rootId: baseContext.rootId  },  fn  )  }   return new Promise(function(resolve, reject) {  let gen: any  const init = function asyncActionInit() {  gen = generator.apply(null, arguments)  onFulfilled(undefined) // kick off the flow  }  ;(init as any).$mst_middleware = (spawner as any).$mst_middleware   runWithActionContext(  {  name,  type: 'flow_spawn',  id: runId,  args: argsToArray(args),  tree: baseContext.tree,  context: baseContext.context,  parentId: baseContext.id,  rootId: baseContext.rootId  },  init  )   function onFulfilled(res: any) {  let ret  try {  // prettier-ignore  wrap((r: any) => { ret = gen.next(r) }, 'flow_resume', res)  } catch (e) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { reject(e) }, 'flow_throw', e)  })  return  }  next(ret)  return  }   function onRejected(err: any) {  let ret  try {  // prettier-ignore  wrap((r: any) => { ret = gen.throw(r) }, 'flow_resume_error', err) // or yieldError?  } catch (e) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { reject(e) }, 'flow_throw', e)  })  return  }  next(ret)  }   function next(ret: any) {  if (ret.done) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { resolve(r) }, 'flow_return', ret.value)  })  return  }  // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100  if (!ret.value || typeof ret.value.then !== 'function')  fail('Only promises can be yielded to `async`, got: ' + ret)  return ret.value.then(onFulfilled, onRejected)  }  })  }  return spawner }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","wrap","{  fn.$mst_middleware = (spawner as any).$mst_middleware // pick up any middleware attached to the flow  runWithActionContext(  {  name,  type,  id: runId,  args: [arg],  tree: baseContext.tree,  context: baseContext.context,  parentId: baseContext.id,  rootId: baseContext.rootId  },  fn  )  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","onFulfilled","{  let ret  try {  // prettier-ignore  wrap((r: any) => { ret = gen.next(r) }, 'flow_resume', res)  } catch (e) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { reject(e) }, 'flow_throw', e)  })  return  }  next(ret)  return  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","onRejected","{  let ret  try {  // prettier-ignore  wrap((r: any) => { ret = gen.throw(r) }, 'flow_resume_error', err) // or yieldError?  } catch (e) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { reject(e) }, 'flow_throw', e)  })  return  }  next(ret)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/flow.ts","next","{  if (ret.done) {  // prettier-ignore  setImmediate(() => {  wrap((r: any) => { resolve(r) }, 'flow_return', ret.value)  })  return  }  // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100  if (!ret.value || typeof ret.value.then !== 'function')  fail('Only promises can be yielded to `async`, got: ' + ret)  return ret.value.then(onFulfilled, onRejected)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type.ts","isType","{  return typeof value === 'object' && value && value.isType === true }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","safeStringify","{  try {  return JSON.stringify(value)  } catch (e) {  return `<Unserializable: ${e}>`  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","prettyPrintValue","{  return typeof value === 'function'  ? `<function${value.name ? ' ' + value.name : ''}>`  : isStateTreeNode(value) ? `<${value}>` : `\`${safeStringify(value)}\`` }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","shortenPrintValue","{  return valueInString.length < 280  ? valueInString  : `${valueInString.substring(0, 272)}......${valueInString.substring(  valueInString.length - 8  )}` }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","toErrorString","{  const { value } = error  const type: IType<any, any> = error.context[error.context.length - 1].type as any  const fullPath = error.context  .map(({ path }) => path)  .filter(path => path.length > 0)  .join('/')   const pathPrefix = fullPath.length > 0 ? `at path '/${fullPath}' ` : ``   const currentTypename = isStateTreeNode(value)  ? `value of type ${getStateTreeNode(value).type.name}:`  : isPrimitive(value) ? 'value' : 'snapshot'  const isSnapshotCompatible =  type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot)   return (  `${pathPrefix}${currentTypename} ${prettyPrintValue(value)} is not assignable ${type  ? `to type: \`${type.name}\``  : ``}` +  (error.message ? ` (${error.message})` : '') +  (type  ? isPrimitiveType(type)  ? `.`  : `, expected an instance of \`${type.name}\` or a snapshot like \`${type.describe()}\` instead.` +  (isSnapshotCompatible  ? ' (Note that a snapshot of the provided value is compatible with the targeted type)'  : '')  : `.`)  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","getDefaultContext","{  return [{ type, path: '' }] }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","getContextForPath","{  return context.concat([{ path, type }]) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","typeCheckSuccess","{  return EMPTY_ARRAY as any }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","typeCheckFailure","{  return [{ context, value, message }] }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","flattenTypeErrors","{  return errors.reduce((a, i) => a.concat(i), []) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","typecheck","{  // if not in dev-mode, do not even try to run typecheck. Everything is developer fault!  if (process.env.NODE_ENV === 'production') return  typecheckPublic(type, value) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/type/type-checker.ts","typecheckPublic","{  const errors = type.validate(value, [{ path: '', type }])   if (errors.length > 0) {  console.error('Failed to create `${type.name}` from:', value)  fail(  `Error while converting ${shortenPrintValue(  prettyPrintValue(value)  )} to \`${type.name}\`:\n\n ` + errors.map(toErrorString).join('\n ')  )  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/create-node.ts","createNode","{  if (isStateTreeNode(initialValue)) {  const targetNode = initialValue.$treenode as ObjectNode  if (!targetNode.isRoot)  fail(  `Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent  ? parent.path  : ''}/${subpath}', but it lives already at '${targetNode.path}'`  )  targetNode.setParent(parent, subpath)  return targetNode  }   const storedValue = createNewInstance(initialValue)   if (type.shouldAttachNode) {  const node = new ObjectNode(  type,  parent,  subpath,  environment,  initialValue,  storedValue,  type.shouldAttachNode,  finalizeNewInstance  )  node.finalizeCreation()  return node  }  return new ScalarNode(  type,  parent,  subpath,  environment,  initialValue,  storedValue,  type.shouldAttachNode,  finalizeNewInstance  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/create-node.ts","isNode","{  return value instanceof ScalarNode || value instanceof ObjectNode }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","isStateTreeNode","{  return !!(value && value.$treenode) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","getStateTreeNode","{  if (isStateTreeNode(value)) return value.$treenode!  else return fail(`Value ${value} is no MST Node`) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","canAttachNode","{  return (  value &&  typeof value === 'object' &&  !(value instanceof Date) &&  !isStateTreeNode(value) &&  !Object.isFrozen(value)  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","toJSON","{  return getStateTreeNode(this).snapshot }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","getRelativePathBetweenNodes","{  // PRE condition target is (a child of) base!  if (base.root !== target.root)  fail(  `Cannot calculate relative path: objects '${base}' and '${target}' are not part of the same object tree`  )   const baseParts = splitJsonPath(base.path)  const targetParts = splitJsonPath(target.path)  let common = 0  for (; common < baseParts.length; common++) {  if (baseParts[common] !== targetParts[common]) break  }  // TODO: assert that no targetParts paths are '..', '.' or ''!  return (  baseParts  .slice(common)  .map(doubleDot)  .join('/') + joinJsonPath(targetParts.slice(common))  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPath","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPath","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPath","{  return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPathParts","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPathParts","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/core/node/node-utils.ts","resolveNodeByPathParts","{  // counter part of getRelativePath  // note that `../` is not part of the JSON pointer spec, which is actually a prefix format  // in json pointer: '' = current, '/a', attribute a, '/' is attribute '' etc...  // so we treat leading ../ apart...  let current: INode | null = base  for (let i = 0; i < pathParts.length; i++) {  if (pathParts[i] === '') current = current!.root  else if (pathParts[i] === '..') current = current!.parent  else if (pathParts[i] === '.' || pathParts[i] === '')  // '/bla' or 'a//b' splits to empty strings  continue  else if (current) {  if (current instanceof ObjectNode) current = current.getChildNode(pathParts[i])  else return fail(`Illegal state`)  continue  }   if (!current) {  if (failIfResolveFails)  return fail(  `Could not resolve '${pathParts[i]}' in '${joinJsonPath(  pathParts.slice(0, i - 1)  )}', path of the patch does not resolve`  )  else return undefined  }  }  return current! }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","serializeArgument","{  if (arg instanceof Date) return { $MST_DATE: arg.getTime() }  if (isPrimitive(arg)) return arg  // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an  // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot  if (isStateTreeNode(arg)) return serializeTheUnserializable(`[MSTNode: ${getType(arg).name}]`)  if (typeof arg === 'function') return serializeTheUnserializable(`[function]`)  if (typeof arg === 'object' && !isPlainObject(arg) && !isArray(arg))  return serializeTheUnserializable(  `[object ${(arg && arg.constructor && arg.constructor.name) || 'Complex Object'}]`  )  try {  // Check if serializable, cycle free etc...  // MWE: there must be a better way....  JSON.stringify(arg) // or throws  return arg  } catch (e) {  return serializeTheUnserializable('' + e)  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","deserializeArgument","{  if (value && typeof value === 'object' && '$MST_DATE' in value)  return new Date(value['$MST_DATE'])  return value }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","serializeTheUnserializable","{  return {  $MST_UNSERIALIZABLE: true,  type: baseType  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","applyAction","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (typeof actions !== 'object')  fail('expected second argument to be an object or array, got ' + actions + ' instead')  }  runInAction(() => {  asArray(actions).forEach(action => baseApplyAction(target, action))  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","baseApplyAction","{  const resolvedTarget = tryResolve(target, action.path || '')  if (!resolvedTarget) return fail(`Invalid action path: ${action.path || ''}`)  const node = getStateTreeNode(resolvedTarget)   // Reserved functions  if (action.name === '@APPLY_PATCHES') {  return applyPatch.call(null, resolvedTarget, action.args![0])  }  if (action.name === '@APPLY_SNAPSHOT') {  return applySnapshot.call(null, resolvedTarget, action.args![0])  }   if (!(typeof resolvedTarget[action.name] === 'function'))  fail(`Action '${action.name}' does not exist in '${node.path}'`)  return resolvedTarget[action.name].apply(  resolvedTarget,  action.args ? action.args.map(v => deserializeArgument(node, v)) : []  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","recordActions","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(subject))  fail(  'expected first argument to be a mobx-state-tree node, got ' + subject + ' instead'  )  }  let recorder = {  actions: [] as ISerializedActionCall[],  stop: () => disposer(),  replay: (target: IStateTreeNode) => {  applyAction(target, recorder.actions)  }  }  let disposer = onAction(subject, recorder.actions.push.bind(recorder.actions))  return recorder }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","onAction","{  // check all arguments  if (process.env.NODE_ENV !== 'production') {  if (!isStateTreeNode(target))  fail('expected first argument to be a mobx-state-tree node, got ' + target + ' instead')  if (!isRoot(target))  console.warn(  '[mobx-state-tree] Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.'  )  if (!isProtected(target))  console.warn(  '[mobx-state-tree] Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.'  )  }   function fireListener(rawCall: IMiddlewareEvent) {  if (rawCall.type === 'action' && rawCall.id === rawCall.rootId) {  const sourceNode = getStateTreeNode(rawCall.context)  listener({  name: rawCall.name,  path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode),  args: rawCall.args.map((arg: any, index: number) =>  serializeArgument(sourceNode, rawCall.name, index, arg)  )  })  }  }   return addMiddleware(  target,  attachAfter  ? function onActionMiddleware(rawCall, next) {  const res = next(rawCall)  fireListener(rawCall)  return res  }  : function onActionMiddleware(rawCall, next) {  fireListener(rawCall)  return next(rawCall)  }  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/on-action.ts","fireListener","{  if (rawCall.type === 'action' && rawCall.id === rawCall.rootId) {  const sourceNode = getStateTreeNode(rawCall.context)  listener({  name: rawCall.name,  path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode),  args: rawCall.args.map((arg: any, index: number) =>  serializeArgument(sourceNode, rawCall.name, index, arg)  )  })  }  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/middlewares/create-action-tracking-middleware.ts","createActionTrackingMiddleware","{  return function actionTrackingMiddleware(  call: IMiddlewareEvent,  next: (actionCall: IMiddlewareEvent) => any  ) {  switch (call.type) {  case 'action': {  if (!hooks.filter || hooks.filter(call) === true) {  const context = hooks.onStart(call)  hooks.onResume(call, context)  runningActions.set(call.id, {  call: call,  context: context,  async: false  })  try {  const res = next(call)  hooks.onSuspend(call, context)  if (runningActions.get(call.id)!.async === false) {  runningActions.delete(call.id)  hooks.onSuccess(call, context, res)  }  return res  } catch (e) {  runningActions.delete(call.id)  hooks.onFail(call, context, e)  throw e  }  } else {  return next(call)  }  }  case 'flow_spawn': {  const root = runningActions.get(call.rootId)!  root.async = true  return next(call)  }  case 'flow_resume':  case 'flow_resume_error': {  const root = runningActions.get(call.rootId)!  hooks.onResume(call, root.context)  try {  return next(call)  } finally {  hooks.onSuspend(call, root.context)  }  }  case 'flow_throw': {  const root = runningActions.get(call.rootId)!  runningActions.delete(call.id)  hooks.onFail(call, root.context, call.args[0])  return next(call)  }  case 'flow_return': {  const root = runningActions.get(call.rootId)!  runningActions.delete(call.id)  hooks.onSuccess(call, root.context, call.args[0])  return next(call)  }  }  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","fail","{  throw new Error('[mobx-state-tree] ' + message) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","identity","{  return _ }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","nothing","{  return null }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","noop","{}"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","isArray","{  return !!(Array.isArray(val) || isObservableArray(val)) as boolean }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","asArray","{  if (!val) return (EMPTY_ARRAY as any) as T[]  if (isArray(val)) return val as T[]  return [val] as T[] }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extend","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extend","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extend","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extend","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extend","{  for (let i = 0; i < b.length; i++) {  const current = b[i]  for (let key in current) a[key] = current[key]  }  return a }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extendKeepGetter","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extendKeepGetter","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extendKeepGetter","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extendKeepGetter","no body"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","extendKeepGetter","{  for (let i = 0; i < b.length; i++) {  const current = b[i]  for (let key in current) {  const descriptor = Object.getOwnPropertyDescriptor(current, key)  if ('get' in descriptor) {  Object.defineProperty(a, key, { ...descriptor, configurable: true })  continue  }  a[key] = current[key]  }  }  return a }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","isPlainObject","{  if (value === null || typeof value !== 'object') return false  const proto = Object.getPrototypeOf(value)  return proto === Object.prototype || proto === null }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","isMutable","{  return (  value !== null &&  typeof value === 'object' &&  !(value instanceof Date) &&  !(value instanceof RegExp)  ) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","isPrimitive","{  if (value === null || value === undefined) return true  if (  typeof value === 'string' ||  typeof value === 'number' ||  typeof value === 'boolean' ||  value instanceof Date  )  return true  return false }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","freeze","{  return isPrimitive(value) ? value : Object.freeze(value) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","deepFreeze","{  freeze(value)   if (isPlainObject(value)) {  Object.keys(value).forEach(propKey => {  if (  !isPrimitive((value as any)[propKey]) &&  !Object.isFrozen((value as any)[propKey])  ) {  deepFreeze((value as any)[propKey])  }  })  }   return value }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","isSerializable","{  return typeof value !== 'function' }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","addHiddenFinalProp","{  Object.defineProperty(object, propName, {  enumerable: false,  writable: false,  configurable: true,  value  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","addHiddenWritableProp","{  Object.defineProperty(object, propName, {  enumerable: false,  writable: true,  configurable: true,  value  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","addReadOnlyProp","{  Object.defineProperty(object, propName, {  enumerable: true,  writable: false,  configurable: true,  value  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","remove","{  const idx = collection.indexOf(item)  if (idx !== -1) collection.splice(idx, 1) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","registerEventHandler","{  handlers.push(handler)  return () => {  remove(handlers, handler)  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","hasOwnProperty","{  return prototypeHasOwnProperty.call(object, propName) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mobx-state-tree/src/utils.ts","argsToArray","{  const res = new Array(args.length)  for (let i = 0; i < args.length; i++) res[i] = args[i]  return res }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/test/atomic.ts","delay","{  return new Promise(resolve => {  setTimeout(resolve, time)  }) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/test/UndoManager.ts","delay","{  return new Promise(resolve => {  setTimeout(resolve, time)  })  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/action-logger.ts","actionLogger","{  const skip =  (call.type === 'action' && call.parentId !== 0) ||  call.type === 'flow_resume' ||  call.type === 'flow_resume_error'   if (!skip)  console.log(`[MST] #${call.rootId} ${call.type} - ${getPath(call.context)}/${call.name}`)  return next(call) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/simple-action-logger.ts","simpleActionLogger","{  if (call.type === 'action' && call.parentId === 0)  console.log('[MST] ' + getPath(call.context) + '/' + call.name)  return next(call) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/redux.ts","reduxActionToAction","{  const actionArgs = Object.assign({}, action)  delete actionArgs.type  return {  name: action.type,  args: [actionArgs]  } }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/redux.ts","runMiddleWare","{  function n(retVal: any) {  const f = runners.shift()  if (f) f(n)(retVal)  else next(retVal)  }  n(action) }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/redux.ts","n","{  const f = runners.shift()  if (f) f(n)(retVal)  else next(retVal)  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/redux.ts","handleMonitorActions","{  switch (message.payload.type) {  case 'RESET':  applySnapshot(model, initialState)  return remotedev.init(initialState)  case 'COMMIT':  return remotedev.init(mst.getSnapshot(model))  case 'ROLLBACK':  return remotedev.init(remoteDevDep.extractState(message))  case 'JUMP_TO_STATE':  case 'JUMP_TO_ACTION':  applySnapshot(model, remoteDevDep.extractState(message))  return  case 'IMPORT_STATE':  const nextLiftedState = message.payload.nextLiftedState  const computedStates = nextLiftedState.computedStates  applySnapshot(model, computedStates[computedStates.length - 1].state)  remotedev.send(null, nextLiftedState)  return  default:  }  }"
"../test-repos/mobxjs_mobx-state-tree/packages/mst-middlewares/src/redux.ts","applySnapshot","{  applyingSnapshot = true  mst.applySnapshot(model, state)  applyingSnapshot = false  }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/event-trigger.ts","shouldTriggerEvents","{  return (alwaysCallback || shouldFireScrollEvent) && !isTriggeredCurrentTotal; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-register.ts","createScroller","{  const { scrollContainer, scrollWindow, element, fromRoot } = config;  const resolver = createResolver({  axis: new AxisResolver(!config.horizontal),  windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)  });  const { totalToScroll: startWithTotal } = calculatePoints(element, resolver);  const scrollState: Models.IScrollState = {  lastScrollPosition: 0,  lastTotalToScroll: 0,  totalToScroll: startWithTotal,  triggered: {  down: 0,  up: 0  }  };  const options: Models.IScrollRegisterConfig = {  container: resolver.container,  throttle: config.throttle  };  const distance = {  up: config.upDistance,  down: config.downDistance  };  return attachScrollEvent(options)  .mergeMap((ev: any) => of(calculatePoints(element, resolver)))  .map((positionStats: Models.IPositionStats) =>  toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance))  .do(({ stats, scrollDown }: Models.IScrollParams) =>  ScrollResolver.updateScrollState(  scrollState,  stats.scrolled,  stats.totalToScroll,  ))  .filter(({ fire, scrollDown, stats: { totalToScroll } }: Models.IScrollParams) =>  shouldTriggerEvents(  fire, config.alwaysCallback, ScrollResolver.isTriggeredScroll(totalToScroll, scrollState, scrollDown))  )  .do(({ scrollDown, stats: { totalToScroll } }: Models.IScrollParams) => {  ScrollResolver.updateTriggeredFlag(totalToScroll, scrollState, true, scrollDown);  })  .map(toInfiniteScrollAction); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-register.ts","attachScrollEvent","{  let obs = Observable.fromEvent(options.container, 'scroll');  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.  // Let's avoid calling the function unless needed.  // See https://github.com/orizens/ngx-infinite-scroll/issues/198  if (options.throttle) {  obs = obs.sampleTime(options.throttle);  }  return obs; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-register.ts","toInfiniteScrollParams","{  const { scrollDown, fire } = ScrollResolver.getScrollStats(  lastScrollPosition,  stats,  distance  );  return {  scrollDown,  fire,  stats  }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-register.ts","toInfiniteScrollAction","{  const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;  return {  type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,  payload: {  currentScrollPosition  }  }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","shouldFireScrollEvent","{  let remaining: number;  let containerBreakpoint: number;  const scrolledUntilNow = container.height + container.scrolled;  if (scrollingDown) {  remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;  containerBreakpoint = distance.down / 10;  } else {  remaining = scrolledUntilNow / container.totalToScroll;  containerBreakpoint = distance.up / 10;  }   const shouldFireEvent: boolean = remaining <= containerBreakpoint;  return shouldFireEvent; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","isScrollingDownwards","{  return lastScrollPosition < container.scrolled; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","getScrollStats","{  const scrollDown = isScrollingDownwards(lastScrollPosition, container);  return {  fire: shouldFireScrollEvent(container, distance, scrollDown),  scrollDown  }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","updateScrollPosition","{  return (scrollState.lastScrollPosition = position); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","updateTotalToScroll","{  if (scrollState.lastTotalToScroll !== totalToScroll) {  scrollState.lastTotalToScroll = scrollState.totalToScroll;  scrollState.totalToScroll = totalToScroll;  } }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","isSameTotalToScroll","{  return scrollState.totalToScroll === scrollState.lastTotalToScroll; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","updateTriggeredFlag","{  if (isScrollingDown) {  scrollState.triggered.down = scroll;  } else {  scrollState.triggered.up = scroll;  } }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","isTriggeredScroll","{  return isScrollingDown  ? scrollState.triggered.down === totalToScroll  : scrollState.triggered.up === totalToScroll; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/scroll-resolver.ts","updateScrollState","{  updateScrollPosition(scrolledUntilNow, scrollState);  updateTotalToScroll(totalToScroll, scrollState);  // const isSameTotal = isSameTotalToScroll(scrollState);  // if (!isSameTotal) {  // updateTriggeredFlag(scrollState, false, isScrollingDown);  // } }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","createResolver","{  return createResolverWithContainer(  { axis, isWindow: isElementWindow(windowElement) },  windowElement  ); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","createResolverWithContainer","{  const container =  resolver.isWindow || (windowElement && !windowElement.nativeElement)  ? windowElement  : windowElement.nativeElement;  return { ...resolver, container }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","isElementWindow","{  const isWindow = ['Window', 'global'].some((obj: string) =>  Object.prototype.toString.call(windowElement).includes(obj)  );  return isWindow; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","getDocumentElement","{  return isContainerWindow ? windowElement.document.documentElement : null; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","calculatePoints","{  const height = extractHeightForElement(resolver);  return resolver.isWindow  ? calculatePointsForWindow(height, element, resolver)  : calculatePointsForElement(height, element, resolver); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","calculatePointsForWindow","{  const { axis, container, isWindow } = resolver;  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);  // scrolled until now / current y point  const scrolled =  height +  getElementPageYOffset(  getDocumentElement(isWindow, container),  axis,  isWindow  );  // total height / most bottom y point  const nativeElementHeight = getElementHeight(  element.nativeElement,  isWindow,  offsetHeightKey,  clientHeightKey  );  const totalToScroll =  getElementOffsetTop(element.nativeElement, axis, isWindow) +  nativeElementHeight;  return { height, scrolled, totalToScroll }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","calculatePointsForElement","{  const { axis, container } = resolver;  // perhaps use container.offsetTop instead of 'scrollTop'  const scrolled = container[axis.scrollTopKey()];  const totalToScroll = container[axis.scrollHeightKey()];  return { height, scrolled, totalToScroll }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","extractHeightPropKeys","{  return {  offsetHeightKey: axis.offsetHeightKey(),  clientHeightKey: axis.clientHeightKey()  }; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","extractHeightForElement","{  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);  return getElementHeight(  container,  isWindow,  offsetHeightKey,  clientHeightKey  ); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","getElementHeight","{  if (isNaN(elem[offsetHeightKey])) {  return getDocumentElement(isWindow, elem)[clientHeightKey];  } else {  return elem[offsetHeightKey];  } }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","getElementOffsetTop","{  const topKey = axis.topKey();  // elem = elem.nativeElement;  if (!elem.getBoundingClientRect) {  // || elem.css('none')) {  return;  }  return (  elem.getBoundingClientRect()[topKey] +  getElementPageYOffset(elem, axis, isWindow)  ); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/position-resolver.ts","getElementPageYOffset","{  const pageYOffset = axis.pageYOffsetKey();  const scrollTop = axis.scrollTopKey();  const offsetTop = axis.offsetTopKey();   if (isNaN(window[pageYOffset])) {  return getDocumentElement(isWindow, elem)[scrollTop];  } else if (elem.ownerDocument) {  return elem.ownerDocument.defaultView[pageYOffset];  } else {  return elem[offsetTop];  } }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/ngx-ins-utils.ts","resolveContainerElement","{  const hasWindow = window && !!window.document && window.document.documentElement;  let container = hasWindow && scrollWindow ? window : defaultElement;  if (selector) {  const containerIsString =  selector && hasWindow && typeof selector === 'string';  container = containerIsString  ? findElement(selector, defaultElement.nativeElement, fromRoot)  : selector;  if (!container) {  throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');  }  }  return container; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/ngx-ins-utils.ts","findElement","{  const rootEl = fromRoot ? window.document : customRoot;  return rootEl.querySelector(selector); }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/ngx-ins-utils.ts","inputPropChanged","{  return prop && !prop.firstChange; }"
"../test-repos/orizens_ngx-infinite-scroll/src/services/ngx-ins-utils.ts","hasWindowDefined","{  return typeof window !== 'undefined'; }"
"../test-repos/paulirish_pwmetrics/lib/sheets/gsheets.ts","getRange","{  try {  const sheets = google.sheets('v4');  const response = await promisify(sheets.spreadsheets.values.get)({  auth: auth,  spreadsheetId: spreadsheetId,  range: range  });  return response.values;  } catch(error) {  console.log(getMessage('G_SHEETS_API_ERROR', error));  throw new Error(error);  } }"
"../test-repos/paulirish_pwmetrics/lib/sheets/gsheets.ts","appendResults","{  try {  const sheets = google.sheets('v4');  // clone values to append  const values = Object.assign([], valuesToAppend);  console.log(getMessage('G_SHEETS_APPENDING', formatValues(valuesToAppend)));   const response = await promisify(sheets.spreadsheets.values.append)({  auth: auth,  spreadsheetId: options.spreadsheetId,  range: `${options.tableName}!A1:C1`,  valueInputOption: 'USER_ENTERED',  resource: {  values: values,  },  });  const rangeValues: Array<GSheetsValuesToAppend> = await getRange(auth, response.updates.updatedRange, options.spreadsheetId);  console.log(getMessage('G_SHEETS_APPENDED', formatValues(rangeValues)));  } catch(error) {  console.log(getMessage('G_SHEETS_API_ERROR', error));  throw new Error(error);  } }"
"../test-repos/paulirish_pwmetrics/lib/expectations.ts","validateMetrics","{  const metricsKeys = Object.keys(metrics);   if (!metrics || !metricsKeys.length) {  console.error(getMessageWithPrefix('ERROR', 'NO_METRICS'));  process.exit(1);  }   metricsKeys.forEach(key => {  if (!metrics[key] || !metrics[key].warn || !metrics[key].error) {  console.error(getMessageWithPrefix('ERROR', 'NO_EXPECTATION_ERROR', key));  process.exit(1);  }  }); }"
"../test-repos/paulirish_pwmetrics/lib/expectations.ts","normalizeMetrics","{  let normalizedMetrics: NormalizedExpectationMetrics = {};  Object.keys(metrics).forEach(key => {  normalizedMetrics[key] = {  warn: parseInt(metrics[key].warn.replace('>=', ''), 10),  error: parseInt(metrics[key].error.replace('>=', ''), 10)  };  });  return normalizedMetrics; }"
"../test-repos/paulirish_pwmetrics/lib/expectations.ts","checkExpectations","{  metricsData.forEach(metric => {  const metricName = metric.id;  const expectationValue = expectationMetrics[metricName];  const metricValue = metric.timing;  let msg;   if (!expectationValue) return;   if (metricValue >= expectationValue.error) {  msg = getAssertionMessage('ERROR', metricName, expectationValue.error, metricValue);  } else if (metricValue >= expectationValue.warn && metricValue < expectationValue.error) {  msg = getAssertionMessage('WARNING', metricName, expectationValue.warn, metricValue);  }   if (msg) {  console.log(msg);  }  }); }"
"../test-repos/paulirish_pwmetrics/lib/utils/fs.ts","getConfigFromFile","{  let resolved: string;  try {  resolved = require.resolve(`./${fileName}`);  } catch (e) {  const cwdPath = path.resolve(process.cwd(), fileName);  resolved = require.resolve(cwdPath);  }  const config = require(resolved);  if(config !== null && typeof config === 'object') {  if (resolved.endsWith('package.json'))  return config.pwmetrics || {};  else return config;  } else throw new Error(`Invalid config from ${fileName}`);  }"
"../test-repos/paulirish_pwmetrics/lib/metrics.ts","prepareData","{  const audits = res.audits;   checkAudits(audits);   const colorP0 = 'yellow';  const colorP2 = 'green';  const colorVisual = 'blue';   const timings: Timing[] = [];  const navStart = metricsDefinitions.find(def => def.id === metricsIds.NAVSTART);  const timestamps: Timestamp[] = [{  title: navStart.name,  id: navStart.id,  timestamp: navStart.getTs(audits)  }];   metricsDefinitions  // exclude navStart as its not a timing  .filter(def => def.id !== metricsIds.NAVSTART)  // exclude experimental metrics  .filter(def => def.id !== metricsIds.TTI  && def.id !== metricsIds.OnLoad  && def.id !== metricsIds.EndOfATrace)  .forEach(metric => {  const resolvedMetric: Timing = {  title: metric.name,  id: metric.id,  timestamp: metric.getTs(audits),  timing: (metric.getTs(audits) - navStart.getTs(audits)) / 1000,  color: colorVisual  };   switch (metric.id) {  case metricsIds.TTFCP:  case metricsIds.TTFMP:  resolvedMetric.color = colorP2;  break;  case metricsIds.TTFI:  case metricsIds.TTCI:  resolvedMetric.color = colorP0;  break;  }   timings.push(resolvedMetric);  });   return {  timings,  timestamps,  generatedTime: res.generatedTime,  lighthouseVersion: res.lighthouseVersion,  initialUrl: res.initialUrl,  url: res.url  }; }"
"../test-repos/rangle_angular-ssr/source/bin/render.ts","adjustEnvironment","{  // Because we compile our outputs to a temporary path outside the filesystem structure of  // the project, we must tweak the module search paths to look inside the project node  // modules folder as well as our own modules folder. Otherwise we are going to encounter  // require exceptions when the application attempts to load libraries.  const roots = [options.project.basePath, pathFromString(dirname(module.filename))];   const search = roots.map(r => r.findInAncestor(Files.modules)).filter(f => f != null).map(f => f.toString());   const originalCall = Module._nodeModulePaths;   Module._nodeModulePaths = function (from) {  return [...originalCall.call(this, from), ...search];  };   Object.assign(env, {NG_RENDER: true}); }"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/control.ts","stop","{}"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/control.ts","close","{}"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/control.ts","captureEvents","{}"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/control.ts","open","{  throw new NotSupportedException(); }"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/events.ts","addEventListener","{  return this().addEventListener(type, listener, useCapture); }"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/interaction.ts","blur","{}"
"../test-repos/rangle_angular-ssr/source/runtime/browser-emulation/interaction.ts","focus","{}"
"../test-repos/rhysd_Mstdn/renderer/key_handler.ts","scrollable","{  const scrollables = document.querySelectorAll('.scrollable') as NodeListOf<HTMLElement>;  if (scrollables.length === 0) {  log.error('Scrollable element was not found!');  return;  }  for (const elem of scrollables) {  pred(elem);  } }"
"../test-repos/rhysd_Mstdn/renderer/key_handler.ts","navigateTo","{  const url = `https://${host}${path}`;  if (window.location.href === url) {  log.info('Current URL is already', url);  return;  }   const link = document.querySelector(`a[href='${path}']`);  if (link) {  log.info('Click link by shortcut', path);  (link as HTMLAnchorElement).click();  } else {  log.info('Force navigation by shortcut', path);  window.location.href = url;  } }"
"../test-repos/rhysd_Mstdn/renderer/key_handler.ts","setupKeymaps","{  const dataDir = config.__DATA_DIR || '/';  for (const key in config.keymaps) {  const action = config.keymaps[key];  if (action.endsWith('.js')) {  if (config.chromium_sandbox) {  log.info('Loading external script is limited because Chromium sandbox is enabled. Disable shortcut:', action);  continue;  }  const script = join(dataDir, action);   let plugin: (c: Config, a: Account) => void;  try {  plugin = require(script);  } catch (e) {  log.error('Error while loading plugin ' + script, e);  continue;  }  Mousetrap.bind(key, e => {  e.preventDefault();  log.info('Shortcut:', action);  try {  plugin(config, account);  } catch (e) {  log.error('Failed to run shortcut script ' + script, e);  }  });  } else if (action.startsWith('plugin:')) {  // Format is 'plugin:{name}:{action}'  const split = action.split(':').slice(1);  if (split.length <= 1) {  log.error('Invalid format keymap. Plugin-defined action should be 'plugin:{name}:{action}':', action);  continue;  }  Mousetrap.bind(key, e => {  loader.runKeyShortcut(e, split[0], split[1]);  });  } else if (action.startsWith('/')) {  Mousetrap.bind(key, e => {  e.preventDefault();  navigateTo(account.host, action);  });  } else {  const func = ShortcutActions[action];  if (!func) {  log.error('Unknown shortcut action:', action);  continue;  }  Mousetrap.bind(key, e => {  log.info('Shortcut:', action);  e.preventDefault();  func();  });  }  } }"
"../test-repos/rhysd_Mstdn/renderer/ipc.ts","on","{  ipc.on(channel, (_: any, ...args: any[]) => {  log.info('IPC: Received from:', channel, args);  callback(...args);  }); }"
"../test-repos/rhysd_Mstdn/renderer/ipc.ts","send","{  log.info('IPC: Send:', channel, args);  ipc.send(channel, ...args); }"
"../test-repos/rhysd_Mstdn/main/account_switcher.ts","partitionForAccount","{  let host = account.host;  if (account.host.startsWith('https://')) {  host = host.slice(8);  } else if (account.host.startsWith('http://')) {  host = host.slice(7);  }  return `persist:mstdn:${account.name}:${host}`; }"
"../test-repos/rhysd_Mstdn/main/app.ts","startApp","{  const default_account = config.accounts[0];  return Window.create(default_account, config)  .then(win => new App(win, config)); }"
"../test-repos/rhysd_Mstdn/main/default_menu.ts","defaultMenu","{  const template: Electron.MenuItemConstructorOptions[] = [  {  label: 'Edit',  submenu: [  {  label: 'Edit Config',  click() {  shell.openItem(path.join(app.getPath('userData'), 'config.json'));  }  },  {  type: 'separator'  },  {  role: 'undo'  },  {  role: 'redo'  },  {  type: 'separator'  },  {  role: 'cut'  },  {  role: 'copy'  },  {  role: 'paste'  },  {  role: 'pasteandmatchstyle'  },  {  role: 'delete'  },  {  role: 'selectall'  }  ]  },  {  label: 'View',  submenu: [  {  role: 'reload'  },  {  role: 'toggledevtools'  },  {  type: 'separator'  },  {  role: 'resetzoom'  },  {  role: 'zoomin'  },  {  role: 'zoomout'  },  {  type: 'separator'  },  {  role: 'togglefullscreen'  }  ]  },  {  role: 'window',  submenu: [  {  role: 'minimize'  },  {  role: 'close'  }  ]  },  {  role: 'help',  submenu: [  {  label: 'Learn More',  click() {  shell.openExternal('https://github.com/rhysd/Mstdn#readme');  }  },  {  label: 'Search Issues',  click() {  shell.openExternal('https://github.com/rhysd/Mstdn/issues');  }  }  ]  }  ];   if (process.platform === 'darwin') {  template.unshift({  label: 'Mstdn',  submenu: [  {  role: 'about'  },  {  type: 'separator'  },  {  role: 'services',  submenu: []  },  {  type: 'separator'  },  {  role: 'hide'  },  {  role: 'hideothers'  },  {  role: 'unhide'  },  {  type: 'separator'  },  {  role: 'quit'  }  ]  });   (template[1].submenu as Electron.MenuItemConstructorOptions[]).push(  {  type: 'separator'  },  {  label: 'Speech',  submenu: [  {  role: 'startspeaking'  },  {  role: 'stopspeaking'  }  ]  }  );   template[3].submenu = [  {  role: 'close'  },  {  role: 'minimize'  },  {  role: 'zoom'  },  {  type: 'separator'  },  {  role: 'front'  }  ];  } else {  template.unshift(  {  label: 'File',  submenu: [  {  role: 'quit'  }  ]  }  );  }   return Menu.buildFromTemplate(template); }"
"../test-repos/rhysd_Mstdn/main/common.ts","trayIcon","{  return path.join(__dirname, '..', 'resources', 'icon', `tray-icon-${  color === 'white' ? 'white' : 'black'  }@2x.png`); }"
"../test-repos/rhysd_Mstdn/main/window.ts","shouldOpenInternal","{  if (host.startsWith('https://pawoo.net') && url.startsWith('https://accounts.pixiv.net/login?')) {  log.debug('accounts.pixiv.net opens and will redirect to pawoo.net for signin with Pixiv account.');  return true;  }   return false; }"
"../test-repos/rhysd_Mstdn/main/window.ts","applyUserCss","{  if (config.chromium_sandbox) {  log.debug('User CSS is disabled because Chromium sandbox is enabled');  return;  }  fs.readFile(USER_CSS, 'utf8', (err, css) => {  if (err) {  log.debug('Failed to load user.css: ', err.message);  return;  }  win.webContents.insertCSS(css);  log.debug('Applied user CSS:', USER_CSS);  }); }"
"../test-repos/rhysd_Mstdn/main/window.ts","startNormalWindow","{  log.debug('Setup a normal window');  return new Promise<Window>(resolve => {  const state = windowState({  defaultWidth: 600,  defaultHeight: 800,  });  const win = new BrowserWindow({  width: state.width,  height: state.height,  x: state.x,  y: state.y,  icon: APP_ICON,  show: false,  autoHideMenuBar: !!config.hide_menu,  webPreferences: {  nodeIntegration: false,  sandbox: sandboxFlag(config, account),  preload: PRELOAD_JS,  partition: partitionForAccount(account),  zoomFactor: config.zoom_factor,  },  });  win.once('ready-to-show', () => {  win.show();  });  win.once('closed', () => {  app.quit();  });   if (state.isFullScreen) {  win.setFullScreen(true);  } else if (state.isMaximized) {  win.maximize();  }  state.manage(win);   win.webContents.once('dom-ready', () => {  log.debug('Normal window application was launched');  if (IS_DEBUG) {  win.webContents.openDevTools({mode: 'detach'});  }  });   resolve(new Window(win, state, account, null));  }); }"
"../test-repos/rhysd_Mstdn/main/window.ts","sandboxFlag","{  // XXX:  // Electron has a bug that CSP prevents preload script from being loaded.  // mstdn.jp enables CSP. So currently we need to disable native sandbox to load preload script.  //  // Ref: https://github.com/electron/electron/issues/9276  //  const electronBugIssue9276 = account.host === 'mstdn.jp' || account.host === 'https://mstdn.jp';  if (electronBugIssue9276) {  return false;  }  return !!config.chromium_sandbox; }"
"../test-repos/rhysd_Mstdn/main/window.ts","startMenuBar","{  log.debug('Setup a menubar window');  return new Promise<Window>(resolve => {  const state = windowState({  defaultWidth: 320,  defaultHeight: 420,  });  const icon = trayIcon(config.icon_color);  const mb = bar || menubar({  icon,  width: state.width,  height: state.height,  alwaysOnTop: IS_DEBUG || !!config.always_on_top,  tooltip: 'Mstdn',  autoHideMenuBar: !!config.hide_menu,  show: false,  showDockIcon: true,  webPreferences: {  nodeIntegration: false,  sandbox: sandboxFlag(config, account),  preload: PRELOAD_JS,  partition: partitionForAccount(account),  zoomFactor: config.zoom_factor,  },  });  mb.once('after-create-window', () => {  log.debug('Menubar application was launched');  if (IS_DEBUG) {  mb.window.webContents.openDevTools({mode: 'detach'});  }  state.manage(mb.window);   resolve(new Window(mb.window, state, account, mb));  });  mb.once('after-close', () => {  app.quit();  });  if (bar) {  log.debug('Recreate menubar window with different partition:', account);  const pref = mb.getOption('webPreferences');  pref.partition = partitionForAccount(account);  pref.sandbox = sandboxFlag(config, account);  mb.setOption('webPreferences', pref);  mb.showWindow();  } else {  log.debug('New menubar instance was created:', account);  mb.once('ready', () => mb.showWindow());  }  }); }"
"../test-repos/rhysd_Mstdn/main/config.ts","makeDefaultConfig","{  const IsDarkMode = IS_DARWIN && systemPreferences.isDarkMode();  const menubarBroken = IS_WINDOWS;   return {  hot_key: 'CmdOrCtrl+Shift+Enter',  icon_color: IsDarkMode ? 'white' : 'black',  always_on_top: false,  hide_menu: false,  normal_window: menubarBroken,  zoom_factor: 0.9,  chromium_sandbox: true,  accounts: [{  name: '',  host: '',  default_page: '/web/timelines/home',  plugins: [],  }],  keymaps: {  j: 'scroll-down',  k: 'scroll-up',  i: 'scroll-top',  m: 'scroll-bottom',  1: '/web/statuses/new',  2: '/web/timelines/home',  3: '/web/notifications',  4: '/web/timelines/public/local',  5: '/web/timelines/public',  6: '/web/getting-started'  },  }; }"
"../test-repos/rhysd_Mstdn/main/config.ts","showDyingDialog","{  dialog.showMessageBox({  type: 'info',  message: title,  detail,  }, () => {  app.quit();  }); }"
"../test-repos/rhysd_Mstdn/main/config.ts","recommendConfigAndDie","{  const title = 'Please write configuration in JSON';  const detail = 'You need to write up name and host in first item of accounts. Restart this app after writing up them. Please see README for more detail: https://github.com/rhysd/Mstdn#readme';  shell.openItem(file);  showDyingDialog(title, detail); }"
"../test-repos/rhysd_Mstdn/main/config.ts","hostUrl","{  if (a.host.startsWith('https://') || a.host.startsWith('http://')) {  return a.host;  } else {  return 'https://' + a.host;  } }"
"../test-repos/rhysd_Mstdn/main/config.ts","loadConfig","{  return new Promise<Config>(resolve => {  fs.readFile(CONFIG_FILE, 'utf8', (err, json) => {  if (err) {  log.info('Configuration file was not found, will create:', CONFIG_FILE);  const default_config = makeDefaultConfig();  // Note:  // If calling writeFile() directly here, it tries to create config file before Electron  // runtime creates data directory. As the result, writeFile() would fail to create a file.  if (app.isReady()) {  fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, 2));  recommendConfigAndDie(CONFIG_FILE);  } else {  app.once('ready', () => {  fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, 2));  recommendConfigAndDie(CONFIG_FILE);  });  }  return;  }   try {  const config = JSON.parse(json);  if (config.hot_key && config.hot_key.startsWith('mod+')) {  config.hot_key = `CmdOrCtrl+${config.hot_key.slice(4)}`;  }  log.debug('Configuration was loaded successfully', config);  if (!config.accounts || config.accounts[0].host === '' || config.accounts[0].name === '') {  recommendConfigAndDie(CONFIG_FILE);  } else {  config.__DATA_DIR = DATA_DIR;  if (config.chromium_sandbox === undefined) {  config.chromium_sandbox = true;  }  resolve(config);  }  } catch (e) {  log.debug('Error on loading JSON file', e);  showDyingDialog('Error on loading JSON file', e.message);  }  });  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","calculateFlexWrap","{  if (wrap && reverse) {  return 'wrap-reverse';  } else if (wrap && !reverse) {  return 'wrap';  } else {  return 'nowrap';  } }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","sizeToString","{  let returnVal;  if (typeof size === 'string') {  returnVal = `${remFromPX(SIZE_MAP[size])}rem`;  } else if (typeof size === 'object') {  const horizontal = size.horizontal || 'none';  const vertical = size.vertical || 'none';  returnVal = `${remFromPX(SIZE_MAP[vertical])}rem ${remFromPX(SIZE_MAP[horizontal])}rem`;  } else {  returnVal = `0rem`;  }  return returnVal; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","stringBoxStyle","{  if (size === 'full') {  return {  width: '100vw',  height: 'auto',  };  } else {  return {  width: size ? `${remFromPX(BOX_SIZE_MAP[size])}rem` : '',  height: size ? `${remFromPX(BOX_SIZE_MAP[size])}rem` : '',  };  } }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","objectBoxStyle","{  let width = 'auto';  let height = 'auto';  if (size.vertical) {  height = size.vertical === 'full'  ? '100vh'  : `${remFromPX(BOX_SIZE_MAP[size.vertical])}rem`;  }  if (size.horizontal) {  width = size.horizontal === 'full'  ? '100vw'  : `${remFromPX(BOX_SIZE_MAP[size.horizontal])}rem`;  }  return {  width,  height,  }; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","boxSizeToStyle","{  if (typeof size === 'string') {  return stringBoxStyle(size);  } else if (typeof size === 'object') {  return objectBoxStyle(size);  } else {  return { width: 'auto', height: 'auto' };  } }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Box/styleUtils.ts","calculateFullStyle","{  if (typeof full === 'object') {  if (postFix === 'vw') {  return full.horizontal ? `100${postFix}` : 'auto';  } else {  return full.vertical ? `100${postFix}` : 'auto';  }  } else if (typeof full === 'boolean') {  return full ? `100${postFix}` : 'auto';  }  return 'auto'; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Paragraph/styleUtils.ts","calculateMargin","{  return remStringFromPX(marginSizeMap[margin]); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Paragraph/styleUtils.ts","calculateSize","{  return remStringFromPX(sizeMap[size]); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Paragraph/styles.ts","marginCss","{  return css`  margin-top: ${calculateMargin(margin)};  margin-bottom: ${calculateMargin(margin)};  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Headline/styleUtils.ts","calculateSize","{  return remStringFromPX(sizeMap[size]); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/WithAnimation/animation.ts","styles","{  const opacity = props.isVisible ? 1.0 : 0.0;  const transform = props.isVisible ? 0 : 20;  switch (props.type) {  case 'fadeIn':  return css`  opacity: ${opacity};  `;  case 'fadeInUp':  return css`  opacity: ${opacity};  transform: translateY(${transform}%);  will-change: transform, opacity;  `;  default:  return '';  } }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/WithAnimation/animation.ts","transition","{  const duration = 600;  return css`  transition: transform ${duration / 2}ms ease, opacity ${duration}ms ease-out;  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/WithAnimation/animation.ts","delay","{  return css`  transition-delay: ${delay}ms;  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Hero/styles.ts","background","{  if (props.backgroundImage) {  return css`  background: ${(props: Props) => `url(${props.backgroundImage})`} center center / cover no-repeat;  `;  } else if (props.backgroundColor) {  return css`  background-color: ${(props: Props) => props.backgroundColor};  `;  } }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Hero/styles.ts","height","{  if (props.height) {  const height = typeof props.height === 'string'  ? props.height  : `${props.height}px`;  return css`  height: ${height};  `;  }  if (props.full) {  return css`  height: 100vh;  `;  }  return css`  height: auto;  min-height: 350px;  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Header/styles.ts","translateStyle","{  const translate = state === 'Pinned' ? 0 : -height;  return css`  transform: translate3d(0px, ${translate}px, 0px);  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/openui/src/Header/styles.ts","headerStyles","{  return css`  ${(props: OwnProps) => translateStyle(props)}  padding: 20px;  position: fixed;  top: 0;  right: 0;  left: 0;  z-index: 8;  width: 100%;  will-change: transform;  transition: transform 600ms ease, background-color 600ms ease, height 600ms ease;  background-color: ${(props: OwnProps) => props.backgroundColor || 'rgba(245,245,245,.95)'};  `; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/server/graphqlEntry.ts","createSchema","{  return new Promise<string>((res, rej) => {  graphql(schema, introspectionQuery)  .then((json) => {  fs.writeFile(  path.join(__dirname, './graph/schema.json'),  JSON.stringify(json, null, 2),  (err) => {  if (err) {  rej(`Error occured while creating graphql schema. ${err}`);  }  res('Schema successfully created');  },  );  });  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/server/graphqlEntry.ts","graphqlEntry","{  return new Promise<express.Application>(async (res, rej) => {  app.use(bodyParser.json());  app.use(bodyParser.urlencoded({ extended: true }));  app.use('/api', cors(), graphqlExpress({  schema,  }));   app.use('/graphql-ui', graphiqlExpress({  endpointURL: '/api',  }));  await createSchema().catch((err) => rej(err));  res(app);  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/server/db/index.ts","seedPosts","{  return [  {  title: 'Welcome!',  content: 'Hey there! Welcome to the blog of Scalable-React-TypeScript! ' +  'This is just an introductory post, but stay tuned for more!',  image: 'https://raw.githubusercontent.com/RyanCCollins/cdn/master/stsb-images/ts-resized-2.png',  },  ]; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/server/db/index.ts","createSeedPosts","{  return new Promise((res, rej) => {  PostModel.find().exec((err, docs) => {  if (docs.length === 0) {  PostModel.create(  seedPosts(),  (err, data) => {  if (err) {  rej(err);  }  res(data);  },  );  }  });  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/server/db/index.ts","createSeedData","{  return new Promise((res, rej) => {  createSeedPosts().then(() => {  res();  }).catch((err) => rej(err));  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/packages/docs/src/client/components/PostCard/shortenText.ts","shortenText","{  if (text.length > maxLength) {  return `${text.substr(0, maxLength - 3)}...`;  }  return text; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/src/server/graphqlEntry.ts","createSchema","{  return new Promise<string>((res, rej) => {  graphql(schema, introspectionQuery)  .then((json) => {  fs.writeFile(  path.join(__dirname, './graph/schema.json'),  JSON.stringify(json, null, 2),  (err) => {  if (err) {  rej(`Error occured while creating graphql schema. ${err}`);  }  res('Schema successfully created');  },  );  });  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/src/server/graphqlEntry.ts","graphqlEntry","{  return new Promise<express.Application>(async (res, rej) => {  app.use(bodyParser.json());  app.use(bodyParser.urlencoded({ extended: true }));  app.use('/api', cors(), graphqlExpress({  schema,  }));   app.use('/graphql-ui', graphiqlExpress({  endpointURL: '/api',  }));  await createSchema().catch((err) => rej(err));  res(app);  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/src/server/db/index.ts","seedPosts","{  return [  {  title: 'Welcome!',  content: 'Hey there! Welcome to the blog of Scalable-React-TypeScript! ' +  'This is just an introductory post, but stay tuned for more!',  image: 'https://raw.githubusercontent.com/RyanCCollins/cdn/master/stsb-images/ts-resized-2.png',  },  ]; }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/src/server/db/index.ts","createSeedPosts","{  return new Promise((res, rej) => {  PostModel.find().exec((err, docs) => {  if (docs.length === 0) {  PostModel.create(  seedPosts(),  (err, data) => {  if (err) {  rej(err);  }  res(data);  },  );  }  });  }); }"
"../test-repos/scalable-react_scalable-react-typescript-boilerplate/src/server/db/index.ts","createSeedData","{  return new Promise((res, rej) => {  createSeedPosts().then(() => {  res();  }).catch((err) => rej(err));  }); }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Socket.ts","setupSockets","{  let server = io(app);   server.use((socket, next) => {  passport.authenticate('jwt', { session: false }, (err, user, info) => {  if(err) next(new Error('Error in passport authenticate'));  if(!user) next(new Error('Failed to authenticate oAuth token'));  socket.request.user = user;  return next();  })(socket.request, null, next);  });   server.on('connection', (socket) => {  logger.info('Web Sockets initalized');  // const userId = socket.request.session.passport.user;   // bind applicable subscribers to the socket  defaultMetadataRegistry  .collectEventsHandlers  .forEach(eventHandler => {  const eventNamesForThisHandler = Object.keys(eventHandler);  eventNamesForThisHandler.forEach(eventName => {  const callback = eventHandler[eventName];  socket.on(eventName, (data) => {  callback(Object.assign({ socket }, data));  });  });  });  });   return io; }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Authentication.ts","verify","{  const id = payload.sub;  return id !== undefined;  /*  User.findOne({ id: jwt_payload.sub }, (err, user) => {  if (err) return done(err, false);   if (user) {  done(null, user);  } else {  done(null, false);  // or you could create a new account  }  });  */ }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Authentication.ts","setupAuth","{  app.use(passport.initialize());  passport.use(new JwtStrategy(opts, verify)); }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Logging.ts","setupLogging","{  // Development Logger  // const env = config.util.getEnv('NODE_ENV');  if(level === 'info') {  logger.add(winston.transports.Console, {  type: 'verbose',  colorize: true,  prettyPrint: true,  handleExceptions: true,  humanReadableUnhandledException: true  });  }   setupExpress(app); }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Logging.ts","setupExpress","{  // error logging  if(level === 'debug') {  app.use(expressWinston.errorLogger({  transports: [  new winston.transports.Console({  json: true,  colorize: true  })  ]  }));  }   // request logging  if(level === 'info') {  app.use(expressWinston.logger({  transports: [  new winston.transports.Console({  json: true,  colorize: true  })  ]  }));  } }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Swagger.ts","setupSwagger","{  // resolve the spec  const spath = path.resolve('./dist/spec.json');  const file = fs.readFileSync(spath, 'utf8');  const spec = JSON.parse(file);   // setup middleware swagger middleware in express  swaggerTools.initializeMiddleware(spec, (middleware) => {  app.use(middleware.swaggerUi());  app.use(middleware.swaggerMetadata());  app.use(setupSwaggerSecurity(middleware));  app.use(middleware.swaggerValidator({  validateResponse: true  }));  }); }"
"../test-repos/swimlane_node-microservice-demo/petstore/src/config/Swagger.ts","setupSwaggerSecurity","{  return middleware.swaggerSecurity({  jwt_token: (req, authOrSecDef, scopes, callback) => {  passport.authenticate('jwt', { session: false }, (err, user, info) => {  if(err) callback(new Error('Error in passport authenticate'));  if(!user) callback(new Error('Failed to authenticate oAuth token'));  req.user = user;  return callback();  })(req, null, callback);  }  }); }"
"../test-repos/theintern_leadfoot/tests/srcLoader.ts","normalize","{  return id; }"
"../test-repos/theintern_leadfoot/tests/srcLoader.ts","load","{  pluginRequire(['dojo/node!' + require.toUrl(id)], function(module) {   callback(module);  }); }"
"../test-repos/theintern_leadfoot/tests/functional/Element.ts","toUrl","{  return (<any>require).toUrl(url); }"
"../test-repos/theintern_leadfoot/tests/functional/Element.ts","createStubbedSuite","{  let originalMethod: Function;  let calledWith: any;  let extraArguments: any[] = [];  let element = new Element('test', <Session>{});  const suite = {   setup: function() {    originalMethod = (<any>element)[stubbedMethodName];    (<any>element)[stubbedMethodName] = function() {     calledWith = arguments;    };     for (let i = 0, j = originalMethod.length - 1; i < j; ++i) {     extraArguments.push('ok' + (i + 2));    }   },   beforeEach: function() {    calledWith = null;   },    teardown: function() {    (<any>element)[stubbedMethodName] = originalMethod;   }  };   placeholders.forEach(function(placeholder: string, index: number) {   const method = testMethodName.replace('_', placeholder);    (<any>suite)['#' + method] = function() {    assert.isFunction((<any>element)[method]);    (<any>element)[method].apply(element, extraArguments);    assert.ok(calledWith);    assert.strictEqual(calledWith[0], firstArguments[index]);    assert.deepEqual(     Array.prototype.slice.call(calledWith, 1),     extraArguments    );   };  });   return suite; }"
"../test-repos/theintern_leadfoot/tests/functional/Element.ts","getId","{     assert.property(      element,      'elementId',      'Returned object should look like an element object'     );     return element.getAttribute('id');    }"
"../test-repos/theintern_leadfoot/tests/functional/Element.ts","getIds","{     elements.forEach(function(element, index) {      assert.property(       element,       'elementId',       'Returned object ' +        index +        ' should look like an element object'      );     });      return Task.all(      elements.map(function(element) {       return element.getAttribute('id');      })     );    }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","toUrl","{  return (<any>require).toUrl(url); }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","createStubbedSuite","{   let originalMethod: Function;   let calledWith: any;   let extraArguments: any[] = [];   const suite: any = {    setup: function() {     originalMethod = session[stubbedMethodName];     session[stubbedMethodName] = function() {      calledWith = arguments;     };      for (let i = 0, j = originalMethod.length - 1; i < j; ++i) {      extraArguments.push('ok' + (i + 2));     }    },    beforeEach: function() {     calledWith = null;    },     teardown: function() {     session[stubbedMethodName] = originalMethod;    }   };    placeholders.forEach(function(placeholder, index) {    const method = testMethodName.replace('_', placeholder);     suite['#' + method] = function() {     assert.isFunction(session[method]);     session[method].apply(session, extraArguments);     assert.ok(calledWith);     assert.strictEqual(calledWith[0], firstArguments[index]);     assert.deepEqual(      Array.prototype.slice.call(calledWith, 1),      extraArguments     );    };   });    return suite;  }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","createStorageTests","{   const clear = 'clear' + type + 'Storage';   const getKeys = 'get' + type + 'StorageKeys';   const get = 'get' + type + 'StorageItem';   const set = 'set' + type + 'StorageItem';   const del = 'delete' + type + 'StorageItem';   const getLength = 'get' + type + 'StorageLength';    return function(this: Test) {    if (!session.capabilities.webStorageEnabled) {     this.skip('web storage not enabled');    }     return session     .get(toUrl('./data/default.html'))     .then(function() {      return session[set]('foo', 'foo');     })     .then(function() {      return session[clear]();     })     .then(function() {      return session[getLength]();     })     .then(function(length: number) {      assert.strictEqual(       length,       0,       'Cleared storage should contain no data'      );      return session[set]('foo', 'foo');     })     .then(function() {      return session[set]('bar', 'bar');     })     .then(function() {      return session[set]('foo', 'foofoo');     })     .then(function() {      return session[getLength]();     })     .then(function(length: number) {      assert.strictEqual(       length,       2,       'Getting size should return the number of data items in storage'      );      return session[getKeys]();     })     .then(function(keys: string[]) {      assert.sameMembers(       keys,       ['foo', 'bar'],       'Storage should contain set keys'      );      return session[get]('foo');     })     .then(function(value: string) {      assert.strictEqual(       value,       'foofoo',       'Getting item should retrieve correct stored value'      );      return session[del]('not-existing');     })     .then(function() {      return session[getLength]();     })     .then(function(length: number) {      assert.strictEqual(       length,       2,       'Deleting non-existing key should not change size of storage'      );      return session[del]('foo');     })     .then(function() {      return session[getKeys]();     })     .then(function(keys: string[]) {      assert.deepEqual(       keys,       ['bar'],       'Deleting existing key should reduce size of storage'      );      return session[clear]();     })     .catch(function(error: Error) {      return session[clear]().then(function() {       throw error;      });     });   };  }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","getScrollPosition","{   // touchScroll scrolls in device pixels; scroll position is normally in   // reference pixels, so get the correct device pixel location to verify   // that it worked properly   return session.execute(    function(element?: HTMLElement) {     if (!element) {      element = document.documentElement;      if (!element.scrollLeft && !element.scrollTop) {       element = document.body;      }     }      return {      x: element.scrollLeft,      y: element.scrollTop     };    },    [element]   );  }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","getId","{     assert.property(      element,      'elementId',      'Returned object should look like an element object'     );     return element.getAttribute('id');    }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","getIds","{     elements.forEach(function(element, index) {      assert.property(       element,       'elementId',       'Returned object ' +        index +        ' should look like an element object'      );     });      return Task.all(      elements.map(function(element: Element) {       return element.getAttribute('id');      })     );    }"
"../test-repos/theintern_leadfoot/tests/functional/Session.ts","click","{     /*jshint maxlen:140 */     return function() {      return session       .clickMouseButton(button)       .then(function() {        return session.execute(         'return result.click.a && result.click.a[0];'        );       })       .then(function(event: any) {        assert.strictEqual(event.button, button);        return session         .execute(          'return result.mousedown.a && result.mousedown.a[0];'         )         .then(function(mouseDownEvent: MouseEvent) {          assert.closeTo(           event.timeStamp,           mouseDownEvent.timeStamp,           300          );          assert.operator(           mouseDownEvent.timeStamp,           '<=',           event.timeStamp          );          return session.execute(           'return result.mouseup.a && result.mouseup.a[0];'          );         })         .then(function(mouseUpEvent: MouseEvent) {          assert.closeTo(           event.timeStamp,           mouseUpEvent.timeStamp,           300          );          assert.operator(           mouseUpEvent.timeStamp,           '<=',           event.timeStamp          );         });       });     };    }"
"../test-repos/theintern_leadfoot/tests/functional/support/util.ts","createServer","{  return new Server(config); }"
"../test-repos/theintern_leadfoot/tests/functional/support/util.ts","createServerFromRemote","{  if (remote.session && remote.session.server) {   return new Server(remote.session.server.url);  }   throw new Error('Unsupported remote'); }"
"../test-repos/theintern_leadfoot/tests/functional/support/util.ts","createSessionFromRemote","{  const server = createServerFromRemote(remote);   function fixGet(session: any) {   const oldGet = session.get;   session.get = function(this: Session, url: string) {    if (!/^[A-Za-z][A-Za-z0-9+.-]+:/.test(url)) {     url = convertPathToUrl(remote, url);    }     return oldGet.call(this, url);   };  }   if (remote.session) {   const session = new SessionCtor(    remote.session.sessionId,    server,    remote.session.capabilities   );   fixGet(session);   return server['_fillCapabilities'](session);  }   throw new Error('Unsupported remote'); }"
"../test-repos/theintern_leadfoot/tests/functional/support/util.ts","fixGet","{   const oldGet = session.get;   session.get = function(this: Session, url: string) {    if (!/^[A-Za-z][A-Za-z0-9+.-]+:/.test(url)) {     url = convertPathToUrl(remote, url);    }     return oldGet.call(this, url);   };  }"
"../test-repos/theintern_leadfoot/tests/functional/support/util.ts","convertPathToUrl","{  if (session.session) {   session = session.session;  }   return session.proxyUrl + url.slice(session.proxyBasePathLength); }"
"../test-repos/theintern_leadfoot/tests/functional/helpers/pollUntil.ts","toUrl","{  return (<any>require).toUrl(url); }"
"../test-repos/theintern_leadfoot/src/Element.ts","noop","{  // At least ios-driver 0.6.6 returns an empty object for methods that are  // supposed to return no value at all, which is not correct }"
"../test-repos/theintern_leadfoot/src/Session.ts","manualClose","{    return self.getCurrentWindowHandle().then(function(handle: any) {     return self.execute('window.close();').then(function() {      self._closedWindows[handle] = true;     });    });   }"
"../test-repos/theintern_leadfoot/src/Session.ts","forCommand","{  return function(   target: any,   property: string,   descriptor: PropertyDescriptor  ) {   const fn = <Function>target[property];   descriptor.value = utilForCommand(fn, properties);  }; }"
"../test-repos/theintern_leadfoot/src/Session.ts","convertToElements","{  // TODO: Unit test elements attached to objects  function convert(value: any) {   if (Array.isArray(value)) {    value = value.map(convert);   } else if (typeof value === 'object' && value !== null) {    if (value.ELEMENT) {     value = new Element(value, session);    } else {     for (let k in value) {      value[k] = convert(value[k]);     }    }   }    return value;  }   return convert(value); }"
"../test-repos/theintern_leadfoot/src/Session.ts","convert","{   if (Array.isArray(value)) {    value = value.map(convert);   } else if (typeof value === 'object' && value !== null) {    if (value.ELEMENT) {     value = new Element(value, session);    } else {     for (let k in value) {      value[k] = convert(value[k]);     }    }   }    return value;  }"
"../test-repos/theintern_leadfoot/src/Session.ts","fixExecuteError","{  if (error.name === 'UnknownError') {   error.status = '17';   error.name = statusCodes[error.status][0];  }   throw error; }"
"../test-repos/theintern_leadfoot/src/Session.ts","pushCookieProperties","{  Object.keys(source).forEach(function(key) {   let value = source[key];    if (    key === 'name' ||    key === 'value' ||    (key === 'domain' && value === 'http')   ) {    return;   }    if (typeof value === 'boolean') {    value && target.push(key);   } else if (key === 'expiry') {    // JsonWireProtocol uses the key 'expiry' but JavaScript cookies    // use the key 'expires'    if (typeof value === 'number') {     value = new Date(value * 1000);    }     if (value instanceof Date) {     value = value.toUTCString();    }     target.push('expires=' + encodeURIComponent(value));   } else {    target.push(key + '=' + encodeURIComponent(value));   }  }); }"
"../test-repos/theintern_leadfoot/src/Session.ts","simulateKeys","{  const target = <any>document.activeElement;   function dispatch(kwArgs: any) {   let event: KeyboardEvent;    if (typeof KeyboardEvent === 'function') {    event = new KeyboardEvent(kwArgs.type, {     bubbles: true,     cancelable: kwArgs.cancelable || false,     view: window,     key: kwArgs.key || '',     location: 3    });   } else {    event = document.createEvent('KeyboardEvent');    event.initKeyboardEvent(     kwArgs.type,     true,     kwArgs.cancelable || false,     window,     kwArgs.key || '',     3,     '',     <any>0,     ''    );   }    return target.dispatchEvent(event);  }   function dispatchInput() {   let event: Event;   if (typeof Event === 'function') {    event = new Event('input', { bubbles: true, cancelable: false });   } else {    event = document.createEvent('Event');    event.initEvent('input', true, false);   }   return target.dispatchEvent(event);  }   keys = (<string[]>[]).concat(...keys.map(keys => keys.split('')));   for (let i = 0, j = keys.length; i < j; ++i) {   const key = keys[i];   let performDefault = true;    performDefault = dispatch({    type: 'keydown',    cancelable: true,    key: key   });   performDefault =    performDefault &&    dispatch({ type: 'keypress', cancelable: true, key: key });    if (performDefault) {    if ('value' in target) {     target.value =      target.value.slice(0, target.selectionStart) +      key +      target.value.slice(target.selectionEnd);     dispatchInput();    } else if (target.isContentEditable) {     let node = document.createTextNode(key);     let selection = window.getSelection();     let range = selection.getRangeAt(0);     range.deleteContents();     range.insertNode(node);     range.setStartAfter(node);     range.setEndAfter(node);     selection.removeAllRanges();     selection.addRange(range);    }   }    dispatch({ type: 'keyup', cancelable: true, key: key });  } }"
"../test-repos/theintern_leadfoot/src/Session.ts","dispatch","{   let event: KeyboardEvent;    if (typeof KeyboardEvent === 'function') {    event = new KeyboardEvent(kwArgs.type, {     bubbles: true,     cancelable: kwArgs.cancelable || false,     view: window,     key: kwArgs.key || '',     location: 3    });   } else {    event = document.createEvent('KeyboardEvent');    event.initKeyboardEvent(     kwArgs.type,     true,     kwArgs.cancelable || false,     window,     kwArgs.key || '',     3,     '',     <any>0,     ''    );   }    return target.dispatchEvent(event);  }"
"../test-repos/theintern_leadfoot/src/Session.ts","dispatchInput","{   let event: Event;   if (typeof Event === 'function') {    event = new Event('input', { bubbles: true, cancelable: false });   } else {    event = document.createEvent('Event');    event.initEvent('input', true, false);   }   return target.dispatchEvent(event);  }"
"../test-repos/theintern_leadfoot/src/Session.ts","simulateMouse","{  let position = kwArgs.position;   function dispatch(kwArgs: any) {   let event: MouseEvent;   if (typeof MouseEvent === 'function') {    event = new MouseEvent(kwArgs.type, {     bubbles: 'bubbles' in kwArgs ? kwArgs.bubbles : true,     cancelable: kwArgs.cancelable || false,     view: window,     detail: kwArgs.detail || 0,     screenX: window.screenX + position.x,     screenY: window.screenY + position.y,     clientX: position.x,     clientY: position.y,     ctrlKey: kwArgs.ctrlKey || false,     shiftKey: kwArgs.shiftKey || false,     altKey: kwArgs.altKey || false,     metaKey: kwArgs.metaKey || false,     button: kwArgs.button || 0,     relatedTarget: kwArgs.relatedTarget    });   } else {    event = document.createEvent('MouseEvents');    event.initMouseEvent(     kwArgs.type,     kwArgs.bubbles || true,     kwArgs.cancelable || false,     window,     kwArgs.detail || 0,     window.screenX + position.x,     window.screenY + position.y,     position.x,     position.y,     kwArgs.ctrlKey || false,     kwArgs.altKey || false,     kwArgs.shiftKey || false,     kwArgs.metaKey || false,     kwArgs.button || 0,     kwArgs.relatedTarget || null    );   }    return kwArgs.target.dispatchEvent(event);  }   function click(target: any, button: any, detail: any) {   if (!down(target, button)) {    return false;   }    if (!up(target, button)) {    return false;   }    return dispatch({    button: button,    cancelable: true,    detail: detail,    target: target,    type: 'click'   });  }   function down(target: any, button: any) {   return dispatch({    button: button,    cancelable: true,    target: target,    type: 'mousedown'   });  }   function up(target: any, button: any) {   return dispatch({    button: button,    cancelable: true,    target: target,    type: 'mouseup'   });  }   function move(   currentElement: HTMLElement,   newElement: HTMLElement,   xOffset: number,   yOffset: number  ) {   if (newElement) {    const bbox = newElement.getBoundingClientRect();     if (xOffset == null) {     xOffset = (bbox.right - bbox.left) * 0.5;    }     if (yOffset == null) {     yOffset = (bbox.bottom - bbox.top) * 0.5;    }     position = { x: bbox.left + xOffset, y: bbox.top + yOffset };   } else {    position.x += xOffset || 0;    position.y += yOffset || 0;     newElement = <HTMLElement>document.elementFromPoint(     position.x,     position.y    );   }    if (currentElement !== newElement) {    dispatch({     type: 'mouseout',     target: currentElement,     relatedTarget: newElement    });    dispatch({     type: 'mouseleave',     target: currentElement,     relatedTarget: newElement,     bubbles: false    });    dispatch({     type: 'mouseenter',     target: newElement,     relatedTarget: currentElement,     bubbles: false    });    dispatch({     type: 'mouseover',     target: newElement,     relatedTarget: currentElement    });   }    dispatch({ type: 'mousemove', target: newElement, bubbles: true });    return position;  }   const target = <HTMLElement>document.elementFromPoint(   position.x,   position.y  );   if (kwArgs.action === 'mousemove') {   return move(target, kwArgs.element, kwArgs.xOffset, kwArgs.yOffset);  } else if (kwArgs.action === 'mousedown') {   return down(target, kwArgs.button);  } else if (kwArgs.action === 'mouseup') {   return up(target, kwArgs.button);  } else if (kwArgs.action === 'click') {   return click(target, kwArgs.button, 0);  } else if (kwArgs.action === 'dblclick') {   if (!click(target, kwArgs.button, 0)) {    return false;   }    if (!click(target, kwArgs.button, 1)) {    return false;   }    return dispatch({    type: 'dblclick',    target: target,    button: kwArgs.button,    detail: 2,    cancelable: true   });  } }"
"../test-repos/theintern_leadfoot/src/Session.ts","dispatch","{   let event: MouseEvent;   if (typeof MouseEvent === 'function') {    event = new MouseEvent(kwArgs.type, {     bubbles: 'bubbles' in kwArgs ? kwArgs.bubbles : true,     cancelable: kwArgs.cancelable || false,     view: window,     detail: kwArgs.detail || 0,     screenX: window.screenX + position.x,     screenY: window.screenY + position.y,     clientX: position.x,     clientY: position.y,     ctrlKey: kwArgs.ctrlKey || false,     shiftKey: kwArgs.shiftKey || false,     altKey: kwArgs.altKey || false,     metaKey: kwArgs.metaKey || false,     button: kwArgs.button || 0,     relatedTarget: kwArgs.relatedTarget    });   } else {    event = document.createEvent('MouseEvents');    event.initMouseEvent(     kwArgs.type,     kwArgs.bubbles || true,     kwArgs.cancelable || false,     window,     kwArgs.detail || 0,     window.screenX + position.x,     window.screenY + position.y,     position.x,     position.y,     kwArgs.ctrlKey || false,     kwArgs.altKey || false,     kwArgs.shiftKey || false,     kwArgs.metaKey || false,     kwArgs.button || 0,     kwArgs.relatedTarget || null    );   }    return kwArgs.target.dispatchEvent(event);  }"
"../test-repos/theintern_leadfoot/src/Session.ts","click","{   if (!down(target, button)) {    return false;   }    if (!up(target, button)) {    return false;   }    return dispatch({    button: button,    cancelable: true,    detail: detail,    target: target,    type: 'click'   });  }"
"../test-repos/theintern_leadfoot/src/Session.ts","down","{   return dispatch({    button: button,    cancelable: true,    target: target,    type: 'mousedown'   });  }"
"../test-repos/theintern_leadfoot/src/Session.ts","up","{   return dispatch({    button: button,    cancelable: true,    target: target,    type: 'mouseup'   });  }"
"../test-repos/theintern_leadfoot/src/Session.ts","move","{   if (newElement) {    const bbox = newElement.getBoundingClientRect();     if (xOffset == null) {     xOffset = (bbox.right - bbox.left) * 0.5;    }     if (yOffset == null) {     yOffset = (bbox.bottom - bbox.top) * 0.5;    }     position = { x: bbox.left + xOffset, y: bbox.top + yOffset };   } else {    position.x += xOffset || 0;    position.y += yOffset || 0;     newElement = <HTMLElement>document.elementFromPoint(     position.x,     position.y    );   }    if (currentElement !== newElement) {    dispatch({     type: 'mouseout',     target: currentElement,     relatedTarget: newElement    });    dispatch({     type: 'mouseleave',     target: currentElement,     relatedTarget: newElement,     bubbles: false    });    dispatch({     type: 'mouseenter',     target: newElement,     relatedTarget: currentElement,     bubbles: false    });    dispatch({     type: 'mouseover',     target: newElement,     relatedTarget: currentElement    });   }    dispatch({ type: 'mousemove', target: newElement, bubbles: true });    return position;  }"
"../test-repos/theintern_leadfoot/src/Session.ts","isStringArray","{  return Array.isArray(value) && typeof value[0] === 'string'; }"
"../test-repos/theintern_leadfoot/src/lib/Locator.ts","toW3cLocator","{  switch (using) {   case 'id':    using = 'css selector';    value = `#${value}`;    break;   case 'class name':    using = 'css selector';    value = `.${value}`;    break;   case 'name':    using = 'css selector';    value = `[name='${value}']`;    break;   case 'tag name':    using = 'css selector';    break;  }   return { using, value }; }"
"../test-repos/theintern_leadfoot/src/lib/util.ts","sleep","{  let timer: NodeJS.Timer;  return new Task<void>(   function(resolve) {    timer = setTimeout(() => {     resolve();    }, ms);   },   () => clearTimeout(timer)  ); }"
"../test-repos/theintern_leadfoot/src/lib/util.ts","forCommand","{  return mixin(fn, properties); }"
"../test-repos/theintern_leadfoot/src/lib/util.ts","toExecuteString","{  if (typeof fn === 'function') {   // If someone runs code through Istanbul in the test runner, inline   // functions that are supposed to execute on the client will contain   // code coverage variables that will cause script execution failure.   // These statements are very simple and are generated in a consistent   // manner, so we can get rid of them easily with a regular expression   fn = fn.toString().replace(/\b__cov_[^,;]+[,;]/g, '');   fn = 'return (' + fn + ').apply(this, arguments);';  }   return fn; }"
"../test-repos/theintern_leadfoot/src/lib/util.ts","trimStack","{  return stack.replace(/^[^\n]+/, ''); }"
"../test-repos/theintern_leadfoot/src/Server.ts","assertSelected","{       return function(actual: any) {        if (expected !== actual) {         throw new Error('unexpected selection state');        }       };      }"
"../test-repos/theintern_leadfoot/src/Server.ts","isMac","{  return (   capabilities.platform === 'MAC' && capabilities.platformName !== 'ios'  ); }"
"../test-repos/theintern_leadfoot/src/Server.ts","isMsEdge","{  if (capabilities.browserName !== 'MicrosoftEdge') {   return false;  }   return isValidVersion(capabilities, minOrExactVersion, maxVersion); }"
"../test-repos/theintern_leadfoot/src/Server.ts","isInternetExplorer","{  if (capabilities.browserName !== 'internet explorer') {   return false;  }   return isValidVersion(capabilities, minOrExactVersion, maxVersion); }"
"../test-repos/theintern_leadfoot/src/Server.ts","isSafari","{  if (capabilities.browserName !== 'safari') {   return false;  }   return isValidVersion(capabilities, minOrExactVersion, maxVersion); }"
"../test-repos/theintern_leadfoot/src/Server.ts","isFirefox","{  if (capabilities.browserName !== 'firefox') {   return false;  }   return isValidVersion(capabilities, minOrExactVersion, maxVersion); }"
"../test-repos/theintern_leadfoot/src/Server.ts","isValidVersion","{  if (minOrExactVersion != null) {   const version = parseFloat(    (capabilities.version || capabilities.browserVersion)!   );    if (maxVersion != null) {    if (version < minOrExactVersion) {     return false;    }    if (version >= maxVersion) {     return false;    }   } else if (version !== minOrExactVersion) {    return false;   }  }   return true; }"
"../test-repos/theintern_leadfoot/src/Server.ts","noop","{}"
"../test-repos/theintern_leadfoot/src/Server.ts","returnValue","{  return response.value; }"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","pollUntil","no body"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","pollUntil","no body"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","pollUntil","{  let args: any[] | undefined;   if (typeof argsOrTimeout === 'number') {   pollInterval = timeout;   timeout = argsOrTimeout;  } else {   args = argsOrTimeout;  }   args = args || [];  pollInterval = pollInterval || 67;   return function(this: Command<any>) {   const session = this.session;   let originalTimeout: number;    return session.getExecuteAsyncTimeout().then(function(currentTimeout) {    let resultOrError: T | Error;     function storeResult(result: any) {     resultOrError = result;    }     function finish() {     if (resultOrError instanceof Error) {      throw resultOrError;     }     if (resultOrError == null) {      const error = new Error('Polling timed out with no result');      error.name = 'ScriptTimeout';      throw error;     }     return resultOrError;    }     function cleanup() {     if (!isNaN(originalTimeout)) {      return session       .setExecuteAsyncTimeout(originalTimeout)       .then(finish);     }     return finish();    }     if (!isNaN(<number>timeout)) {     originalTimeout = currentTimeout;    } else {     timeout = currentTimeout;    }     return session     .setExecuteAsyncTimeout(timeout!)     .then(function() {      /* jshint maxlen:140 */      return session.executeAsync(       /* istanbul ignore next */ function(        poller: string | Function,        args: any[],        timeout: number,        pollInterval: number,        done: Function       ): void {        /* jshint evil:true */        poller = <Function>new Function(<string>poller);         const endTime = Number(new Date()) + timeout;         (function poll(this: any) {         const result = poller.apply(this, args);          /*jshint evil:true */         if (result != null) {          done(result);         } else if (Number(new Date()) < endTime) {          setTimeout(poll, pollInterval);         } else {          done(null);         }        })();       },       [        util.toExecuteString(poller),        args,        timeout,        pollInterval       ]      );     })     .then(storeResult, storeResult)     .then(cleanup, cleanup);   });  }; }"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","storeResult","{     resultOrError = result;    }"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","finish","{     if (resultOrError instanceof Error) {      throw resultOrError;     }     if (resultOrError == null) {      const error = new Error('Polling timed out with no result');      error.name = 'ScriptTimeout';      throw error;     }     return resultOrError;    }"
"../test-repos/theintern_leadfoot/src/helpers/pollUntil.ts","cleanup","{     if (!isNaN(originalTimeout)) {      return session       .setExecuteAsyncTimeout(originalTimeout)       .then(finish);     }     return finish();    }"
"../test-repos/thundernet8_StarCabinet/src/renderer/rxdb/database.ts","get","{  if (!dbPromise) {  dbPromise = _create(dbName);  }  return dbPromise; }"
"../test-repos/thundernet8_StarCabinet/src/renderer/utils/dbName.ts","getDBName","{  return `scdb4${MD5(username)}`; // database name include username to differentiate }"
"../test-repos/thundernet8_StarCabinet/src/renderer/store/index.ts","getStore","{  const globalStore = new GlobalStore();  const store = {  global: globalStore,  main: new MainStore(globalStore)  };   return store; }"
"../test-repos/torokmark_design_patterns_in_typescript/interpreter/demo.ts","show","{    var context: InterpreterPattern.Context = new InterpreterPattern.Context(),     list = [],     i = 0,     max;     list.push(new InterpreterPattern.NonterminalExpression());    list.push(new InterpreterPattern.NonterminalExpression());    list.push(new InterpreterPattern.NonterminalExpression());    list.push(new InterpreterPattern.TerminalExpression());    list.push(new InterpreterPattern.NonterminalExpression());    list.push(new InterpreterPattern.NonterminalExpression());    list.push(new InterpreterPattern.TerminalExpression());    list.push(new InterpreterPattern.TerminalExpression());     for (i = 0, max = list.length; i < max; i += 1) {     list[i].interpret(context);    }     }"
"../test-repos/torokmark_design_patterns_in_typescript/template_method/demo.ts","show","{    var c1: TemplateMethodPattern.ConcreteClass1 = new TemplateMethodPattern.ConcreteClass1(),     c2: TemplateMethodPattern.ConcreteClass2 = new TemplateMethodPattern.ConcreteClass2();     c1.templateMethod();    c2.templateMethod();    }"
"../test-repos/torokmark_design_patterns_in_typescript/main.ts","printMenu","{   var menu = '= Creational Patterns == \n' +      ' 1: Singleton \n' +      ' 2: Abstract factory \n' +      ' 3: Factory method \n' +      ' 4: Builder \n' +      ' 5: Prototype \n\n' +      '= Structural Patterns == \n' +      ' 6: Adapter \n' +      ' 7: Bridge \n' +      ' 8: Composite \n' +      ' 9: Decorator \n' +      ' 10: Facade \n' +      ' 11: Flyweight \n' +      ' 12: Proxy \n\n' +      '= Behavioral Patterns == \n' +      ' 13: Chain of responsibility \n' +      ' 14: Command \n' +      ' 15: Interpreter \n' +      ' 16: Iterator \n' +      ' 17: Mediator \n' +      ' 18: Memento \n' +      ' 19: Observer \n' +      ' 20: State \n' +      ' 21: Strategy \n' +      ' 22: Template method \n' +      ' 23: Visitor \n';     console.log('\n\n');   console.log('==== Choose one pattern to demonstrate ====');   console.log('\n');   console.log(menu);  }"
"../test-repos/torokmark_design_patterns_in_typescript/main.ts","menu","{   var rl = readline.createInterface({      input: process.stdin,      output: process.stdout    });    printMenu();   rl.question('Which pattern would you like to check? ', function(answer) {    switch(+answer) {     case 1 : show(SingletonPattern); break;     case 2 : show(AbstractFactoryPattern); break;     case 3 : show(FactoryMethodPattern); break;     case 4 : show(BuilderPattern); break;     case 5 : show(PrototypePattern); break;     case 6 : show(AdapterPattern); break;     case 7 : show(BridgePattern); break;     case 8 : show(CompositePattern); break;     case 9 : show(DecoratorPattern); break;     case 10 : show(FacadePattern); break;     case 11 : show(FlyweightPattern); break;     case 12 : show(ProxyPattern); break;     case 13 : show(ChainOfResponsibilityPattern); break;     case 14 : show(CommandPattern); break;     case 15 : show(InterpreterPattern); break;     case 16 : show(IteratorPattern); break;     case 17 : show(MediatorPattern); break;     case 18 : show(MementoPattern); break;     case 19 : show(ObserverPattern); break;     case 20 : show(StatePattern); break;     case 21 : show(StrategyPattern); break;     case 22 : show(TemplateMethodPattern); break;     case 23 : show(VisitorPattern); break;     default : break;    }    rl.close();   });  }"
"../test-repos/torokmark_design_patterns_in_typescript/main.ts","show","{   Pattern.Demo.show();  }"
"../test-repos/torokmark_design_patterns_in_typescript/proxy/demo.ts","show","{    var proxy1: ProxyPattern.Proxy = new ProxyPattern.Proxy('proxy1'),     proxy2: ProxyPattern.Proxy = new ProxyPattern.Proxy('proxy2');     proxy1.doAction();    proxy1.doAction();    proxy2.doAction();    proxy2.doAction();    proxy1.doAction();    }"
"../test-repos/torokmark_design_patterns_in_typescript/decorator/demo.ts","show","{    var decorator1: DecoratorPattern.Decorator = new DecoratorPattern.ConcreteDecorator(1, new DecoratorPattern.ConcreteComponent('Comp1'));     decorator1.operation();   }"
"../test-repos/torokmark_design_patterns_in_typescript/bridge/demo.ts","show","{    var abstractionA: BridgePattern.Abstraction = new BridgePattern.RefinedAbstractionA(new BridgePattern.ConcreteImplementorA());    var abstractionB: BridgePattern.Abstraction = new BridgePattern.RefinedAbstractionB(new BridgePattern.ConcreteImplementorB());     abstractionA.callIt('abstractionA');    abstractionB.callIt('abstractionB');   }"
"../test-repos/torokmark_design_patterns_in_typescript/facade/demo.ts","show","{    var facade: FacadePattern.Facade = new FacadePattern.Facade();     facade.operation1();     facade.operation2();   }"
"../test-repos/torokmark_design_patterns_in_typescript/observer/demo.ts","show","{    var sub: ObserverPattern.ConcreteSubject = new ObserverPattern.ConcreteSubject();     sub.register(new ObserverPattern.ConcreteObserver(sub, 'Jancsi'));    sub.register(new ObserverPattern.ConcreteObserver(sub, 'Julcsa'));    sub.register(new ObserverPattern.ConcreteObserver(sub, 'Marcsa'));     sub.SubjectState = 123;    sub.notify();    }"
"../test-repos/torokmark_design_patterns_in_typescript/memento/demo.ts","show","{    var state: MementoPattern.State = new MementoPattern.State('... State '),     originator: MementoPattern.Originator = new MementoPattern.Originator(state),     careTaker: MementoPattern.CareTaker = new MementoPattern.CareTaker();     careTaker.Memento = originator.createMemento();    originator.State = new MementoPattern.State('something else...');     originator.setMemento(careTaker.Memento);   }"
"../test-repos/torokmark_design_patterns_in_typescript/adapter/demo.ts","show","{    var adapter: AdapterPattern.Adapter = new AdapterPattern.Adapter();    adapter.call();   }"
"../test-repos/torokmark_design_patterns_in_typescript/prototype/demo.ts","show","{    var builder : PrototypePattern.Builder = new PrototypePattern.Builder();   var i = 0;  for (i = 1; i <= 3; i += 1) {   console.log(builder.createOne('c' + i).toString());  }    }"
"../test-repos/torokmark_design_patterns_in_typescript/state/demo.ts","show","{    var context: StatePattern.Context = new StatePattern.Context(new StatePattern.ConcreteStateA());    context.request();    context.request();    context.request();    context.request();    context.request();    context.request();    context.request();    context.request();    }"
"../test-repos/torokmark_design_patterns_in_typescript/composite/demo.ts","show","{    var leaf1 = new CompositePattern.Leaf('1'),     leaf2 = new CompositePattern.Leaf('2'),     leaf3 = new CompositePattern.Leaf('3'),     composite1 = new CompositePattern.Composite('Comp1'),    composite2 = new CompositePattern.Composite('Comp2');     composite1.add(leaf1);    composite1.add(leaf2);    composite1.add(leaf3);     composite1.remove(2);     composite2.add(leaf1);    composite2.add(leaf3);     composite1.operation();    composite2.operation();   }"
"../test-repos/torokmark_design_patterns_in_typescript/factory_method/demo.ts","show","{    var a: FactoryMethodPattern.AbstractProduct = FactoryMethodPattern.ProductFactory.createProduct('A');    var b: FactoryMethodPattern.AbstractProduct = FactoryMethodPattern.ProductFactory.createProduct('B');     console.log(a.method());    console.log(b.method());   }"
"../test-repos/torokmark_design_patterns_in_typescript/iterator/demo.ts","show","{    var nArray = [1, 7, 21, 657, 3, 2, 765, 13, 65],     numbers: IteratorPattern.Numbers = new IteratorPattern.Numbers(nArray),     it: IteratorPattern.ConcreteIterator = <IteratorPattern.ConcreteIterator>numbers.createIterator();     while (it.hasNext()) {     console.log(it.next());    }    }"
"../test-repos/torokmark_design_patterns_in_typescript/chain_of_responsibility/demo.ts","show","{    var h1: ChainOfResponsibilityPattern.Handler,     h2: ChainOfResponsibilityPattern.Handler,     h3: ChainOfResponsibilityPattern.Handler,     reqs: number[],     i: number,     max: number;     reqs = [2, 7, 23, 34, 4, 5, 8, 3];     h1 = new ChainOfResponsibilityPattern.ConcreteHandler1(3);    h2 = new ChainOfResponsibilityPattern.ConcreteHandler2(7);    h3 = new ChainOfResponsibilityPattern.ConcreteHandler3(20);     h1.setHandler(h2);    h2.setHandler(h3);     for (i = 0, max = reqs.length; i < max; i += 1) {     h1.operation('operation is fired!', reqs[i]);    }    }"
"../test-repos/torokmark_design_patterns_in_typescript/visitor/demo.ts","show","{    var objs: VisitorPattern.Objs = new VisitorPattern.Objs();     objs.attach(new VisitorPattern.ConcreteElement1());    objs.attach(new VisitorPattern.ConcreteElement2());     var v1: VisitorPattern.ConcreteVisitor1 = new VisitorPattern.ConcreteVisitor1(),     v2: VisitorPattern.ConcreteVisitor2 = new VisitorPattern.ConcreteVisitor2();     objs.operate(v1);    objs.operate(v2);    }"
"../test-repos/torokmark_design_patterns_in_typescript/singleton/demo.ts","show","{    var singleton1 = SingletonPattern.Singleton.Instance();    var singleton2 = SingletonPattern.Singleton.Instance();     if (singleton1 === singleton2) {     console.log('two singletons are equivalent');    } else {     console.log('two singletons are not equivalent');    }   }"
"../test-repos/torokmark_design_patterns_in_typescript/command/demo.ts","show","{    var receiver: CommandPattern.Receiver = new CommandPattern.Receiver(),     command1: CommandPattern.Command = new CommandPattern.ConcreteCommand1(receiver),     command2: CommandPattern.Command = new CommandPattern.ConcreteCommand2(receiver),     invoker : CommandPattern.Invoker = new CommandPattern.Invoker();     invoker.storeAndExecute(command1);    invoker.storeAndExecute(command2);     }"
"../test-repos/torokmark_design_patterns_in_typescript/abstract_factory/demo.ts","show","{  // Abstract factory1    var factory1: AbstractFactoryPattern.AbstractFactory = new AbstractFactoryPattern.ConcreteFactory1();  var tester1: AbstractFactoryPattern.Tester = new AbstractFactoryPattern.Tester(factory1);    tester1.test();     // Abstract factory2    var factory2: AbstractFactoryPattern.AbstractFactory = new AbstractFactoryPattern.ConcreteFactory2();    var tester2: AbstractFactoryPattern.Tester = new AbstractFactoryPattern.Tester(factory2);    tester2.test();   }"
"../test-repos/torokmark_design_patterns_in_typescript/flyweight/demo.ts","show","{    var factory: FlyweightPattern.FlyweightFactory = new FlyweightPattern.FlyweightFactory(),     conc1: FlyweightPattern.ConcreteFlyweight = <FlyweightPattern.ConcreteFlyweight>factory.getFlyweight('conc1'),    conc2: FlyweightPattern.ConcreteFlyweight = <FlyweightPattern.ConcreteFlyweight>factory.getFlyweight('conc2');     conc1.operation('1');    conc2.operation('2');   }"
"../test-repos/torokmark_design_patterns_in_typescript/builder/demo.ts","show","{    var u: BuilderPattern.User = new BuilderPattern.UserBuilder('Jancsi')  .setAge(12)  .setPhone('0123456789')  .setAddress('asdf')  .build();  console.log(u.Name + ' ' + u.Age + ' ' + u.Phone + ' ' + u.Address);   }"
"../test-repos/torokmark_design_patterns_in_typescript/mediator/demo.ts","show","{    var cm: MediatorPattern.ConcreteMediator = new MediatorPattern.ConcreteMediator(),     c1: MediatorPattern.ConcreteColleagueA = new MediatorPattern.ConcreteColleagueA(cm),     c2: MediatorPattern.ConcreteColleagueB = new MediatorPattern.ConcreteColleagueB(cm);     cm.concreteColleagueA = c1;    cm.concreteColleagueB = c2;     c1.send('`send` of ConcreteColleagueA is being called!');    c2.send('`send` of ConcreteColleagueB is being called!');    }"
"../test-repos/torokmark_design_patterns_in_typescript/strategy/demo.ts","show","{    var context: StrategyPattern.Context = new StrategyPattern.Context(new StrategyPattern.ConcreteStrategy1());     context.executeStrategy();     context = new StrategyPattern.Context(new StrategyPattern.ConcreteStrategy2());    context.executeStrategy();     context = new StrategyPattern.Context(new StrategyPattern.ConcreteStrategy3());    context.executeStrategy();     }"
"../test-repos/troyanskiy_ngx-resource/src/ResourceAction.ts","ResourceAction","{   methodOptions = methodOptions || {};   if (methodOptions.method === undefined) {  methodOptions.method = RequestMethod.Get;  }   return function (target: Resource, propertyKey: string) {   (<any>target)[propertyKey] = function (...args: any[]): ResourceResult<any> | ResourceModel<Resource> {   let data: any = null;  let params: any = null;  let callback: any = null;  let onError: any = null;   args.forEach((arg: any) => {   if (typeof arg === 'function') {  if (callback) {  onError = arg;  } else {  callback = arg;  }  } else {  if (data) {  params = arg;  } else {  data = arg;  }  }   });   const options = Object.assign({}, this.getResourceOptions(), methodOptions);   return this.$resourceAction(data, params, callback, onError, options);   };   };  }"
"../test-repos/troyanskiy_ngx-resource/src/ResourceParams.ts","ResourceParams","{   return function (target: Type<Resource>) {    target.prototype.getResourceOptions = function () {  return params;  };   if (params.add2Provides === undefined && ResourceGlobalConfig.add2Provides !== null) {  params.add2Provides = ResourceGlobalConfig.add2Provides;  }   if (params.add2Provides !== false) {  ResourceProviders.add(target, params.providersSubSet);  }   if (typeof params.removeTrailingSlash !== 'undefined') {  target.prototype.removeTrailingSlash = function () {  return !!params.removeTrailingSlash;  };  }   if (params.url) {  target.prototype.$_getUrl = function () {  return params.url;  };  }   if (params.path) {  target.prototype.$_getPath = function () {  return params.path;  };  }   if (params.headers) {  target.prototype.$_getHeaders = function () {  return params.headers;  };  }   if (params.params) {  target.prototype.$_getParams = function () {  return params.params;  };  }   if (params.data) {  target.prototype.$_getData = function () {  return params.data;  };  }   }; }"
"../test-repos/troyanskiy_ngx-resource/src/ResourceODATA.ts","ResourceODATAParams","{  const injectable = Injectable();  const zuper = ResourceParams(params);   return function (target: Type<Resource>) {  injectable(target);  zuper(target);  target.prototype.getEntityName = function () {  if (params.name) {  return params.name;  }  return typeof params.entity === 'string' ? params.entity : params.entity.name;  };  }; }"
"../test-repos/typestack_routing-controllers/test/functional/test-utils.ts","assertRequest","no body"
"../test-repos/typestack_routing-controllers/test/functional/test-utils.ts","assertRequest","no body"
"../test-repos/typestack_routing-controllers/test/functional/test-utils.ts","assertRequest","no body"
"../test-repos/typestack_routing-controllers/test/functional/test-utils.ts","assertRequest","{  const args = arguments.length;   ports.forEach(port => {   it('asserting port ' + port, async() => {  let unhandledRejection: Error = undefined;  const captureRejection = (e: Error) => { unhandledRejection = e; };  process.on('unhandledRejection', captureRejection);   try {  let r;  if (args === 4) {  r = await chakram[method](`http://127.0.0.1:${port}/${route}`).then(dataOrCallback as Function);  }  else if (args === 5) {  r = await chakram[method](`http://127.0.0.1:${port}/${route}`, dataOrCallback as any).then(dataOrRequestOptionsOrCallback as Function);  }  else if (args === 6) {  r = await chakram[method](`http://127.0.0.1:${port}/${route}`, dataOrCallback as any, dataOrRequestOptionsOrCallback as any).then(maybeCallback);  }  else {  throw new Error('No assertion has been performed');  }   if (unhandledRejection) {  const e = new Error('There was an unhandled rejection while processing the request');  e.stack += '\nCaused by: ' + unhandledRejection.stack;  throw e;  }   return r;  }  finally {  process.removeListener('unhandledRejection', captureRejection);  }  });  });  }"
"../test-repos/typestack_routing-controllers/sample/sample14-custom-decorator/UserFromSession.ts","UserFromSession","{  return createParamDecorator({  required: options && options.required ? true : false,  value: action => {  // perform queries based on token from request headers  // const token = action.request.headers['authorization'];  // return database.findUserByToken(token);  return new User(1, 'Johny', 'Cage');  }  }); }"
"../test-repos/typestack_routing-controllers/src/decorator/State.ts","State","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'state',  object: object,  method: methodName,  index: index,  name: objectName,  parse: false, // it does not make sense for Session to be parsed  required: true, // when we demand session object, it must exist (working session middleware)  classTransform: undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Middleware.ts","Middleware","{  return function (target: Function) {  getMetadataArgsStorage().middlewares.push({  target: target,  type: options && options.type ? options.type : 'before',  global: true,  priority: options && options.priority !== undefined ? options.priority : 0  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Get.ts","Get","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Get.ts","Get","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Get.ts","Get","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().actions.push({  type: 'get',  target: object.constructor,  method: methodName,  route: route  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/UploadedFiles.ts","UploadedFiles","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'files',  object: object,  method: methodName,  index: index,  name: name,  parse: false,  required: options ? options.required : undefined,  extraOptions: options ? options.options : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/UseBefore.ts","UseBefore","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseBefore.ts","UseBefore","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseBefore.ts","UseBefore","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseBefore.ts","UseBefore","{  return function (objectOrFunction: Object|Function, methodName?: string) {  middlewares.forEach(middleware => {  getMetadataArgsStorage().uses.push({  target: methodName ? objectOrFunction.constructor : objectOrFunction as Function,  method: methodName,  middleware: middleware,  afterAction: false  });  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Ctx.ts","Ctx","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'context',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/QueryParam.ts","QueryParam","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'query',  object: object,  method: methodName,  index: index,  name: name,  parse: options ? options.parse : false,  required: options ? options.required : undefined,  classTransform: options ? options.transform : undefined,  explicitType: options ? options.type : undefined,  validate: options ? options.validate : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/CookieParam.ts","CookieParam","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'cookie',  object: object,  method: methodName,  index: index,  name: name,  parse: options ? options.parse : false,  required: options ? options.required : undefined,  explicitType: options ? options.type : undefined,  classTransform: options ? options.transform : undefined,  validate: options ? options.validate : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Req.ts","Req","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'request',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Interceptor.ts","Interceptor","{  return function (target: Function) {  getMetadataArgsStorage().interceptors.push({  target: target,  global: true,  priority: options && options.priority ? options.priority : 0  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/BodyParam.ts","BodyParam","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'body-param',  object: object,  method: methodName,  index: index,  name: name,  parse: options ? options.parse : false,  required: options ? options.required : undefined,  explicitType: options ? options.type : undefined,  classTransform: options ? options.transform : undefined,  validate: options ? options.validate : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/UploadedFile.ts","UploadedFile","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'file',  object: object,  method: methodName,  index: index,  name: name,  parse: false,  required: options ? options.required : undefined,  extraOptions: options ? options.options : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/ResponseClassTransformOptions.ts","ResponseClassTransformOptions","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'response-class-transform-options',  value: options,  target: object.constructor,  method: methodName  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/HeaderParam.ts","HeaderParam","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'header',  object: object,  method: methodName,  index: index,  name: name,  parse: options ? options.parse : false,  required: options ? options.required : undefined,  classTransform: options ? options.transform : undefined,  explicitType: options ? options.type : undefined,  validate: options ? options.validate : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Location.ts","Location","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'location',  target: object.constructor,  method: methodName,  value: url  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/HeaderParams.ts","HeaderParams","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'headers',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Param.ts","Param","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'param',  object: object,  method: methodName,  index: index,  name: name,  parse: false, // it does not make sense for Param to be parsed  required: true, // params are always required, because if they are missing router will not match the route  classTransform: undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Session.ts","Session","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Session.ts","Session","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Session.ts","Session","{  let propertyName: string|undefined;  let options: ParamOptions|undefined;  if (typeof optionsOrObjectName === 'string') {  propertyName = optionsOrObjectName;  options = paramOptions || {};  } else {  options = optionsOrObjectName || {};  }   return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'session',  object: object,  method: methodName,  index: index,  name: propertyName,  parse: false, // it makes no sense for Session object to be parsed as json  required: options.required !== undefined ? options.required : true,  classTransform: options.transform,  validate: options.validate !== undefined ? options.validate : false,  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/CurrentUser.ts","CurrentUser","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'current-user',  object: object,  method: methodName,  index: index,  parse: false,  required: options ? options.required : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/JsonController.ts","JsonController","{  return function (object: Function) {  getMetadataArgsStorage().controllers.push({  type: 'json',  target: object,  route: baseRoute  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/HttpCode.ts","HttpCode","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'success-code',  target: object.constructor,  method: methodName,  value: code  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/ContentType.ts","ContentType","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'content-type',  target: object.constructor,  method: methodName,  value: contentType  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/OnNull.ts","OnNull","no body"
"../test-repos/typestack_routing-controllers/src/decorator/OnNull.ts","OnNull","no body"
"../test-repos/typestack_routing-controllers/src/decorator/OnNull.ts","OnNull","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'on-null',  target: object.constructor,  method: methodName,  value: codeOrError  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Redirect.ts","Redirect","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'redirect',  target: object.constructor,  method: methodName,  value: url  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Render.ts","Render","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'rendered-template',  target: object.constructor,  method: methodName,  value: template  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Header.ts","Header","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().responseHandlers.push({  type: 'header',  target: object.constructor,  method: methodName,  value: name,  secondaryValue: value  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Body.ts","Body","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'body',  object: object,  method: methodName,  index: index,  parse: false,  required: options ? options.required : undefined,  classTransform: options ? options.transform : undefined,  validate: options ? options.validate : undefined,  explicitType: options ? options.type : undefined,  extraOptions: options ? options.options : undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/UseAfter.ts","UseAfter","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseAfter.ts","UseAfter","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseAfter.ts","UseAfter","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseAfter.ts","UseAfter","{  return function (objectOrFunction: Object|Function, methodName?: string) {  middlewares.forEach(middleware => {  getMetadataArgsStorage().uses.push({  target: methodName ? objectOrFunction.constructor : objectOrFunction as Function,  method: methodName,  middleware: middleware,  afterAction: true  });  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Controller.ts","Controller","{  return function (object: Function) {  getMetadataArgsStorage().controllers.push({  type: 'default',  target: object,  route: baseRoute  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/CookieParams.ts","CookieParams","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'cookies',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Params.ts","Params","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'params',  object: object,  method: methodName,  index: index,  parse: false, // it does not make sense for Param to be parsed  required: false,  classTransform: undefined  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Res.ts","Res","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'response',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/UseInterceptor.ts","UseInterceptor","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseInterceptor.ts","UseInterceptor","no body"
"../test-repos/typestack_routing-controllers/src/decorator/UseInterceptor.ts","UseInterceptor","{  return function (objectOrFunction: Object|Function, methodName?: string) {  interceptors.forEach(interceptor => {  getMetadataArgsStorage().useInterceptors.push({  interceptor: interceptor,  target: methodName ? objectOrFunction.constructor : objectOrFunction as Function,  method: methodName,  });  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Post.ts","Post","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Post.ts","Post","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Post.ts","Post","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().actions.push({  type: 'post',  target: object.constructor,  method: methodName,  route: route  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Patch.ts","Patch","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Patch.ts","Patch","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Patch.ts","Patch","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().actions.push({  type: 'patch',  target: object.constructor,  method: methodName,  route: route  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Delete.ts","Delete","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Delete.ts","Delete","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Delete.ts","Delete","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().actions.push({  type: 'delete',  target: object.constructor,  method: methodName,  route: route  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/Put.ts","Put","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Put.ts","Put","no body"
"../test-repos/typestack_routing-controllers/src/decorator/Put.ts","Put","{  return function (object: Object, methodName: string) {  getMetadataArgsStorage().actions.push({  type: 'put',  target: object.constructor,  method: methodName,  route: route  });  }; }"
"../test-repos/typestack_routing-controllers/src/decorator/QueryParams.ts","QueryParams","{  return function (object: Object, methodName: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'queries',  object: object,  method: methodName,  index: index,  parse: false,  required: false  });  }; }"
"../test-repos/typestack_routing-controllers/src/util/importClassesFromDirectories.ts","importClassesFromDirectories","{   const loadFileClasses = function (exported: any, allLoaded: Function[]) {  if (exported instanceof Function) {  allLoaded.push(exported);  } else if (exported instanceof Array) {  exported.forEach((i: any) => loadFileClasses(i, allLoaded));  } else if (exported instanceof Object || typeof exported === 'object') {  Object.keys(exported).forEach(key => loadFileClasses(exported[key], allLoaded));  }   return allLoaded;  };   const allFiles = directories.reduce((allDirs, dir) => {  return allDirs.concat(require('glob').sync(path.normalize(dir)));  }, [] as string[]);   const dirs = allFiles  .filter(file => {  const dtsExtension = file.substring(file.length - 5, file.length);  return formats.indexOf(path.extname(file)) !== -1 && dtsExtension !== '.d.ts';  })  .map(file => {  return require(file);  });   return loadFileClasses(dirs, []); }"
"../test-repos/typestack_routing-controllers/src/util/runInSequence.ts","runInSequence","{  const results: U[] = [];  return collection.reduce((promise, item) => {  return promise.then(() => {  return callback(item);  }).then(result => {  results.push(result);  });  }, Promise.resolve()).then(() => {  return results;  }); }"
"../test-repos/typestack_routing-controllers/src/util/isPromiseLike.ts","isPromiseLike","{  return arg != null && typeof arg === 'object' && typeof arg.then === 'function'; }"
"../test-repos/typestack_routing-controllers/src/container.ts","useContainer","{  userContainer = iocContainer;  userContainerOptions = options; }"
"../test-repos/typestack_routing-controllers/src/container.ts","getFromContainer","{  if (userContainer) {  try {  const instance = userContainer.get(someClass);  if (instance)  return instance;   if (!userContainerOptions || !userContainerOptions.fallback)  return instance;   } catch (error) {  if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)  throw error;  }  }  return defaultContainer.get<T>(someClass); }"
"../test-repos/typestack_routing-controllers/src/index.ts","getMetadataArgsStorage","{  if (!(global as any).routingControllersMetadataArgsStorage)  (global as any).routingControllersMetadataArgsStorage = new MetadataArgsStorage();   return (global as any).routingControllersMetadataArgsStorage; }"
"../test-repos/typestack_routing-controllers/src/index.ts","useExpressServer","{  const driver = new ExpressDriver(expressApp);  return createServer(driver, options); }"
"../test-repos/typestack_routing-controllers/src/index.ts","createExpressServer","{  const driver = new ExpressDriver();  return createServer(driver, options); }"
"../test-repos/typestack_routing-controllers/src/index.ts","useKoaServer","{  const driver = new KoaDriver(koaApp);  return createServer(driver, options); }"
"../test-repos/typestack_routing-controllers/src/index.ts","createKoaServer","{  const driver = new KoaDriver();  return createServer(driver, options); }"
"../test-repos/typestack_routing-controllers/src/index.ts","createServer","{  createExecutor(driver, options);  return driver.app; }"
"../test-repos/typestack_routing-controllers/src/index.ts","createExecutor","{   // import all controllers and middlewares and error handlers (new way)  let controllerClasses: Function[];  if (options && options.controllers && options.controllers.length) {  controllerClasses = (options.controllers as any[]).filter(controller => controller instanceof Function);  const controllerDirs = (options.controllers as any[]).filter(controller => typeof controller === 'string');  controllerClasses.push(...importClassesFromDirectories(controllerDirs));  }  let middlewareClasses: Function[];  if (options && options.middlewares && options.middlewares.length) {  middlewareClasses = (options.middlewares as any[]).filter(controller => controller instanceof Function);  const middlewareDirs = (options.middlewares as any[]).filter(controller => typeof controller === 'string');  middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));  }  let interceptorClasses: Function[];  if (options && options.interceptors && options.interceptors.length) {  interceptorClasses = (options.interceptors as any[]).filter(controller => controller instanceof Function);  const interceptorDirs = (options.interceptors as any[]).filter(controller => typeof controller === 'string');  interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));  }   if (options && options.development !== undefined) {  driver.developmentMode = options.development;  } else {  driver.developmentMode = process.env.NODE_ENV !== 'production';  }   if (options.defaultErrorHandler !== undefined) {  driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;  } else {  driver.isDefaultErrorHandlingEnabled = true;  }   if (options.classTransformer !== undefined) {  driver.useClassTransformer = options.classTransformer;  } else {  driver.useClassTransformer = true;  }   if (options.validation !== undefined) {  driver.enableValidation = !!options.validation;  if (options.validation instanceof Object)  driver.validationOptions = options.validation as ValidationOptions;   } else {  driver.enableValidation = true;  }   driver.classToPlainTransformOptions = options.classToPlainTransformOptions;  driver.plainToClassTransformOptions = options.plainToClassTransformOptions;   if (options.errorOverridingMap !== undefined)  driver.errorOverridingMap = options.errorOverridingMap;   if (options.routePrefix !== undefined)  driver.routePrefix = options.routePrefix;   if (options.currentUserChecker !== undefined)  driver.currentUserChecker = options.currentUserChecker;   if (options.authorizationChecker !== undefined)  driver.authorizationChecker = options.authorizationChecker;   driver.cors = options.cors;   // next create a controller executor  new RoutingControllers(driver, options)  .initialize()  .registerInterceptors(interceptorClasses)  .registerMiddlewares('before', middlewareClasses)  .registerControllers(controllerClasses)  .registerMiddlewares('after', middlewareClasses); // todo: register only for loaded controllers? }"
"../test-repos/typestack_routing-controllers/src/index.ts","createParamDecorator","{  return function(object: Object, method: string, index: number) {  getMetadataArgsStorage().params.push({  type: 'custom-converter',  object: object,  method: method,  index: index,  parse: false,  required: options.required,  transform: options.value  });  }; }"
"../test-repos/valor-software_ng2-file-upload/scripts/matchers.ts","buildError","{  return function (actual, className) {  const orNot = isNot ? 'not ' : '';  return {  pass: actual.classList.contains(className) === !isNot,  message: `Expected ${actual.outerHTML} ${orNot} to contain the CSS class '${className}'`  };  };  }"
"../test-repos/valor-software_ng2-file-upload/src/spec/file-drop.directive.spec.ts","getFakeEventData","{  return {  dataTransfer: {  files: [ 'foo.bar' ],  types: [ 'Files' ]  },  preventDefault: () => undefined,  stopPropagation: () => undefined  } }"
"../test-repos/valor-software_ng2-file-upload/src/file-upload/file-like-object.class.ts","isElement","{  return !!(node && (node.nodeName || node.prop && node.attr && node.find)); }"
"../test-repos/valor-software_ng2-file-upload/src/file-upload/file-uploader.class.ts","isFile","{  return (File && value instanceof File); }"
"../test-repos/wordpress-clients_wp-api-angular/demo/module.ts","WpApiLoaderFactory","{  return new WpApiStaticLoader(http, config.baseUrl); }"
"../test-repos/wordpress-clients_wp-api-angular/src/wp-api-angular.ts","WpApiLoaderFactory","{  return new WpApiStaticLoader(http); }"
"../test-repos/wordpress-clients_wp-api-angular/src/utils.ts","stripTrailingSlash","{  // Is the last char a /  if (value.substring(value.length - 1, value.length) === '/') {  return value.substring(0, value.length - 1);  } else {  return value;  } }"
